/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/regenerator-runtime/runtime-module.js":
/*!************************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime-module.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzP2JiZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime-module.js\n");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcz85NmNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXG4gIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKClcbik7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n");

/***/ }),

/***/ "./src/core/Po.js":
/*!************************!*\
  !*** ./src/core/Po.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\r\n    deepClone,\r\n    extend,\r\n    GetAttrElement,\r\n    proxyArr\r\n} = __webpack_require__(/*! ../util/util */ \"./src/util/util.js\");\r\nconst TplEng = __webpack_require__(/*! ./template */ \"./src/core/template.js\");\r\nconst Jsvm = __webpack_require__(/*! ../util/JsVm */ \"./src/util/JsVm.js\");\r\n\r\n// const debugObj = require(\"../util/debug\")\r\n\r\nlet replaceSubNode = (html, subPos, supper, localPo) => {\r\n    let resloveData = attrs => {\r\n        let res = {}\r\n        if (attrs == undefined || attrs.length == 0) return res\r\n        let arr = attrs.split(\" \")\r\n        let re = new RegExp(`(.+?)=([\"'])(.+?)\\\\2`)\r\n        for (let attr of arr) {\r\n            if (attr.trim() == \"\") continue\r\n            let reg$arr = re.exec(attr)\r\n            res[reg$arr[1]] = reg$arr[3]\r\n        }\r\n        return res\r\n    }\r\n    let reslove = html\r\n    let localCur = 0\r\n    for (let subName in subPos) {\r\n        let sub = subPos[subName]\r\n        let re = new RegExp(\"<(\" + subName + \")(( [^<> ]*)*)>([^<>]*)<\\/\" + subName + \">\", \"gi\")\r\n        let subArr = html.match(re)\r\n        if (!subArr) continue\r\n        for (let _si in subArr) {\r\n            let _s = subArr[_si]\r\n            re = new RegExp(\"<(\" + subName + \")(( [^<> ]*)*)>([^<>]*)<\\/\" + subName + \">\", \"gi\")\r\n            let reg$arr = re.exec(_s)\r\n            let tempData = resloveData(reg$arr[2])\r\n            tempData._content = reg$arr[4]\r\n            if (localPo[localCur] == undefined) {\r\n                localPo.push(sub.Clone(tempData))\r\n            }\r\n            let temp = localPo[localCur].assemble(supper, localCur)\r\n            reslove = reslove.replace(_s, temp)\r\n            localCur += 1\r\n        }\r\n    }\r\n    return reslove\r\n}\r\n\r\nlet _init_DateValueProperty = (data, _ev) => {\r\n    let source = deepClone(data)\r\n    for (let variable in data) {\r\n        let setVal = data[variable];\r\n        let option = {}\r\n        if (Object.prototype.toString.call(setVal) == \"[object Array]\") {\r\n            // #101 length problem\r\n            setVal = proxyArr(setVal, newVal => {\r\n                _ev.emit(\"SET_\" + variable, newVal);\r\n                _ev.emit(\"_rerender_\");\r\n                if (source[variable].length == newVal.length) return\r\n                source[variable] = newVal;\r\n            })\r\n        }\r\n        if (typeof setVal === \"function\") {\r\n            if (/_ev.emit/g.test(setVal.toString()))\r\n                continue\r\n            data[variable] = function() {\r\n                let _resTemp = setVal.apply(data, arguments)\r\n                _ev.emit(\"_rerender_\");\r\n                return _resTemp\r\n            }\r\n            continue;\r\n            // option.get = ()=>{\r\n            //     return setVal(data)\r\n            // }\r\n        } else {\r\n            option.get = () => {\r\n                return source[variable];\r\n            }\r\n        }\r\n        option.set = newVal => {\r\n            if (source[variable] == newVal) return\r\n            source[variable] = newVal;\r\n            _ev.emit(\"SET_\" + variable, newVal);\r\n            _ev.emit(\"_rerender_\");\r\n        }\r\n        Object.defineProperty(data, variable, option)\r\n        data[variable] = setVal;\r\n    }\r\n    return data;\r\n}\r\n\r\nlet hitchOnEv = (_evManger, _on, data, localArr) => {\r\n    for (var event_ in _on) {\r\n        if (_on.hasOwnProperty(event_)) {\r\n            let thisOption = _on[event_],\r\n                evName = thisOption.eventName,\r\n                coStr = thisOption.codeStr,\r\n                that_data = data,\r\n                ele = thisOption.ele,\r\n                withData = {};\r\n            if (ele.attributes[\"PoiId\"] != undefined) {\r\n                let _index = ele.attributes[\"PoiId\"].nodeValue\r\n                withData = localArr[_index].data\r\n            }\r\n            _evManger.on(evName, e => {\r\n                if (e.target === ele) {\r\n                    let dataobj = Object.assign(that_data, {\r\n                        e: e,\r\n                        self: e.target\r\n                    }, withData)\r\n                    // require(\"../util/JsVm.js\").micVm(coStr, that_data);\r\n                    Jsvm.safe(coStr, that_data);\r\n                }\r\n            })\r\n        }\r\n    }\r\n    // on_ev end\r\n}\r\nlet hitchBindEv = (_evManger, _bind, data, localArr) => {\r\n    for (var _ev in _bind) {\r\n        if (_bind.hasOwnProperty(_ev)) {\r\n            let thisOption = _bind[_ev],\r\n                evName = thisOption.eventName,\r\n                coStr = thisOption.codeStr,\r\n                that_data = data,\r\n                ele = thisOption.ele,\r\n                withData = {};\r\n            if (ele.attributes[\"PoiId\"] != undefined) {\r\n                let _index = ele.attributes[\"PoiId\"].nodeValue\r\n                withData = localArr[_index].data\r\n            }\r\n            if (evName == \"class\")\r\n                evName = \"className\"\r\n            ele[evName] = Jsvm.safe(\"return(\" + coStr + \")\", Object.assign(deepClone(withData), that_data));\r\n            // init value\r\n            _evManger.on(\"_rerender_\", () => {\r\n                if (ele && ele.parentNode != null) {\r\n                    // require(\"../util/JsVm.js\").micVm(coStr, that_data);\r\n                    ele[evName] = Jsvm.safe(\"return(\" + coStr + \")\", Object.assign(deepClone(withData), that_data))\r\n                }\r\n            })\r\n        }\r\n    }\r\n};\r\n\r\nlet hitchWath = (watch, _ev) => {\r\n    for (let variable in watch) {\r\n        if (typeof watch[variable] === \"function\") {\r\n            _ev.on(\"SET_\" + variable, (newVal) => {\r\n                watch[variable](newVal);\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\nlet Po = function(template, data, watch, evManger, subPos, mixwith) {\r\n    if (mixwith) {\r\n        extend(data, deepClone(mixwith.$pureData));\r\n    }\r\n    this.$pureData = deepClone(data)\r\n    // tpl\r\n    this.Clone = _data => {\r\n        return {\r\n            $pureData: Object.assign(deepClone(_data), this.$pureData),\r\n            tpl: this.tpl,\r\n            data: _init_DateValueProperty(deepClone(Object.assign(deepClone(_data), deepClone(this.$pureData))), evManger),\r\n            assemble: function(data, _id) {\r\n                return this.tpl.joint(Object.assign(this.data, data), _id)\r\n            }\r\n        }\r\n    }\r\n    // data\r\n    // let dbg = new debugObj(\"_init_DateValueProperty\")\r\n    this.data = _init_DateValueProperty(data, evManger)\r\n    // dbg.log()\r\n    //\r\n    // subPo\r\n    this.tpl = new TplEng(template, \"{{\", \"}}\"); //new Template(template,subPos);\r\n    if (watch) hitchWath(watch, evManger);\r\n    // error everyday\r\n    //\r\n    this.$localPo = []\r\n    this.assemble = function(data, _id) {\r\n        evManger.block(\"_rerender_\")\r\n        if (data != undefined) {\r\n            Object.assign(deepClone(data), this.data)\r\n        } else {\r\n            data = deepClone(this.data)\r\n        }\r\n        evManger.unblock(\"_rerender_\")\r\n        let res = this.tpl.joint(data, _id)\r\n        if (subPos != undefined) {\r\n            return replaceSubNode(res, subPos, this.data, this.$localPo)\r\n        } else {\r\n            return res\r\n        }\r\n    };\r\n\r\n    this.bind = patchs => {\r\n        // if (subPos) {\r\n        //     for (let subi in subPos) {\r\n        //         subPos[subi].bind()\r\n        //     }\r\n        // }\r\n        if (patchs.length == 0) return\r\n        let bindArr = [],\r\n            onArr = [];\r\n        let splitEv = ele => {\r\n            if (ele.nodeType == 3) return\r\n            if (ele.children.length != 0) {\r\n                for (let _chi in ele.children) {\r\n                    if (_chi == \"length\") break\r\n                    let _ch = ele.children[_chi]\r\n                    splitEv(_ch)\r\n                }\r\n            }\r\n            let attrs = ele.attributes\r\n            if (attrs.length == 0) return\r\n            let isOn = node => {\r\n                return /on:/g.test(node.nodeName)\r\n            }\r\n            let isBind = node => {\r\n                return /bind:/g.test(node.nodeName)\r\n            }\r\n            for (let attri in attrs) {\r\n                let attr = attrs[attri]\r\n                if (isOn(attr)) {\r\n                    onArr.push({\r\n                        ele: ele,\r\n                        eventName: attr.nodeName.split(\":\")[1],\r\n                        codeStr: attr.nodeValue\r\n                    })\r\n                }\r\n                if (isBind(attr)) {\r\n                    bindArr.push({\r\n                        ele: ele,\r\n                        eventName: attr.nodeName.split(\":\")[1],\r\n                        codeStr: attr.nodeValue\r\n                    })\r\n                }\r\n            }\r\n        }\r\n        for (let _patchi in patchs) {\r\n            let _patch = patchs[_patchi]\r\n            if (_patch.option == \"add\" || _patch.option == \"attributesChange\") {\r\n                splitEv(_patch.ele)\r\n            }\r\n        }\r\n        if (onArr.length != 0)\r\n            hitchOnEv(evManger, onArr, this.data, this.$localPo)\r\n        if (bindArr.length != 0)\r\n            hitchBindEv(evManger, bindArr, this.data, this.$localPo);\r\n    };\r\n}\r\n\r\nlet generateSubPo = function(poList, evManger) {\r\n    let res = {}\r\n    for (let poName in poList) {\r\n        let sub = poList[poName],\r\n            tplText\r\n        if (sub.tpl[0] == \"#\") {\r\n            tplText = document.querySelector(sub.tpl).innerHTML;\r\n        } else {\r\n            tplText = sub.tpl\r\n        }\r\n        res[poName] = new Po(tplText, deepClone(sub.data), {}, evManger)\r\n    }\r\n    return res\r\n}\r\n\r\nmodule.exports = {\r\n    Po,\r\n    generateSubPo\r\n};\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9Qby5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb3JlL1BvLmpzPzIyNDQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qge1xyXG4gICAgZGVlcENsb25lLFxyXG4gICAgZXh0ZW5kLFxyXG4gICAgR2V0QXR0ckVsZW1lbnQsXHJcbiAgICBwcm94eUFyclxyXG59ID0gcmVxdWlyZShcIi4uL3V0aWwvdXRpbFwiKTtcclxuY29uc3QgVHBsRW5nID0gcmVxdWlyZShcIi4vdGVtcGxhdGVcIik7XHJcbmNvbnN0IEpzdm0gPSByZXF1aXJlKFwiLi4vdXRpbC9Kc1ZtXCIpO1xyXG5cclxuLy8gY29uc3QgZGVidWdPYmogPSByZXF1aXJlKFwiLi4vdXRpbC9kZWJ1Z1wiKVxyXG5cclxubGV0IHJlcGxhY2VTdWJOb2RlID0gKGh0bWwsIHN1YlBvcywgc3VwcGVyLCBsb2NhbFBvKSA9PiB7XHJcbiAgICBsZXQgcmVzbG92ZURhdGEgPSBhdHRycyA9PiB7XHJcbiAgICAgICAgbGV0IHJlcyA9IHt9XHJcbiAgICAgICAgaWYgKGF0dHJzID09IHVuZGVmaW5lZCB8fCBhdHRycy5sZW5ndGggPT0gMCkgcmV0dXJuIHJlc1xyXG4gICAgICAgIGxldCBhcnIgPSBhdHRycy5zcGxpdChcIiBcIilcclxuICAgICAgICBsZXQgcmUgPSBuZXcgUmVnRXhwKGAoLis/KT0oW1wiJ10pKC4rPylcXFxcMmApXHJcbiAgICAgICAgZm9yIChsZXQgYXR0ciBvZiBhcnIpIHtcclxuICAgICAgICAgICAgaWYgKGF0dHIudHJpbSgpID09IFwiXCIpIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGxldCByZWckYXJyID0gcmUuZXhlYyhhdHRyKVxyXG4gICAgICAgICAgICByZXNbcmVnJGFyclsxXV0gPSByZWckYXJyWzNdXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXNcclxuICAgIH1cclxuICAgIGxldCByZXNsb3ZlID0gaHRtbFxyXG4gICAgbGV0IGxvY2FsQ3VyID0gMFxyXG4gICAgZm9yIChsZXQgc3ViTmFtZSBpbiBzdWJQb3MpIHtcclxuICAgICAgICBsZXQgc3ViID0gc3ViUG9zW3N1Yk5hbWVdXHJcbiAgICAgICAgbGV0IHJlID0gbmV3IFJlZ0V4cChcIjwoXCIgKyBzdWJOYW1lICsgXCIpKCggW148PiBdKikqKT4oW148Pl0qKTxcXC9cIiArIHN1Yk5hbWUgKyBcIj5cIiwgXCJnaVwiKVxyXG4gICAgICAgIGxldCBzdWJBcnIgPSBodG1sLm1hdGNoKHJlKVxyXG4gICAgICAgIGlmICghc3ViQXJyKSBjb250aW51ZVxyXG4gICAgICAgIGZvciAobGV0IF9zaSBpbiBzdWJBcnIpIHtcclxuICAgICAgICAgICAgbGV0IF9zID0gc3ViQXJyW19zaV1cclxuICAgICAgICAgICAgcmUgPSBuZXcgUmVnRXhwKFwiPChcIiArIHN1Yk5hbWUgKyBcIikoKCBbXjw+IF0qKSopPihbXjw+XSopPFxcL1wiICsgc3ViTmFtZSArIFwiPlwiLCBcImdpXCIpXHJcbiAgICAgICAgICAgIGxldCByZWckYXJyID0gcmUuZXhlYyhfcylcclxuICAgICAgICAgICAgbGV0IHRlbXBEYXRhID0gcmVzbG92ZURhdGEocmVnJGFyclsyXSlcclxuICAgICAgICAgICAgdGVtcERhdGEuX2NvbnRlbnQgPSByZWckYXJyWzRdXHJcbiAgICAgICAgICAgIGlmIChsb2NhbFBvW2xvY2FsQ3VyXSA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsUG8ucHVzaChzdWIuQ2xvbmUodGVtcERhdGEpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCB0ZW1wID0gbG9jYWxQb1tsb2NhbEN1cl0uYXNzZW1ibGUoc3VwcGVyLCBsb2NhbEN1cilcclxuICAgICAgICAgICAgcmVzbG92ZSA9IHJlc2xvdmUucmVwbGFjZShfcywgdGVtcClcclxuICAgICAgICAgICAgbG9jYWxDdXIgKz0gMVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXNsb3ZlXHJcbn1cclxuXHJcbmxldCBfaW5pdF9EYXRlVmFsdWVQcm9wZXJ0eSA9IChkYXRhLCBfZXYpID0+IHtcclxuICAgIGxldCBzb3VyY2UgPSBkZWVwQ2xvbmUoZGF0YSlcclxuICAgIGZvciAobGV0IHZhcmlhYmxlIGluIGRhdGEpIHtcclxuICAgICAgICBsZXQgc2V0VmFsID0gZGF0YVt2YXJpYWJsZV07XHJcbiAgICAgICAgbGV0IG9wdGlvbiA9IHt9XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzZXRWYWwpID09IFwiW29iamVjdCBBcnJheV1cIikge1xyXG4gICAgICAgICAgICAvLyAjMTAxIGxlbmd0aCBwcm9ibGVtXHJcbiAgICAgICAgICAgIHNldFZhbCA9IHByb3h5QXJyKHNldFZhbCwgbmV3VmFsID0+IHtcclxuICAgICAgICAgICAgICAgIF9ldi5lbWl0KFwiU0VUX1wiICsgdmFyaWFibGUsIG5ld1ZhbCk7XHJcbiAgICAgICAgICAgICAgICBfZXYuZW1pdChcIl9yZXJlbmRlcl9cIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlW3ZhcmlhYmxlXS5sZW5ndGggPT0gbmV3VmFsLmxlbmd0aCkgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICBzb3VyY2VbdmFyaWFibGVdID0gbmV3VmFsO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHNldFZhbCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIGlmICgvX2V2LmVtaXQvZy50ZXN0KHNldFZhbC50b1N0cmluZygpKSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIGRhdGFbdmFyaWFibGVdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgX3Jlc1RlbXAgPSBzZXRWYWwuYXBwbHkoZGF0YSwgYXJndW1lbnRzKVxyXG4gICAgICAgICAgICAgICAgX2V2LmVtaXQoXCJfcmVyZW5kZXJfXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZXNUZW1wXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIC8vIG9wdGlvbi5nZXQgPSAoKT0+e1xyXG4gICAgICAgICAgICAvLyAgICAgcmV0dXJuIHNldFZhbChkYXRhKVxyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgb3B0aW9uLmdldCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2VbdmFyaWFibGVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9wdGlvbi5zZXQgPSBuZXdWYWwgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc291cmNlW3ZhcmlhYmxlXSA9PSBuZXdWYWwpIHJldHVyblxyXG4gICAgICAgICAgICBzb3VyY2VbdmFyaWFibGVdID0gbmV3VmFsO1xyXG4gICAgICAgICAgICBfZXYuZW1pdChcIlNFVF9cIiArIHZhcmlhYmxlLCBuZXdWYWwpO1xyXG4gICAgICAgICAgICBfZXYuZW1pdChcIl9yZXJlbmRlcl9cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhLCB2YXJpYWJsZSwgb3B0aW9uKVxyXG4gICAgICAgIGRhdGFbdmFyaWFibGVdID0gc2V0VmFsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn1cclxuXHJcbmxldCBoaXRjaE9uRXYgPSAoX2V2TWFuZ2VyLCBfb24sIGRhdGEsIGxvY2FsQXJyKSA9PiB7XHJcbiAgICBmb3IgKHZhciBldmVudF8gaW4gX29uKSB7XHJcbiAgICAgICAgaWYgKF9vbi5oYXNPd25Qcm9wZXJ0eShldmVudF8pKSB7XHJcbiAgICAgICAgICAgIGxldCB0aGlzT3B0aW9uID0gX29uW2V2ZW50X10sXHJcbiAgICAgICAgICAgICAgICBldk5hbWUgPSB0aGlzT3B0aW9uLmV2ZW50TmFtZSxcclxuICAgICAgICAgICAgICAgIGNvU3RyID0gdGhpc09wdGlvbi5jb2RlU3RyLFxyXG4gICAgICAgICAgICAgICAgdGhhdF9kYXRhID0gZGF0YSxcclxuICAgICAgICAgICAgICAgIGVsZSA9IHRoaXNPcHRpb24uZWxlLFxyXG4gICAgICAgICAgICAgICAgd2l0aERhdGEgPSB7fTtcclxuICAgICAgICAgICAgaWYgKGVsZS5hdHRyaWJ1dGVzW1wiUG9pSWRcIl0gIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgX2luZGV4ID0gZWxlLmF0dHJpYnV0ZXNbXCJQb2lJZFwiXS5ub2RlVmFsdWVcclxuICAgICAgICAgICAgICAgIHdpdGhEYXRhID0gbG9jYWxBcnJbX2luZGV4XS5kYXRhXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX2V2TWFuZ2VyLm9uKGV2TmFtZSwgZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IGVsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhb2JqID0gT2JqZWN0LmFzc2lnbih0aGF0X2RhdGEsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZTogZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZjogZS50YXJnZXRcclxuICAgICAgICAgICAgICAgICAgICB9LCB3aXRoRGF0YSlcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1aXJlKFwiLi4vdXRpbC9Kc1ZtLmpzXCIpLm1pY1ZtKGNvU3RyLCB0aGF0X2RhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIEpzdm0uc2FmZShjb1N0ciwgdGhhdF9kYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBvbl9ldiBlbmRcclxufVxyXG5sZXQgaGl0Y2hCaW5kRXYgPSAoX2V2TWFuZ2VyLCBfYmluZCwgZGF0YSwgbG9jYWxBcnIpID0+IHtcclxuICAgIGZvciAodmFyIF9ldiBpbiBfYmluZCkge1xyXG4gICAgICAgIGlmIChfYmluZC5oYXNPd25Qcm9wZXJ0eShfZXYpKSB7XHJcbiAgICAgICAgICAgIGxldCB0aGlzT3B0aW9uID0gX2JpbmRbX2V2XSxcclxuICAgICAgICAgICAgICAgIGV2TmFtZSA9IHRoaXNPcHRpb24uZXZlbnROYW1lLFxyXG4gICAgICAgICAgICAgICAgY29TdHIgPSB0aGlzT3B0aW9uLmNvZGVTdHIsXHJcbiAgICAgICAgICAgICAgICB0aGF0X2RhdGEgPSBkYXRhLFxyXG4gICAgICAgICAgICAgICAgZWxlID0gdGhpc09wdGlvbi5lbGUsXHJcbiAgICAgICAgICAgICAgICB3aXRoRGF0YSA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoZWxlLmF0dHJpYnV0ZXNbXCJQb2lJZFwiXSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBfaW5kZXggPSBlbGUuYXR0cmlidXRlc1tcIlBvaUlkXCJdLm5vZGVWYWx1ZVxyXG4gICAgICAgICAgICAgICAgd2l0aERhdGEgPSBsb2NhbEFycltfaW5kZXhdLmRhdGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXZOYW1lID09IFwiY2xhc3NcIilcclxuICAgICAgICAgICAgICAgIGV2TmFtZSA9IFwiY2xhc3NOYW1lXCJcclxuICAgICAgICAgICAgZWxlW2V2TmFtZV0gPSBKc3ZtLnNhZmUoXCJyZXR1cm4oXCIgKyBjb1N0ciArIFwiKVwiLCBPYmplY3QuYXNzaWduKGRlZXBDbG9uZSh3aXRoRGF0YSksIHRoYXRfZGF0YSkpO1xyXG4gICAgICAgICAgICAvLyBpbml0IHZhbHVlXHJcbiAgICAgICAgICAgIF9ldk1hbmdlci5vbihcIl9yZXJlbmRlcl9cIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZSAmJiBlbGUucGFyZW50Tm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVxdWlyZShcIi4uL3V0aWwvSnNWbS5qc1wiKS5taWNWbShjb1N0ciwgdGhhdF9kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBlbGVbZXZOYW1lXSA9IEpzdm0uc2FmZShcInJldHVybihcIiArIGNvU3RyICsgXCIpXCIsIE9iamVjdC5hc3NpZ24oZGVlcENsb25lKHdpdGhEYXRhKSwgdGhhdF9kYXRhKSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5sZXQgaGl0Y2hXYXRoID0gKHdhdGNoLCBfZXYpID0+IHtcclxuICAgIGZvciAobGV0IHZhcmlhYmxlIGluIHdhdGNoKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3YXRjaFt2YXJpYWJsZV0gPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICBfZXYub24oXCJTRVRfXCIgKyB2YXJpYWJsZSwgKG5ld1ZhbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgd2F0Y2hbdmFyaWFibGVdKG5ld1ZhbCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5sZXQgUG8gPSBmdW5jdGlvbih0ZW1wbGF0ZSwgZGF0YSwgd2F0Y2gsIGV2TWFuZ2VyLCBzdWJQb3MsIG1peHdpdGgpIHtcclxuICAgIGlmIChtaXh3aXRoKSB7XHJcbiAgICAgICAgZXh0ZW5kKGRhdGEsIGRlZXBDbG9uZShtaXh3aXRoLiRwdXJlRGF0YSkpO1xyXG4gICAgfVxyXG4gICAgdGhpcy4kcHVyZURhdGEgPSBkZWVwQ2xvbmUoZGF0YSlcclxuICAgIC8vIHRwbFxyXG4gICAgdGhpcy5DbG9uZSA9IF9kYXRhID0+IHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAkcHVyZURhdGE6IE9iamVjdC5hc3NpZ24oZGVlcENsb25lKF9kYXRhKSwgdGhpcy4kcHVyZURhdGEpLFxyXG4gICAgICAgICAgICB0cGw6IHRoaXMudHBsLFxyXG4gICAgICAgICAgICBkYXRhOiBfaW5pdF9EYXRlVmFsdWVQcm9wZXJ0eShkZWVwQ2xvbmUoT2JqZWN0LmFzc2lnbihkZWVwQ2xvbmUoX2RhdGEpLCBkZWVwQ2xvbmUodGhpcy4kcHVyZURhdGEpKSksIGV2TWFuZ2VyKSxcclxuICAgICAgICAgICAgYXNzZW1ibGU6IGZ1bmN0aW9uKGRhdGEsIF9pZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHBsLmpvaW50KE9iamVjdC5hc3NpZ24odGhpcy5kYXRhLCBkYXRhKSwgX2lkKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZGF0YVxyXG4gICAgLy8gbGV0IGRiZyA9IG5ldyBkZWJ1Z09iaihcIl9pbml0X0RhdGVWYWx1ZVByb3BlcnR5XCIpXHJcbiAgICB0aGlzLmRhdGEgPSBfaW5pdF9EYXRlVmFsdWVQcm9wZXJ0eShkYXRhLCBldk1hbmdlcilcclxuICAgIC8vIGRiZy5sb2coKVxyXG4gICAgLy9cclxuICAgIC8vIHN1YlBvXHJcbiAgICB0aGlzLnRwbCA9IG5ldyBUcGxFbmcodGVtcGxhdGUsIFwie3tcIiwgXCJ9fVwiKTsgLy9uZXcgVGVtcGxhdGUodGVtcGxhdGUsc3ViUG9zKTtcclxuICAgIGlmICh3YXRjaCkgaGl0Y2hXYXRoKHdhdGNoLCBldk1hbmdlcik7XHJcbiAgICAvLyBlcnJvciBldmVyeWRheVxyXG4gICAgLy9cclxuICAgIHRoaXMuJGxvY2FsUG8gPSBbXVxyXG4gICAgdGhpcy5hc3NlbWJsZSA9IGZ1bmN0aW9uKGRhdGEsIF9pZCkge1xyXG4gICAgICAgIGV2TWFuZ2VyLmJsb2NrKFwiX3JlcmVuZGVyX1wiKVxyXG4gICAgICAgIGlmIChkYXRhICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGRlZXBDbG9uZShkYXRhKSwgdGhpcy5kYXRhKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSBkZWVwQ2xvbmUodGhpcy5kYXRhKVxyXG4gICAgICAgIH1cclxuICAgICAgICBldk1hbmdlci51bmJsb2NrKFwiX3JlcmVuZGVyX1wiKVxyXG4gICAgICAgIGxldCByZXMgPSB0aGlzLnRwbC5qb2ludChkYXRhLCBfaWQpXHJcbiAgICAgICAgaWYgKHN1YlBvcyAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VTdWJOb2RlKHJlcywgc3ViUG9zLCB0aGlzLmRhdGEsIHRoaXMuJGxvY2FsUG8pXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5iaW5kID0gcGF0Y2hzID0+IHtcclxuICAgICAgICAvLyBpZiAoc3ViUG9zKSB7XHJcbiAgICAgICAgLy8gICAgIGZvciAobGV0IHN1YmkgaW4gc3ViUG9zKSB7XHJcbiAgICAgICAgLy8gICAgICAgICBzdWJQb3Nbc3ViaV0uYmluZCgpXHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgaWYgKHBhdGNocy5sZW5ndGggPT0gMCkgcmV0dXJuXHJcbiAgICAgICAgbGV0IGJpbmRBcnIgPSBbXSxcclxuICAgICAgICAgICAgb25BcnIgPSBbXTtcclxuICAgICAgICBsZXQgc3BsaXRFdiA9IGVsZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlbGUubm9kZVR5cGUgPT0gMykgcmV0dXJuXHJcbiAgICAgICAgICAgIGlmIChlbGUuY2hpbGRyZW4ubGVuZ3RoICE9IDApIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IF9jaGkgaW4gZWxlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jaGkgPT0gXCJsZW5ndGhcIikgYnJlYWtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgX2NoID0gZWxlLmNoaWxkcmVuW19jaGldXHJcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRFdihfY2gpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGF0dHJzID0gZWxlLmF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgaWYgKGF0dHJzLmxlbmd0aCA9PSAwKSByZXR1cm5cclxuICAgICAgICAgICAgbGV0IGlzT24gPSBub2RlID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAvb246L2cudGVzdChub2RlLm5vZGVOYW1lKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBpc0JpbmQgPSBub2RlID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAvYmluZDovZy50ZXN0KG5vZGUubm9kZU5hbWUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgYXR0cmkgaW4gYXR0cnMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBhdHRyID0gYXR0cnNbYXR0cmldXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPbihhdHRyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uQXJyLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGU6IGVsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lOiBhdHRyLm5vZGVOYW1lLnNwbGl0KFwiOlwiKVsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZVN0cjogYXR0ci5ub2RlVmFsdWVcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzQmluZChhdHRyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJpbmRBcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZTogZWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudE5hbWU6IGF0dHIubm9kZU5hbWUuc3BsaXQoXCI6XCIpWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlU3RyOiBhdHRyLm5vZGVWYWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgX3BhdGNoaSBpbiBwYXRjaHMpIHtcclxuICAgICAgICAgICAgbGV0IF9wYXRjaCA9IHBhdGNoc1tfcGF0Y2hpXVxyXG4gICAgICAgICAgICBpZiAoX3BhdGNoLm9wdGlvbiA9PSBcImFkZFwiIHx8IF9wYXRjaC5vcHRpb24gPT0gXCJhdHRyaWJ1dGVzQ2hhbmdlXCIpIHtcclxuICAgICAgICAgICAgICAgIHNwbGl0RXYoX3BhdGNoLmVsZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob25BcnIubGVuZ3RoICE9IDApXHJcbiAgICAgICAgICAgIGhpdGNoT25Fdihldk1hbmdlciwgb25BcnIsIHRoaXMuZGF0YSwgdGhpcy4kbG9jYWxQbylcclxuICAgICAgICBpZiAoYmluZEFyci5sZW5ndGggIT0gMClcclxuICAgICAgICAgICAgaGl0Y2hCaW5kRXYoZXZNYW5nZXIsIGJpbmRBcnIsIHRoaXMuZGF0YSwgdGhpcy4kbG9jYWxQbyk7XHJcbiAgICB9O1xyXG59XHJcblxyXG5sZXQgZ2VuZXJhdGVTdWJQbyA9IGZ1bmN0aW9uKHBvTGlzdCwgZXZNYW5nZXIpIHtcclxuICAgIGxldCByZXMgPSB7fVxyXG4gICAgZm9yIChsZXQgcG9OYW1lIGluIHBvTGlzdCkge1xyXG4gICAgICAgIGxldCBzdWIgPSBwb0xpc3RbcG9OYW1lXSxcclxuICAgICAgICAgICAgdHBsVGV4dFxyXG4gICAgICAgIGlmIChzdWIudHBsWzBdID09IFwiI1wiKSB7XHJcbiAgICAgICAgICAgIHRwbFRleHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHN1Yi50cGwpLmlubmVySFRNTDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0cGxUZXh0ID0gc3ViLnRwbFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXNbcG9OYW1lXSA9IG5ldyBQbyh0cGxUZXh0LCBkZWVwQ2xvbmUoc3ViLmRhdGEpLCB7fSwgZXZNYW5nZXIpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgUG8sXHJcbiAgICBnZW5lcmF0ZVN1YlBvXHJcbn07XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/Po.js\n");

/***/ }),

/***/ "./src/core/Poi.js":
/*!*************************!*\
  !*** ./src/core/Poi.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const EventObj = __webpack_require__(/*! ./event */ \"./src/core/event.js\");\r\nconst diff = __webpack_require__(/*! ./diff */ \"./src/core/diff.js\");\r\nconst {\r\n    Po,\r\n    generateSubPo\r\n} = __webpack_require__(/*! ./Po */ \"./src/core/Po.js\");\r\nconst {domApi} = __webpack_require__(/*! ../util/domApi.js */ \"./src/util/domApi.js\");\r\n\r\nfunction async_render(__ctx__) {\r\n    (async () => {\r\n        __ctx__.Event.block(\"_rerender_\")\r\n        // dirty checking maybe\r\n        let patchArr = await diff(__ctx__.el, __ctx__.Po.assemble());\r\n        __ctx__.Po.bind(patchArr)\r\n        __ctx__.Event.unblock(\"_rerender_\")\r\n    })();\r\n}\r\n\r\nlet _Poi = function(finder, template, data, watch, subPos, mixwith, mounts) {\r\n    this.el = domApi.$(finder);\r\n    // on,emit\r\n    this.Event = new EventObj(this.el);\r\n    this.$on = function() {\r\n        this.Event.on.apply(this.Event, arguments)\r\n    };\r\n    this.$emit = function() {\r\n        this.Event.emit.apply(this.Event, arguments)\r\n    };\r\n    // #401 babel es5 leads to mistakes\r\n    let that = this;\r\n    this.render = () => {\r\n        (async ()=>{\r\n            this.$on(\"_rerender_\", () => {\r\n                that.rerender();\r\n            })\r\n            this.Event.block(\"_rerender_\")\r\n            this.el.html(\"\")\r\n            let patchArr = await diff(this.el, this.Po.assemble());\r\n            if (patchArr.length != 0) {\r\n                this.Po.bind(patchArr)\r\n            }\r\n            this.Event.unblock(\"_rerender_\")\r\n        })()\r\n    }\r\n    this.rerender = () => {\r\n        // this.Event.block(\"_rerender_\")\r\n        // // dirty checking maybe\r\n        // let patchArr = diff(this.el, this.Po.assemble());\r\n        // this.Po.bind(patchArr)\r\n        // // this.Po.bind();\r\n        // this.Event.unblock(\"_rerender_\")\r\n        async_render(this)\r\n    }\r\n    let subPoi = subPos ? generateSubPo(subPos, this.Event) : undefined\r\n    this.Po = new Po(template, data, watch, this.Event, subPoi, mixwith);\r\n    this.$data = this.Po.data;\r\n    // #402 mounted init function\r\n    if (mixwith && mixwith.mounts) {\r\n        for (let key in mixwith.mounts) {\r\n            if (key in mounts) {\r\n                mounts[key] = () => {\r\n                    mixwith.mounts[key].apply(this)\r\n                    mounts[key].apply(this)\r\n                }\r\n            } else {\r\n                mounts[key] = mixwith.mounts[key]\r\n            }\r\n        }\r\n    }\r\n    if (mounts) {\r\n        if (mounts.init) mounts.init.apply(this.Po.data);\r\n    }\r\n    return this;\r\n}\r\n\r\nlet Poi = function(config) {\r\n    let tpl_content\r\n    if (config.tpl) {\r\n        if (config.tpl[0] == \"#\") {\r\n            tpl_content = document.querySelector(config.tpl).innerHTML;\r\n            if (tpl_content == undefined) return new Error(\"not found template element \" + config.tpl)\r\n        } else {\r\n            tpl_content = config.tpl\r\n        }\r\n    } else {\r\n        if (config.el[0] == \"#\") {\r\n            tpl_content = document.querySelector(config.el).innerHTML;\r\n            if (tpl_content == undefined) return new Error(\"not found element \" + config.el)\r\n        } else {\r\n            tpl_content = tpl_content.replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\")\r\n        }\r\n    }\r\n    let that = _Poi.apply({}, [config.el, tpl_content, config.data, config.watch, config.components, config.mixwith, config.mounted]);\r\n    that.render();\r\n    return that;\r\n}\r\n\r\nmodule.exports = Poi;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9Qb2kuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9Qb2kuanM/OGI3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFdmVudE9iaiA9IHJlcXVpcmUoXCIuL2V2ZW50XCIpO1xyXG5jb25zdCBkaWZmID0gcmVxdWlyZShcIi4vZGlmZlwiKTtcclxuY29uc3Qge1xyXG4gICAgUG8sXHJcbiAgICBnZW5lcmF0ZVN1YlBvXHJcbn0gPSByZXF1aXJlKFwiLi9Qb1wiKTtcclxuY29uc3Qge2RvbUFwaX0gPSByZXF1aXJlKFwiLi4vdXRpbC9kb21BcGkuanNcIik7XHJcblxyXG5mdW5jdGlvbiBhc3luY19yZW5kZXIoX19jdHhfXykge1xyXG4gICAgKGFzeW5jICgpID0+IHtcclxuICAgICAgICBfX2N0eF9fLkV2ZW50LmJsb2NrKFwiX3JlcmVuZGVyX1wiKVxyXG4gICAgICAgIC8vIGRpcnR5IGNoZWNraW5nIG1heWJlXHJcbiAgICAgICAgbGV0IHBhdGNoQXJyID0gYXdhaXQgZGlmZihfX2N0eF9fLmVsLCBfX2N0eF9fLlBvLmFzc2VtYmxlKCkpO1xyXG4gICAgICAgIF9fY3R4X18uUG8uYmluZChwYXRjaEFycilcclxuICAgICAgICBfX2N0eF9fLkV2ZW50LnVuYmxvY2soXCJfcmVyZW5kZXJfXCIpXHJcbiAgICB9KSgpO1xyXG59XHJcblxyXG5sZXQgX1BvaSA9IGZ1bmN0aW9uKGZpbmRlciwgdGVtcGxhdGUsIGRhdGEsIHdhdGNoLCBzdWJQb3MsIG1peHdpdGgsIG1vdW50cykge1xyXG4gICAgdGhpcy5lbCA9IGRvbUFwaS4kKGZpbmRlcik7XHJcbiAgICAvLyBvbixlbWl0XHJcbiAgICB0aGlzLkV2ZW50ID0gbmV3IEV2ZW50T2JqKHRoaXMuZWwpO1xyXG4gICAgdGhpcy4kb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLkV2ZW50Lm9uLmFwcGx5KHRoaXMuRXZlbnQsIGFyZ3VtZW50cylcclxuICAgIH07XHJcbiAgICB0aGlzLiRlbWl0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5FdmVudC5lbWl0LmFwcGx5KHRoaXMuRXZlbnQsIGFyZ3VtZW50cylcclxuICAgIH07XHJcbiAgICAvLyAjNDAxIGJhYmVsIGVzNSBsZWFkcyB0byBtaXN0YWtlc1xyXG4gICAgbGV0IHRoYXQgPSB0aGlzO1xyXG4gICAgdGhpcy5yZW5kZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgKGFzeW5jICgpPT57XHJcbiAgICAgICAgICAgIHRoaXMuJG9uKFwiX3JlcmVuZGVyX1wiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGF0LnJlcmVuZGVyKCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIHRoaXMuRXZlbnQuYmxvY2soXCJfcmVyZW5kZXJfXCIpXHJcbiAgICAgICAgICAgIHRoaXMuZWwuaHRtbChcIlwiKVxyXG4gICAgICAgICAgICBsZXQgcGF0Y2hBcnIgPSBhd2FpdCBkaWZmKHRoaXMuZWwsIHRoaXMuUG8uYXNzZW1ibGUoKSk7XHJcbiAgICAgICAgICAgIGlmIChwYXRjaEFyci5sZW5ndGggIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5Qby5iaW5kKHBhdGNoQXJyKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuRXZlbnQudW5ibG9jayhcIl9yZXJlbmRlcl9cIilcclxuICAgICAgICB9KSgpXHJcbiAgICB9XHJcbiAgICB0aGlzLnJlcmVuZGVyID0gKCkgPT4ge1xyXG4gICAgICAgIC8vIHRoaXMuRXZlbnQuYmxvY2soXCJfcmVyZW5kZXJfXCIpXHJcbiAgICAgICAgLy8gLy8gZGlydHkgY2hlY2tpbmcgbWF5YmVcclxuICAgICAgICAvLyBsZXQgcGF0Y2hBcnIgPSBkaWZmKHRoaXMuZWwsIHRoaXMuUG8uYXNzZW1ibGUoKSk7XHJcbiAgICAgICAgLy8gdGhpcy5Qby5iaW5kKHBhdGNoQXJyKVxyXG4gICAgICAgIC8vIC8vIHRoaXMuUG8uYmluZCgpO1xyXG4gICAgICAgIC8vIHRoaXMuRXZlbnQudW5ibG9jayhcIl9yZXJlbmRlcl9cIilcclxuICAgICAgICBhc3luY19yZW5kZXIodGhpcylcclxuICAgIH1cclxuICAgIGxldCBzdWJQb2kgPSBzdWJQb3MgPyBnZW5lcmF0ZVN1YlBvKHN1YlBvcywgdGhpcy5FdmVudCkgOiB1bmRlZmluZWRcclxuICAgIHRoaXMuUG8gPSBuZXcgUG8odGVtcGxhdGUsIGRhdGEsIHdhdGNoLCB0aGlzLkV2ZW50LCBzdWJQb2ksIG1peHdpdGgpO1xyXG4gICAgdGhpcy4kZGF0YSA9IHRoaXMuUG8uZGF0YTtcclxuICAgIC8vICM0MDIgbW91bnRlZCBpbml0IGZ1bmN0aW9uXHJcbiAgICBpZiAobWl4d2l0aCAmJiBtaXh3aXRoLm1vdW50cykge1xyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBtaXh3aXRoLm1vdW50cykge1xyXG4gICAgICAgICAgICBpZiAoa2V5IGluIG1vdW50cykge1xyXG4gICAgICAgICAgICAgICAgbW91bnRzW2tleV0gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWl4d2l0aC5tb3VudHNba2V5XS5hcHBseSh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgIG1vdW50c1trZXldLmFwcGx5KHRoaXMpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudHNba2V5XSA9IG1peHdpdGgubW91bnRzW2tleV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChtb3VudHMpIHtcclxuICAgICAgICBpZiAobW91bnRzLmluaXQpIG1vdW50cy5pbml0LmFwcGx5KHRoaXMuUG8uZGF0YSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxubGV0IFBvaSA9IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgbGV0IHRwbF9jb250ZW50XHJcbiAgICBpZiAoY29uZmlnLnRwbCkge1xyXG4gICAgICAgIGlmIChjb25maWcudHBsWzBdID09IFwiI1wiKSB7XHJcbiAgICAgICAgICAgIHRwbF9jb250ZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb25maWcudHBsKS5pbm5lckhUTUw7XHJcbiAgICAgICAgICAgIGlmICh0cGxfY29udGVudCA9PSB1bmRlZmluZWQpIHJldHVybiBuZXcgRXJyb3IoXCJub3QgZm91bmQgdGVtcGxhdGUgZWxlbWVudCBcIiArIGNvbmZpZy50cGwpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdHBsX2NvbnRlbnQgPSBjb25maWcudHBsXHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoY29uZmlnLmVsWzBdID09IFwiI1wiKSB7XHJcbiAgICAgICAgICAgIHRwbF9jb250ZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb25maWcuZWwpLmlubmVySFRNTDtcclxuICAgICAgICAgICAgaWYgKHRwbF9jb250ZW50ID09IHVuZGVmaW5lZCkgcmV0dXJuIG5ldyBFcnJvcihcIm5vdCBmb3VuZCBlbGVtZW50IFwiICsgY29uZmlnLmVsKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRwbF9jb250ZW50ID0gdHBsX2NvbnRlbnQucmVwbGFjZSgvJmx0Oy9nLCBcIjxcIikucmVwbGFjZSgvJmd0Oy9nLCBcIj5cIilcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgdGhhdCA9IF9Qb2kuYXBwbHkoe30sIFtjb25maWcuZWwsIHRwbF9jb250ZW50LCBjb25maWcuZGF0YSwgY29uZmlnLndhdGNoLCBjb25maWcuY29tcG9uZW50cywgY29uZmlnLm1peHdpdGgsIGNvbmZpZy5tb3VudGVkXSk7XHJcbiAgICB0aGF0LnJlbmRlcigpO1xyXG4gICAgcmV0dXJuIHRoYXQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9pO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/Poi.js\n");

/***/ }),

/***/ "./src/core/diff.js":
/*!**************************!*\
  !*** ./src/core/diff.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\r\nconst {domApi} = __webpack_require__(/*! ../util/domApi.js */ \"./src/util/domApi.js\");\r\n\r\nconst {\r\n    frameify\r\n} = __webpack_require__(/*! ../util/frameify.js */ \"./src/util/frameify.js\");\r\n\r\n// const debugObj = require(\"../util/debug\")\r\nlet _lcsDomArr = async (newDomEle, oldDomEle, targetDom) => {\r\n    let planArr = [];\r\n    if (oldDomEle.length == 0) {\r\n        for (let nEli in newDomEle) {\r\n            planArr.push({\r\n                option: \"add\",\r\n                ele: newDomEle[nEli],\r\n                upper: targetDom\r\n            })\r\n        }\r\n        return planArr\r\n    }\r\n    if (newDomEle.length == 0) {\r\n        for (let oEli in oldDomEle) {\r\n            planArr.push({\r\n                option: \"delete\",\r\n                ele: oldDomEle[oEli]\r\n            })\r\n        }\r\n        return planArr\r\n    }\r\n    let lcs_arr = await frameify(lcsOnArr(newDomEle, oldDomEle, domApi.isSame)),\r\n        curA = 0,\r\n        curB = 0;\r\n\r\n    while (true) {\r\n        if (curA >= lcs_arr.length && curB >= lcs_arr[0].length) {\r\n            break;\r\n        }\r\n        let nr = lcs_arr[curA + 1] ? lcs_arr[curA + 1] : [],\r\n            cr = lcs_arr[curA] ? lcs_arr[curA] : [];\r\n        let rv = cr[curB + 1] ? cr[curB + 1] : 0,\r\n            bv = nr[curB] ? nr[curB] : 0,\r\n            rbv = nr[curB + 1] ? nr[curB + 1] : 0,\r\n            val = cr[curB];\r\n        if (domApi.isSame(newDomEle[curA], oldDomEle[curB])) {\r\n            // same char\r\n            // console.log(curA,curB,ltv,nv,ltv+1==nv)\r\n            if (newDomEle[curA].classList != undefined) {\r\n                if (!domApi.classListDiff(newDomEle[curA], oldDomEle[curB]))\r\n                    planArr.push({\r\n                        option: \"classChange\",\r\n                        ele: oldDomEle[curB],\r\n                        list: newDomEle[curA].classList\r\n                    })\r\n            }\r\n            // attributesDiff\r\n            if (newDomEle[curA].attributes != undefined) {\r\n                if (!domApi.attributesDiff(newDomEle[curA], oldDomEle[curB]))\r\n                    planArr.push({\r\n                        option: \"attributesChange\",\r\n                        ele: oldDomEle[curB],\r\n                        to: newDomEle[curA]\r\n                    })\r\n            }\r\n            curA += 1;\r\n            curB += 1;\r\n            continue;\r\n        } else if (val == 0 && rbv != 1) {\r\n            planArr.push({\r\n                option: \"add\",\r\n                before: oldDomEle[curB],\r\n                after: oldDomEle[curB + 1],\r\n                ele: newDomEle[curA],\r\n                upper: targetDom\r\n            })\r\n            curA += 1;\r\n            continue;\r\n        } else if (rv == bv) {\r\n            // ta+1\"_\" tb+1cahr\r\n            planArr.push({\r\n                option: \"delete\",\r\n                ele: oldDomEle[curB]\r\n            })\r\n            // #201 Matrix boundary\r\n            if(newDomEle[curA] != undefined)\r\n                planArr.push({\r\n                    option: \"add\",\r\n                    before: oldDomEle[curB],\r\n                    after: oldDomEle[curB + 1],\r\n                    ele: newDomEle[curA],\r\n                    upper: targetDom\r\n                })\r\n            curA += 1;\r\n            curB += 1;\r\n            continue;\r\n        } else if (rv > bv) {\r\n            planArr.push({\r\n                option: \"delete\",\r\n                ele: oldDomEle[curB]\r\n            })\r\n            curB += 1;\r\n            continue;\r\n        } else {\r\n            // tb+1\"_\" ta+1char\r\n            planArr.push({\r\n                option: \"add\",\r\n                before: oldDomEle[curB],\r\n                after: oldDomEle[curB + 1],\r\n                ele: newDomEle[curA],\r\n                upper: targetDom\r\n            })\r\n            curA += 1;\r\n        }\r\n    }\r\n    return planArr\r\n}\r\n// #101 Time complexity: O(arr1.length * arr2.length)\r\nlet lcsOnArr = function*(arr1, arr2, compareFn) {\r\n    // let dbg = new debugObj(\"lcsOnArr\");\r\n    let lcsArr = [];\r\n    for (let indexA in arr1) {\r\n        let rowArr = [],\r\n            itemA = arr1[indexA];\r\n        for (let indexB in arr2) {\r\n            yield void 0;\r\n            let itemB = arr2[indexB],\r\n                lv = indexB == 0 ? 0 : rowArr[indexB - 1],\r\n                tv = indexA == 0 ? 0 : lcsArr[indexA - 1][indexB],\r\n                ltv = indexB != 0 && indexA != 0 ? lcsArr[indexA - 1][indexB - 1] : 0;\r\n            if (compareFn(itemA, itemB)) {\r\n                rowArr.push(ltv + 1);\r\n            } else {\r\n                rowArr.push(lv > tv ? lv : tv);\r\n            }\r\n        }\r\n        lcsArr.push(rowArr);\r\n    }\r\n    // dbg.log()\r\n    return lcsArr;\r\n}\r\nlet lcsDomtree = async (newChildren, oldTree) => {\r\n    let isSameTree = (ele1, ele2) => {\r\n        return (\r\n            ele1.nodeName == ele2.nodeName &&\r\n            ele1.id == ele2.id &&\r\n            ele1.className == ele2.className\r\n        )\r\n    }\r\n    let Nchi = [],\r\n        Ochi = [],\r\n        planArr = [],\r\n        NsubTree = [],\r\n        OsubTree = []\r\n    for (let index in newChildren) {\r\n        if (index == \"length\") break;\r\n        let child = newChildren[index]\r\n        if (child.nodeType == 3 && child.textContent.trim().replace(/\\n/g, \"\") == \"\") continue;\r\n        // if (child.childNodes.length == 0) {\r\n        if (child.nodeType == 3 || child.children.length == 0) {\r\n            Nchi.push(child)\r\n        } else {\r\n            NsubTree.push({\r\n                ele: child\r\n            })\r\n        }\r\n    }\r\n    for (let index in oldTree.childNodes) {\r\n        if (index == \"length\") break;\r\n        let child = oldTree.childNodes[index]\r\n        if (child.nodeType == 3 && child.textContent.trim().replace(/\\n/g, \"\") == \"\") continue;\r\n        // if (child.childNodes.length == 0) {\r\n        if (child.nodeType == 3 || child.children.length == 0) {\r\n            let isgoto = false\r\n            if (child.nodeType != 3) {\r\n                for (let _c of NsubTree) {\r\n                    if (domApi.isSame(_c.ele, child)) {\r\n                        OsubTree.push(child)\r\n                        isgoto = true\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (isgoto) continue\r\n            Ochi.push(child)\r\n        } else {\r\n            OsubTree.push(child)\r\n        }\r\n    }\r\n    if (Ochi.length == 0 && OsubTree.length == 0) {\r\n        Nchi = []\r\n        NsubTree = []\r\n        for (let index in newChildren) {\r\n            if (index == \"length\") break;\r\n            let child = newChildren[index]\r\n            if (child.nodeType == 3 && child.textContent.trim().replace(/\\n/g, \"\") == \"\") continue;\r\n            Nchi.push(child)\r\n        }\r\n    }\r\n    // let plan = lcsDomArr(Nchi, Ochi, oldTree)\r\n    let plan = await _lcsDomArr(Nchi, Ochi, oldTree)\r\n\r\n    if (plan.length != 0) {\r\n        planArr.push.apply(planArr, plan)\r\n    }\r\n    for (let ni in NsubTree) {\r\n        let ntree = NsubTree[ni].ele\r\n        for (let oi in OsubTree) {\r\n            let otree = OsubTree[oi]\r\n            if (isSameTree(ntree, otree)) {\r\n                // compare\r\n                if (ntree.classList != undefined) {\r\n                    if (!domApi.classListDiff(ntree, otree))\r\n                        planArr.push({\r\n                            option: \"classChange\",\r\n                            ele: otree,\r\n                            list: ntree.classList\r\n                        })\r\n                }\r\n                // attributesDiff\r\n                if (ntree.attributes != undefined) {\r\n                    if (!domApi.attributesDiff(ntree, otree))\r\n                        planArr.push({\r\n                            option: \"attributesChange\",\r\n                            ele: otree,\r\n                            to: ntree\r\n                        })\r\n                }\r\n                // diff ending\r\n                if (planArr.length != 0) {\r\n                    planArr.push.apply(planArr, lcsDomtree(ntree.childNodes, otree))\r\n                } else {\r\n                    planArr = lcsDomtree(ntree.childNodes, otree)\r\n                }\r\n                // delete NsubTree[ni]\r\n                // delete OsubTree[oi]\r\n                NsubTree.splice(ni,1)\r\n                OsubTree.splice(oi,1)\r\n                break\r\n            }\r\n        }\r\n    }\r\n    for (let ni in NsubTree) {\r\n        if (NsubTree[ni]) {\r\n            if (NsubTree[ni].ele.nodeType == 3 && NsubTree[ni].ele.textContent.trim().replace(/\\n/g, \"\") == \"\") continue;\r\n            planArr.push({\r\n                option: \"add\",\r\n                before: NsubTree[ni].before,\r\n                after: NsubTree[ni].after,\r\n                ele: NsubTree[ni].ele,\r\n                upper: oldTree\r\n            })\r\n        }\r\n    }\r\n    for (let ni in OsubTree) {\r\n        if (OsubTree[ni]) {\r\n            planArr.push({\r\n                option: \"delete\",\r\n                ele: OsubTree[ni]\r\n            })\r\n        }\r\n    }\r\n\r\n    return planArr\r\n}\r\n\r\nlet patch = function*(plan) {\r\n    for (let ch of plan) {\r\n        yield void 0;\r\n        if (ch.option == \"add\") {\r\n            if (ch.after != undefined) {\r\n                domApi.insertBefore(ch.ele, ch.after)\r\n            } else if (ch.before != undefined) {\r\n                domApi.insertAfter(ch.ele, ch.before)\r\n            } else {\r\n                domApi.append(ch.ele, ch.upper)\r\n            }\r\n        }\r\n    }\r\n    for (let ch of plan) {\r\n        yield void 0;\r\n        if (ch.option == \"delete\") {\r\n            domApi.remove(ch.ele)\r\n        }\r\n    }\r\n    for (let ch of plan) {\r\n        yield void 0;\r\n        if (ch.option == \"classChange\") {\r\n            ch.ele.classList = ch.list\r\n        }\r\n    }\r\n    for (let ch of plan) {\r\n        yield void 0;\r\n        if (ch.option == \"attributesChange\") {\r\n            domApi.attributesClone(ch.ele, ch.to)\r\n        }\r\n    }\r\n}\r\n\r\nlet diff = async (targetDom, newHtml) => {\r\n    let newTreeChilds = domApi.createDomTree(newHtml)\r\n    let patchArr = await lcsDomtree(newTreeChilds, targetDom)\r\n    await frameify(patch(patchArr))\r\n    return patchArr\r\n}\r\n\r\nmodule.exports = diff\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9kaWZmLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvZGlmZi5qcz9lYzZiIl0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5jb25zdCB7ZG9tQXBpfSA9IHJlcXVpcmUoXCIuLi91dGlsL2RvbUFwaS5qc1wiKTtcclxuXHJcbmNvbnN0IHtcclxuICAgIGZyYW1laWZ5XHJcbn0gPSByZXF1aXJlKCcuLi91dGlsL2ZyYW1laWZ5LmpzJyk7XHJcblxyXG4vLyBjb25zdCBkZWJ1Z09iaiA9IHJlcXVpcmUoXCIuLi91dGlsL2RlYnVnXCIpXHJcbmxldCBfbGNzRG9tQXJyID0gYXN5bmMgKG5ld0RvbUVsZSwgb2xkRG9tRWxlLCB0YXJnZXREb20pID0+IHtcclxuICAgIGxldCBwbGFuQXJyID0gW107XHJcbiAgICBpZiAob2xkRG9tRWxlLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgZm9yIChsZXQgbkVsaSBpbiBuZXdEb21FbGUpIHtcclxuICAgICAgICAgICAgcGxhbkFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbjogXCJhZGRcIixcclxuICAgICAgICAgICAgICAgIGVsZTogbmV3RG9tRWxlW25FbGldLFxyXG4gICAgICAgICAgICAgICAgdXBwZXI6IHRhcmdldERvbVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGxhbkFyclxyXG4gICAgfVxyXG4gICAgaWYgKG5ld0RvbUVsZS5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgIGZvciAobGV0IG9FbGkgaW4gb2xkRG9tRWxlKSB7XHJcbiAgICAgICAgICAgIHBsYW5BcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBvcHRpb246IFwiZGVsZXRlXCIsXHJcbiAgICAgICAgICAgICAgICBlbGU6IG9sZERvbUVsZVtvRWxpXVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGxhbkFyclxyXG4gICAgfVxyXG4gICAgbGV0IGxjc19hcnIgPSBhd2FpdCBmcmFtZWlmeShsY3NPbkFycihuZXdEb21FbGUsIG9sZERvbUVsZSwgZG9tQXBpLmlzU2FtZSkpLFxyXG4gICAgICAgIGN1ckEgPSAwLFxyXG4gICAgICAgIGN1ckIgPSAwO1xyXG5cclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgaWYgKGN1ckEgPj0gbGNzX2Fyci5sZW5ndGggJiYgY3VyQiA+PSBsY3NfYXJyWzBdLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5yID0gbGNzX2FycltjdXJBICsgMV0gPyBsY3NfYXJyW2N1ckEgKyAxXSA6IFtdLFxyXG4gICAgICAgICAgICBjciA9IGxjc19hcnJbY3VyQV0gPyBsY3NfYXJyW2N1ckFdIDogW107XHJcbiAgICAgICAgbGV0IHJ2ID0gY3JbY3VyQiArIDFdID8gY3JbY3VyQiArIDFdIDogMCxcclxuICAgICAgICAgICAgYnYgPSBucltjdXJCXSA/IG5yW2N1ckJdIDogMCxcclxuICAgICAgICAgICAgcmJ2ID0gbnJbY3VyQiArIDFdID8gbnJbY3VyQiArIDFdIDogMCxcclxuICAgICAgICAgICAgdmFsID0gY3JbY3VyQl07XHJcbiAgICAgICAgaWYgKGRvbUFwaS5pc1NhbWUobmV3RG9tRWxlW2N1ckFdLCBvbGREb21FbGVbY3VyQl0pKSB7XHJcbiAgICAgICAgICAgIC8vIHNhbWUgY2hhclxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhjdXJBLGN1ckIsbHR2LG52LGx0disxPT1udilcclxuICAgICAgICAgICAgaWYgKG5ld0RvbUVsZVtjdXJBXS5jbGFzc0xpc3QgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRvbUFwaS5jbGFzc0xpc3REaWZmKG5ld0RvbUVsZVtjdXJBXSwgb2xkRG9tRWxlW2N1ckJdKSlcclxuICAgICAgICAgICAgICAgICAgICBwbGFuQXJyLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb246IFwiY2xhc3NDaGFuZ2VcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlOiBvbGREb21FbGVbY3VyQl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3Q6IG5ld0RvbUVsZVtjdXJBXS5jbGFzc0xpc3RcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGF0dHJpYnV0ZXNEaWZmXHJcbiAgICAgICAgICAgIGlmIChuZXdEb21FbGVbY3VyQV0uYXR0cmlidXRlcyAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZG9tQXBpLmF0dHJpYnV0ZXNEaWZmKG5ld0RvbUVsZVtjdXJBXSwgb2xkRG9tRWxlW2N1ckJdKSlcclxuICAgICAgICAgICAgICAgICAgICBwbGFuQXJyLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb246IFwiYXR0cmlidXRlc0NoYW5nZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGU6IG9sZERvbUVsZVtjdXJCXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IG5ld0RvbUVsZVtjdXJBXVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VyQSArPSAxO1xyXG4gICAgICAgICAgICBjdXJCICs9IDE7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodmFsID09IDAgJiYgcmJ2ICE9IDEpIHtcclxuICAgICAgICAgICAgcGxhbkFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbjogXCJhZGRcIixcclxuICAgICAgICAgICAgICAgIGJlZm9yZTogb2xkRG9tRWxlW2N1ckJdLFxyXG4gICAgICAgICAgICAgICAgYWZ0ZXI6IG9sZERvbUVsZVtjdXJCICsgMV0sXHJcbiAgICAgICAgICAgICAgICBlbGU6IG5ld0RvbUVsZVtjdXJBXSxcclxuICAgICAgICAgICAgICAgIHVwcGVyOiB0YXJnZXREb21cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgY3VyQSArPSAxO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKHJ2ID09IGJ2KSB7XHJcbiAgICAgICAgICAgIC8vIHRhKzFcIl9cIiB0YisxY2FoclxyXG4gICAgICAgICAgICBwbGFuQXJyLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uOiBcImRlbGV0ZVwiLFxyXG4gICAgICAgICAgICAgICAgZWxlOiBvbGREb21FbGVbY3VyQl1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLy8gIzIwMSBNYXRyaXggYm91bmRhcnlcclxuICAgICAgICAgICAgaWYobmV3RG9tRWxlW2N1ckFdICE9IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIHBsYW5BcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uOiBcImFkZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZTogb2xkRG9tRWxlW2N1ckJdLFxyXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyOiBvbGREb21FbGVbY3VyQiArIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGVsZTogbmV3RG9tRWxlW2N1ckFdLFxyXG4gICAgICAgICAgICAgICAgICAgIHVwcGVyOiB0YXJnZXREb21cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGN1ckEgKz0gMTtcclxuICAgICAgICAgICAgY3VyQiArPSAxO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKHJ2ID4gYnYpIHtcclxuICAgICAgICAgICAgcGxhbkFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbjogXCJkZWxldGVcIixcclxuICAgICAgICAgICAgICAgIGVsZTogb2xkRG9tRWxlW2N1ckJdXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGN1ckIgKz0gMTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdGIrMVwiX1wiIHRhKzFjaGFyXHJcbiAgICAgICAgICAgIHBsYW5BcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBvcHRpb246IFwiYWRkXCIsXHJcbiAgICAgICAgICAgICAgICBiZWZvcmU6IG9sZERvbUVsZVtjdXJCXSxcclxuICAgICAgICAgICAgICAgIGFmdGVyOiBvbGREb21FbGVbY3VyQiArIDFdLFxyXG4gICAgICAgICAgICAgICAgZWxlOiBuZXdEb21FbGVbY3VyQV0sXHJcbiAgICAgICAgICAgICAgICB1cHBlcjogdGFyZ2V0RG9tXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGN1ckEgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGxhbkFyclxyXG59XHJcbi8vICMxMDEgVGltZSBjb21wbGV4aXR5OiBPKGFycjEubGVuZ3RoICogYXJyMi5sZW5ndGgpXHJcbmxldCBsY3NPbkFyciA9IGZ1bmN0aW9uKihhcnIxLCBhcnIyLCBjb21wYXJlRm4pIHtcclxuICAgIC8vIGxldCBkYmcgPSBuZXcgZGVidWdPYmooXCJsY3NPbkFyclwiKTtcclxuICAgIGxldCBsY3NBcnIgPSBbXTtcclxuICAgIGZvciAobGV0IGluZGV4QSBpbiBhcnIxKSB7XHJcbiAgICAgICAgbGV0IHJvd0FyciA9IFtdLFxyXG4gICAgICAgICAgICBpdGVtQSA9IGFycjFbaW5kZXhBXTtcclxuICAgICAgICBmb3IgKGxldCBpbmRleEIgaW4gYXJyMikge1xyXG4gICAgICAgICAgICB5aWVsZCB2b2lkIDA7XHJcbiAgICAgICAgICAgIGxldCBpdGVtQiA9IGFycjJbaW5kZXhCXSxcclxuICAgICAgICAgICAgICAgIGx2ID0gaW5kZXhCID09IDAgPyAwIDogcm93QXJyW2luZGV4QiAtIDFdLFxyXG4gICAgICAgICAgICAgICAgdHYgPSBpbmRleEEgPT0gMCA/IDAgOiBsY3NBcnJbaW5kZXhBIC0gMV1baW5kZXhCXSxcclxuICAgICAgICAgICAgICAgIGx0diA9IGluZGV4QiAhPSAwICYmIGluZGV4QSAhPSAwID8gbGNzQXJyW2luZGV4QSAtIDFdW2luZGV4QiAtIDFdIDogMDtcclxuICAgICAgICAgICAgaWYgKGNvbXBhcmVGbihpdGVtQSwgaXRlbUIpKSB7XHJcbiAgICAgICAgICAgICAgICByb3dBcnIucHVzaChsdHYgKyAxKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJvd0Fyci5wdXNoKGx2ID4gdHYgPyBsdiA6IHR2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsY3NBcnIucHVzaChyb3dBcnIpO1xyXG4gICAgfVxyXG4gICAgLy8gZGJnLmxvZygpXHJcbiAgICByZXR1cm4gbGNzQXJyO1xyXG59XHJcbmxldCBsY3NEb210cmVlID0gYXN5bmMgKG5ld0NoaWxkcmVuLCBvbGRUcmVlKSA9PiB7XHJcbiAgICBsZXQgaXNTYW1lVHJlZSA9IChlbGUxLCBlbGUyKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgZWxlMS5ub2RlTmFtZSA9PSBlbGUyLm5vZGVOYW1lICYmXHJcbiAgICAgICAgICAgIGVsZTEuaWQgPT0gZWxlMi5pZCAmJlxyXG4gICAgICAgICAgICBlbGUxLmNsYXNzTmFtZSA9PSBlbGUyLmNsYXNzTmFtZVxyXG4gICAgICAgIClcclxuICAgIH1cclxuICAgIGxldCBOY2hpID0gW10sXHJcbiAgICAgICAgT2NoaSA9IFtdLFxyXG4gICAgICAgIHBsYW5BcnIgPSBbXSxcclxuICAgICAgICBOc3ViVHJlZSA9IFtdLFxyXG4gICAgICAgIE9zdWJUcmVlID0gW11cclxuICAgIGZvciAobGV0IGluZGV4IGluIG5ld0NoaWxkcmVuKSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IFwibGVuZ3RoXCIpIGJyZWFrO1xyXG4gICAgICAgIGxldCBjaGlsZCA9IG5ld0NoaWxkcmVuW2luZGV4XVxyXG4gICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzICYmIGNoaWxkLnRleHRDb250ZW50LnRyaW0oKS5yZXBsYWNlKC9cXG4vZywgXCJcIikgPT0gXCJcIikgY29udGludWU7XHJcbiAgICAgICAgLy8gaWYgKGNoaWxkLmNoaWxkTm9kZXMubGVuZ3RoID09IDApIHtcclxuICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMyB8fCBjaGlsZC5jaGlsZHJlbi5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICBOY2hpLnB1c2goY2hpbGQpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgTnN1YlRyZWUucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBlbGU6IGNoaWxkXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaW5kZXggaW4gb2xkVHJlZS5jaGlsZE5vZGVzKSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IFwibGVuZ3RoXCIpIGJyZWFrO1xyXG4gICAgICAgIGxldCBjaGlsZCA9IG9sZFRyZWUuY2hpbGROb2Rlc1tpbmRleF1cclxuICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMyAmJiBjaGlsZC50ZXh0Q29udGVudC50cmltKCkucmVwbGFjZSgvXFxuL2csIFwiXCIpID09IFwiXCIpIGNvbnRpbnVlO1xyXG4gICAgICAgIC8vIGlmIChjaGlsZC5jaGlsZE5vZGVzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMgfHwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgbGV0IGlzZ290byA9IGZhbHNlXHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSAhPSAzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBfYyBvZiBOc3ViVHJlZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21BcGkuaXNTYW1lKF9jLmVsZSwgY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE9zdWJUcmVlLnB1c2goY2hpbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzZ290byA9IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc2dvdG8pIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIE9jaGkucHVzaChjaGlsZClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBPc3ViVHJlZS5wdXNoKGNoaWxkKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChPY2hpLmxlbmd0aCA9PSAwICYmIE9zdWJUcmVlLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgTmNoaSA9IFtdXHJcbiAgICAgICAgTnN1YlRyZWUgPSBbXVxyXG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIG5ld0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSBcImxlbmd0aFwiKSBicmVhaztcclxuICAgICAgICAgICAgbGV0IGNoaWxkID0gbmV3Q2hpbGRyZW5baW5kZXhdXHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzICYmIGNoaWxkLnRleHRDb250ZW50LnRyaW0oKS5yZXBsYWNlKC9cXG4vZywgXCJcIikgPT0gXCJcIikgY29udGludWU7XHJcbiAgICAgICAgICAgIE5jaGkucHVzaChjaGlsZClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBsZXQgcGxhbiA9IGxjc0RvbUFycihOY2hpLCBPY2hpLCBvbGRUcmVlKVxyXG4gICAgbGV0IHBsYW4gPSBhd2FpdCBfbGNzRG9tQXJyKE5jaGksIE9jaGksIG9sZFRyZWUpXHJcblxyXG4gICAgaWYgKHBsYW4ubGVuZ3RoICE9IDApIHtcclxuICAgICAgICBwbGFuQXJyLnB1c2guYXBwbHkocGxhbkFyciwgcGxhbilcclxuICAgIH1cclxuICAgIGZvciAobGV0IG5pIGluIE5zdWJUcmVlKSB7XHJcbiAgICAgICAgbGV0IG50cmVlID0gTnN1YlRyZWVbbmldLmVsZVxyXG4gICAgICAgIGZvciAobGV0IG9pIGluIE9zdWJUcmVlKSB7XHJcbiAgICAgICAgICAgIGxldCBvdHJlZSA9IE9zdWJUcmVlW29pXVxyXG4gICAgICAgICAgICBpZiAoaXNTYW1lVHJlZShudHJlZSwgb3RyZWUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb21wYXJlXHJcbiAgICAgICAgICAgICAgICBpZiAobnRyZWUuY2xhc3NMaXN0ICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9tQXBpLmNsYXNzTGlzdERpZmYobnRyZWUsIG90cmVlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhbkFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbjogXCJjbGFzc0NoYW5nZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlOiBvdHJlZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3Q6IG50cmVlLmNsYXNzTGlzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gYXR0cmlidXRlc0RpZmZcclxuICAgICAgICAgICAgICAgIGlmIChudHJlZS5hdHRyaWJ1dGVzICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9tQXBpLmF0dHJpYnV0ZXNEaWZmKG50cmVlLCBvdHJlZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYW5BcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb246IFwiYXR0cmlidXRlc0NoYW5nZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlOiBvdHJlZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBudHJlZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZGlmZiBlbmRpbmdcclxuICAgICAgICAgICAgICAgIGlmIChwbGFuQXJyLmxlbmd0aCAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGxhbkFyci5wdXNoLmFwcGx5KHBsYW5BcnIsIGxjc0RvbXRyZWUobnRyZWUuY2hpbGROb2Rlcywgb3RyZWUpKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwbGFuQXJyID0gbGNzRG9tdHJlZShudHJlZS5jaGlsZE5vZGVzLCBvdHJlZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBOc3ViVHJlZVtuaV1cclxuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBPc3ViVHJlZVtvaV1cclxuICAgICAgICAgICAgICAgIE5zdWJUcmVlLnNwbGljZShuaSwxKVxyXG4gICAgICAgICAgICAgICAgT3N1YlRyZWUuc3BsaWNlKG9pLDEpXHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgbmkgaW4gTnN1YlRyZWUpIHtcclxuICAgICAgICBpZiAoTnN1YlRyZWVbbmldKSB7XHJcbiAgICAgICAgICAgIGlmIChOc3ViVHJlZVtuaV0uZWxlLm5vZGVUeXBlID09IDMgJiYgTnN1YlRyZWVbbmldLmVsZS50ZXh0Q29udGVudC50cmltKCkucmVwbGFjZSgvXFxuL2csIFwiXCIpID09IFwiXCIpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBwbGFuQXJyLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uOiBcImFkZFwiLFxyXG4gICAgICAgICAgICAgICAgYmVmb3JlOiBOc3ViVHJlZVtuaV0uYmVmb3JlLFxyXG4gICAgICAgICAgICAgICAgYWZ0ZXI6IE5zdWJUcmVlW25pXS5hZnRlcixcclxuICAgICAgICAgICAgICAgIGVsZTogTnN1YlRyZWVbbmldLmVsZSxcclxuICAgICAgICAgICAgICAgIHVwcGVyOiBvbGRUcmVlXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgbmkgaW4gT3N1YlRyZWUpIHtcclxuICAgICAgICBpZiAoT3N1YlRyZWVbbmldKSB7XHJcbiAgICAgICAgICAgIHBsYW5BcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBvcHRpb246IFwiZGVsZXRlXCIsXHJcbiAgICAgICAgICAgICAgICBlbGU6IE9zdWJUcmVlW25pXVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGxhbkFyclxyXG59XHJcblxyXG5sZXQgcGF0Y2ggPSBmdW5jdGlvbioocGxhbikge1xyXG4gICAgZm9yIChsZXQgY2ggb2YgcGxhbikge1xyXG4gICAgICAgIHlpZWxkIHZvaWQgMDtcclxuICAgICAgICBpZiAoY2gub3B0aW9uID09IFwiYWRkXCIpIHtcclxuICAgICAgICAgICAgaWYgKGNoLmFmdGVyICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgZG9tQXBpLmluc2VydEJlZm9yZShjaC5lbGUsIGNoLmFmdGVyKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoLmJlZm9yZSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGRvbUFwaS5pbnNlcnRBZnRlcihjaC5lbGUsIGNoLmJlZm9yZSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvbUFwaS5hcHBlbmQoY2guZWxlLCBjaC51cHBlcilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAobGV0IGNoIG9mIHBsYW4pIHtcclxuICAgICAgICB5aWVsZCB2b2lkIDA7XHJcbiAgICAgICAgaWYgKGNoLm9wdGlvbiA9PSBcImRlbGV0ZVwiKSB7XHJcbiAgICAgICAgICAgIGRvbUFwaS5yZW1vdmUoY2guZWxlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAobGV0IGNoIG9mIHBsYW4pIHtcclxuICAgICAgICB5aWVsZCB2b2lkIDA7XHJcbiAgICAgICAgaWYgKGNoLm9wdGlvbiA9PSBcImNsYXNzQ2hhbmdlXCIpIHtcclxuICAgICAgICAgICAgY2guZWxlLmNsYXNzTGlzdCA9IGNoLmxpc3RcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBjaCBvZiBwbGFuKSB7XHJcbiAgICAgICAgeWllbGQgdm9pZCAwO1xyXG4gICAgICAgIGlmIChjaC5vcHRpb24gPT0gXCJhdHRyaWJ1dGVzQ2hhbmdlXCIpIHtcclxuICAgICAgICAgICAgZG9tQXBpLmF0dHJpYnV0ZXNDbG9uZShjaC5lbGUsIGNoLnRvKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxubGV0IGRpZmYgPSBhc3luYyAodGFyZ2V0RG9tLCBuZXdIdG1sKSA9PiB7XHJcbiAgICBsZXQgbmV3VHJlZUNoaWxkcyA9IGRvbUFwaS5jcmVhdGVEb21UcmVlKG5ld0h0bWwpXHJcbiAgICBsZXQgcGF0Y2hBcnIgPSBhd2FpdCBsY3NEb210cmVlKG5ld1RyZWVDaGlsZHMsIHRhcmdldERvbSlcclxuICAgIGF3YWl0IGZyYW1laWZ5KHBhdGNoKHBhdGNoQXJyKSlcclxuICAgIHJldHVybiBwYXRjaEFyclxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGRpZmZcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/diff.js\n");

/***/ }),

/***/ "./src/core/event.js":
/*!***************************!*\
  !*** ./src/core/event.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {ev_supList} = __webpack_require__(/*! ../util/util */ \"./src/util/util.js\");\r\n\r\n\r\nclass EventObj {\r\n    constructor() {\r\n        this.subscribe = {}\r\n    }\r\n    on(channel, fn) {\r\n        let old = this.subscribe[channel]?this.subscribe[channel].func:undefined;\r\n        if (old==undefined) this.subscribe[channel] = {locked:0}\r\n        this.subscribe[channel].func = function(_args) {\r\n            if (typeof old == \"function\") {\r\n                old(_args);\r\n            }\r\n            fn(_args);\r\n        }\r\n    }\r\n    emit(channel, _args) {\r\n        if(this.subscribe[channel]!==undefined){\r\n            if (this.subscribe[channel].locked>0)return\r\n            else this.block(channel)\r\n            if (typeof this.subscribe[channel].func == \"function\") {\r\n                this.subscribe[channel].func(_args);\r\n            }\r\n            this.unblock(channel)\r\n        }\r\n    }\r\n    block(channel) {\r\n        if(this.subscribe[channel]==undefined)return\r\n        this.subscribe[channel].locked += 1\r\n    }\r\n    unblock(channel) {\r\n        if(this.subscribe[channel]==undefined)return\r\n        this.subscribe[channel].locked -= 1\r\n    }\r\n    clear(){\r\n        this.subscribe = {};\r\n    }\r\n}\r\nclass EventObjForEle extends EventObj {\r\n    constructor(ele) {\r\n        super();\r\n        this.el = ele;\r\n        this.__init_nativeEv();\r\n    }\r\n    __init_nativeEv() {\r\n        ev_supList.forEach((val, index) => {\r\n            this.el.addEventListener(val, e => {\r\n                this.emit(val, e);\r\n            })\r\n        })\r\n    }\r\n    // addEventListener(evName,ele,fn){\r\n    //     this.el.addEventListener(evName, e => {\r\n    //         if(e.target==ele){\r\n    //             fn()\r\n    //         }\r\n    //     })\r\n    // }\r\n}\r\n\r\nmodule.exports = EventObjForEle;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9ldmVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb3JlL2V2ZW50LmpzPzlkMGYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qge2V2X3N1cExpc3R9ID0gcmVxdWlyZShcIi4uL3V0aWwvdXRpbFwiKTtcclxuXHJcblxyXG5jbGFzcyBFdmVudE9iaiB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnN1YnNjcmliZSA9IHt9XHJcbiAgICB9XHJcbiAgICBvbihjaGFubmVsLCBmbikge1xyXG4gICAgICAgIGxldCBvbGQgPSB0aGlzLnN1YnNjcmliZVtjaGFubmVsXT90aGlzLnN1YnNjcmliZVtjaGFubmVsXS5mdW5jOnVuZGVmaW5lZDtcclxuICAgICAgICBpZiAob2xkPT11bmRlZmluZWQpIHRoaXMuc3Vic2NyaWJlW2NoYW5uZWxdID0ge2xvY2tlZDowfVxyXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlW2NoYW5uZWxdLmZ1bmMgPSBmdW5jdGlvbihfYXJncykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9sZCA9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIG9sZChfYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm4oX2FyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVtaXQoY2hhbm5lbCwgX2FyZ3MpIHtcclxuICAgICAgICBpZih0aGlzLnN1YnNjcmliZVtjaGFubmVsXSE9PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmliZVtjaGFubmVsXS5sb2NrZWQ+MClyZXR1cm5cclxuICAgICAgICAgICAgZWxzZSB0aGlzLmJsb2NrKGNoYW5uZWwpXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdWJzY3JpYmVbY2hhbm5lbF0uZnVuYyA9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlW2NoYW5uZWxdLmZ1bmMoX2FyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudW5ibG9jayhjaGFubmVsKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGJsb2NrKGNoYW5uZWwpIHtcclxuICAgICAgICBpZih0aGlzLnN1YnNjcmliZVtjaGFubmVsXT09dW5kZWZpbmVkKXJldHVyblxyXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlW2NoYW5uZWxdLmxvY2tlZCArPSAxXHJcbiAgICB9XHJcbiAgICB1bmJsb2NrKGNoYW5uZWwpIHtcclxuICAgICAgICBpZih0aGlzLnN1YnNjcmliZVtjaGFubmVsXT09dW5kZWZpbmVkKXJldHVyblxyXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlW2NoYW5uZWxdLmxvY2tlZCAtPSAxXHJcbiAgICB9XHJcbiAgICBjbGVhcigpe1xyXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlID0ge307XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRXZlbnRPYmpGb3JFbGUgZXh0ZW5kcyBFdmVudE9iaiB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZWwgPSBlbGU7XHJcbiAgICAgICAgdGhpcy5fX2luaXRfbmF0aXZlRXYoKTtcclxuICAgIH1cclxuICAgIF9faW5pdF9uYXRpdmVFdigpIHtcclxuICAgICAgICBldl9zdXBMaXN0LmZvckVhY2goKHZhbCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKHZhbCwgZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQodmFsLCBlKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgLy8gYWRkRXZlbnRMaXN0ZW5lcihldk5hbWUsZWxlLGZuKXtcclxuICAgIC8vICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoZXZOYW1lLCBlID0+IHtcclxuICAgIC8vICAgICAgICAgaWYoZS50YXJnZXQ9PWVsZSl7XHJcbiAgICAvLyAgICAgICAgICAgICBmbigpXHJcbiAgICAvLyAgICAgICAgIH1cclxuICAgIC8vICAgICB9KVxyXG4gICAgLy8gfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50T2JqRm9yRWxlO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/event.js\n");

/***/ }),

/***/ "./src/core/template.js":
/*!******************************!*\
  !*** ./src/core/template.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const JsVm = __webpack_require__(/*! ../util/JsVm.js */ \"./src/util/JsVm.js\");\r\nconst {\r\n    deepClone\r\n} = __webpack_require__(/*! ../util/util.js */ \"./src/util/util.js\");\r\n// const evIdSuffix = \"event-id\";\r\n\r\n// var randHash = H_length => {\r\n//     H_length = H_length || 10;\r\n//     let res = \"\",\r\n//         $chars = \"ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678\",\r\n//         maxPos = $chars.length;　　\r\n//     for (let i = 0; i < H_length; i++) {\r\n//         res += $chars.charAt(Math.floor(Math.random() * maxPos));　　\r\n//     }\r\n//     return res\r\n// }\r\n//\r\n// this is F!!! shit!\r\n//\r\n//\r\n// let prehtml = (html ,evManger)=>{\r\n//     // afterJoint(html) {\r\n//     let insert_item = (str, item, index) => {\r\n//         let newstr = \"\"; //初始化一个空字符串\r\n//         let tmp = str.substring(0, index);\r\n//         let estr = str.substring(index, str.length);\r\n//         newstr += tmp + item + estr;\r\n//         return newstr;\r\n//     }\r\n//     let repRegArr = (text, s_reg, repStr) => {\r\n//         text = text.replace(s_reg, \"\");\r\n//         return insert_item(text, repStr, text.indexOf(\">\"));\r\n//     }\r\n//     let rep_non_print = (text) => {\r\n//         return text.replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\").replace(\"\\f\", \"\\\\f\").replace(\"\\v\", \"\\\\v\").replace(\"\\r\", \"\\\\r\")\r\n//     }\r\n//     let pushEventTo = (arr, option_html, hash_id) => {\r\n//         let eReg = / (bind|on|model):(.+?)=(\\\\?('|\")([\\s\\S]+?)\\\\?\\4)/g;\r\n//         let _option = eReg.exec(option_html)\r\n//         arr[_option[1]].push({\r\n//             id: hash_id,\r\n//             eventName: _option[2],\r\n//             codeStr: rep_non_print(_option[5])\r\n//         })\r\n//     }\r\n//     let tagReg = /<[\\s\\S]+?>/g;\r\n//     let eventReg = / (bind|on|model):(.+?)=(\\\\?('|\")([\\s\\S]+?)\\\\?\\4)/g;\r\n//     let tagArr = html.match(tagReg);\r\n//     let textArr = html.split(tagReg);\r\n//     for (var i = 0; i < tagArr.length; i++) {\r\n//         let attributes = tagArr[i].match(eventReg)\r\n//         if (attributes) {\r\n//             let hash_id = randHash();\r\n//             if (attributes.length > 1) {\r\n//                 for (let j = 0; j < attributes.length; j++) {\r\n//                     pushEventTo(evManger, attributes[j], hash_id)\r\n//                 }\r\n//             } else if (attributes.length === 1) {\r\n//                 pushEventTo(evManger, attributes[0], hash_id)\r\n//             }\r\n//             tagArr[i] = repRegArr(tagArr[i], eventReg, \" data-\" + evIdSuffix + \"='\" + hash_id + \"'\")\r\n//         }\r\n//     }\r\n//     let newHeml = textArr[0];\r\n//     for (let i = 0; i < tagArr.length; i++) {\r\n//         newHeml += tagArr[i];\r\n//         newHeml += textArr[i + 1] ? textArr[i + 1] : \"\";\r\n//     }\r\n//     return newHeml;\r\n// }\r\n\r\nlet afterJoint = (_html, poi_id)=>{\r\n    let re = /<([^/]+?)( [^<>]+)*>/g\r\n    let tagArr = _html.match(re)\r\n    for (let tag of tagArr) {\r\n        re = /<([^/]+?)( [^<>]+)*>/g\r\n        let option = re.exec(tag)[2]\r\n        if(/([^<>]+):([^<>]+)=('|\")[^<>]+?\\3/g.test(option)){\r\n            _html = _html.replace(option, option+\" PoiId=\\\"\"+poi_id+\"\\\"\")\r\n        }\r\n    }\r\n    return _html\r\n}\r\n\r\nclass TemplateEngine {\r\n    constructor(html, preMark, tailMark) {\r\n        let fixRegKeyWord = str => str === undefined ? null : str.replace(/([$|{|}|(|)|.|\\\\|*|+|?|^|\\||\\[|\\]])/g, \"\\\\$1\");\r\n        preMark = fixRegKeyWord(preMark) || \"<%\";\r\n        tailMark = fixRegKeyWord(tailMark) || \"%>\";\r\n        let re = new RegExp(preMark + \"(.+?)\" + tailMark, \"g\"),\r\n            reExp = /(^( )?(var|let|if|for|else|switch|case|default|break|{|}|;))(.+)?/g,\r\n            cursor = 0,\r\n            code = 'var r=[];\\n',\r\n            match;\r\n        let add = function(line, js) {\r\n            js ? (code += line.match(reExp) ? line + '\\n' : 'r.push(' + line + ');\\n') :\r\n                (code += line != '' ? 'r.push(\"' + line.replace(/\"/g, '\\\\\"') + '\");\\n' : '');\r\n            return add;\r\n        }\r\n        while (match = re.exec(html)) {\r\n            add(html.slice(cursor, match.index))(match[1], true);\r\n            cursor = match.index + match[0].length;\r\n        }\r\n        add(html.substr(cursor, html.length - cursor));\r\n        this.code = (code + 'return r.join(\"\");').replace(/[\\r\\t\\n]/g, ' ');\r\n\r\n        // joint for bind\r\n        // this.prehtml(this.joint({}))\r\n    }\r\n    joint(options, poi_id) {\r\n        let result\r\n        // result = new Function('obj', \"with(obj){\"+this.code+\"}\").apply(options, [options]);\r\n        result = JsVm.safe(this.code, options);\r\n        // result = JsVm.vm(this.code, deepClone(options));\r\n        if(poi_id!=undefined){\r\n            return afterJoint(result, poi_id)\r\n        }else{\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = TemplateEngine;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS90ZW1wbGF0ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb3JlL3RlbXBsYXRlLmpzP2Y1OGYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgSnNWbSA9IHJlcXVpcmUoXCIuLi91dGlsL0pzVm0uanNcIik7XHJcbmNvbnN0IHtcclxuICAgIGRlZXBDbG9uZVxyXG59ID0gcmVxdWlyZShcIi4uL3V0aWwvdXRpbC5qc1wiKTtcclxuLy8gY29uc3QgZXZJZFN1ZmZpeCA9IFwiZXZlbnQtaWRcIjtcclxuXHJcbi8vIHZhciByYW5kSGFzaCA9IEhfbGVuZ3RoID0+IHtcclxuLy8gICAgIEhfbGVuZ3RoID0gSF9sZW5ndGggfHwgMTA7XHJcbi8vICAgICBsZXQgcmVzID0gXCJcIixcclxuLy8gICAgICAgICAkY2hhcnMgPSBcIkFCQ0RFRkdISktNTlBRUlNUV1hZWmFiY2RlZmhpamttbnByc3R3eHl6MjM0NTY3OFwiLFxyXG4vLyAgICAgICAgIG1heFBvcyA9ICRjaGFycy5sZW5ndGg744CA44CAXHJcbi8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEhfbGVuZ3RoOyBpKyspIHtcclxuLy8gICAgICAgICByZXMgKz0gJGNoYXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXhQb3MpKTvjgIDjgIBcclxuLy8gICAgIH1cclxuLy8gICAgIHJldHVybiByZXNcclxuLy8gfVxyXG4vL1xyXG4vLyB0aGlzIGlzIEYhISEgc2hpdCFcclxuLy9cclxuLy9cclxuLy8gbGV0IHByZWh0bWwgPSAoaHRtbCAsZXZNYW5nZXIpPT57XHJcbi8vICAgICAvLyBhZnRlckpvaW50KGh0bWwpIHtcclxuLy8gICAgIGxldCBpbnNlcnRfaXRlbSA9IChzdHIsIGl0ZW0sIGluZGV4KSA9PiB7XHJcbi8vICAgICAgICAgbGV0IG5ld3N0ciA9IFwiXCI7IC8v5Yid5aeL5YyW5LiA5Liq56m65a2X56ym5LiyXHJcbi8vICAgICAgICAgbGV0IHRtcCA9IHN0ci5zdWJzdHJpbmcoMCwgaW5kZXgpO1xyXG4vLyAgICAgICAgIGxldCBlc3RyID0gc3RyLnN1YnN0cmluZyhpbmRleCwgc3RyLmxlbmd0aCk7XHJcbi8vICAgICAgICAgbmV3c3RyICs9IHRtcCArIGl0ZW0gKyBlc3RyO1xyXG4vLyAgICAgICAgIHJldHVybiBuZXdzdHI7XHJcbi8vICAgICB9XHJcbi8vICAgICBsZXQgcmVwUmVnQXJyID0gKHRleHQsIHNfcmVnLCByZXBTdHIpID0+IHtcclxuLy8gICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHNfcmVnLCBcIlwiKTtcclxuLy8gICAgICAgICByZXR1cm4gaW5zZXJ0X2l0ZW0odGV4dCwgcmVwU3RyLCB0ZXh0LmluZGV4T2YoXCI+XCIpKTtcclxuLy8gICAgIH1cclxuLy8gICAgIGxldCByZXBfbm9uX3ByaW50ID0gKHRleHQpID0+IHtcclxuLy8gICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKFwiXFxuXCIsIFwiXFxcXG5cIikucmVwbGFjZShcIlxcdFwiLCBcIlxcXFx0XCIpLnJlcGxhY2UoXCJcXGZcIiwgXCJcXFxcZlwiKS5yZXBsYWNlKFwiXFx2XCIsIFwiXFxcXHZcIikucmVwbGFjZShcIlxcclwiLCBcIlxcXFxyXCIpXHJcbi8vICAgICB9XHJcbi8vICAgICBsZXQgcHVzaEV2ZW50VG8gPSAoYXJyLCBvcHRpb25faHRtbCwgaGFzaF9pZCkgPT4ge1xyXG4vLyAgICAgICAgIGxldCBlUmVnID0gLyAoYmluZHxvbnxtb2RlbCk6KC4rPyk9KFxcXFw/KCd8XCIpKFtcXHNcXFNdKz8pXFxcXD9cXDQpL2c7XHJcbi8vICAgICAgICAgbGV0IF9vcHRpb24gPSBlUmVnLmV4ZWMob3B0aW9uX2h0bWwpXHJcbi8vICAgICAgICAgYXJyW19vcHRpb25bMV1dLnB1c2goe1xyXG4vLyAgICAgICAgICAgICBpZDogaGFzaF9pZCxcclxuLy8gICAgICAgICAgICAgZXZlbnROYW1lOiBfb3B0aW9uWzJdLFxyXG4vLyAgICAgICAgICAgICBjb2RlU3RyOiByZXBfbm9uX3ByaW50KF9vcHRpb25bNV0pXHJcbi8vICAgICAgICAgfSlcclxuLy8gICAgIH1cclxuLy8gICAgIGxldCB0YWdSZWcgPSAvPFtcXHNcXFNdKz8+L2c7XHJcbi8vICAgICBsZXQgZXZlbnRSZWcgPSAvIChiaW5kfG9ufG1vZGVsKTooLis/KT0oXFxcXD8oJ3xcIikoW1xcc1xcU10rPylcXFxcP1xcNCkvZztcclxuLy8gICAgIGxldCB0YWdBcnIgPSBodG1sLm1hdGNoKHRhZ1JlZyk7XHJcbi8vICAgICBsZXQgdGV4dEFyciA9IGh0bWwuc3BsaXQodGFnUmVnKTtcclxuLy8gICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFnQXJyLmxlbmd0aDsgaSsrKSB7XHJcbi8vICAgICAgICAgbGV0IGF0dHJpYnV0ZXMgPSB0YWdBcnJbaV0ubWF0Y2goZXZlbnRSZWcpXHJcbi8vICAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcclxuLy8gICAgICAgICAgICAgbGV0IGhhc2hfaWQgPSByYW5kSGFzaCgpO1xyXG4vLyAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5sZW5ndGggPiAxKSB7XHJcbi8vICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBqKyspIHtcclxuLy8gICAgICAgICAgICAgICAgICAgICBwdXNoRXZlbnRUbyhldk1hbmdlciwgYXR0cmlidXRlc1tqXSwgaGFzaF9pZClcclxuLy8gICAgICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmxlbmd0aCA9PT0gMSkge1xyXG4vLyAgICAgICAgICAgICAgICAgcHVzaEV2ZW50VG8oZXZNYW5nZXIsIGF0dHJpYnV0ZXNbMF0sIGhhc2hfaWQpXHJcbi8vICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgICAgdGFnQXJyW2ldID0gcmVwUmVnQXJyKHRhZ0FycltpXSwgZXZlbnRSZWcsIFwiIGRhdGEtXCIgKyBldklkU3VmZml4ICsgXCI9J1wiICsgaGFzaF9pZCArIFwiJ1wiKVxyXG4vLyAgICAgICAgIH1cclxuLy8gICAgIH1cclxuLy8gICAgIGxldCBuZXdIZW1sID0gdGV4dEFyclswXTtcclxuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFnQXJyLmxlbmd0aDsgaSsrKSB7XHJcbi8vICAgICAgICAgbmV3SGVtbCArPSB0YWdBcnJbaV07XHJcbi8vICAgICAgICAgbmV3SGVtbCArPSB0ZXh0QXJyW2kgKyAxXSA/IHRleHRBcnJbaSArIDFdIDogXCJcIjtcclxuLy8gICAgIH1cclxuLy8gICAgIHJldHVybiBuZXdIZW1sO1xyXG4vLyB9XHJcblxyXG5sZXQgYWZ0ZXJKb2ludCA9IChfaHRtbCwgcG9pX2lkKT0+e1xyXG4gICAgbGV0IHJlID0gLzwoW14vXSs/KSggW148Pl0rKSo+L2dcclxuICAgIGxldCB0YWdBcnIgPSBfaHRtbC5tYXRjaChyZSlcclxuICAgIGZvciAobGV0IHRhZyBvZiB0YWdBcnIpIHtcclxuICAgICAgICByZSA9IC88KFteL10rPykoIFtePD5dKykqPi9nXHJcbiAgICAgICAgbGV0IG9wdGlvbiA9IHJlLmV4ZWModGFnKVsyXVxyXG4gICAgICAgIGlmKC8oW148Pl0rKTooW148Pl0rKT0oJ3xcIilbXjw+XSs/XFwzL2cudGVzdChvcHRpb24pKXtcclxuICAgICAgICAgICAgX2h0bWwgPSBfaHRtbC5yZXBsYWNlKG9wdGlvbiwgb3B0aW9uK1wiIFBvaUlkPVxcXCJcIitwb2lfaWQrXCJcXFwiXCIpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9odG1sXHJcbn1cclxuXHJcbmNsYXNzIFRlbXBsYXRlRW5naW5lIHtcclxuICAgIGNvbnN0cnVjdG9yKGh0bWwsIHByZU1hcmssIHRhaWxNYXJrKSB7XHJcbiAgICAgICAgbGV0IGZpeFJlZ0tleVdvcmQgPSBzdHIgPT4gc3RyID09PSB1bmRlZmluZWQgPyBudWxsIDogc3RyLnJlcGxhY2UoLyhbJHx7fH18KHwpfC58XFxcXHwqfCt8P3xefFxcfHxcXFt8XFxdXSkvZywgXCJcXFxcJDFcIik7XHJcbiAgICAgICAgcHJlTWFyayA9IGZpeFJlZ0tleVdvcmQocHJlTWFyaykgfHwgXCI8JVwiO1xyXG4gICAgICAgIHRhaWxNYXJrID0gZml4UmVnS2V5V29yZCh0YWlsTWFyaykgfHwgXCIlPlwiO1xyXG4gICAgICAgIGxldCByZSA9IG5ldyBSZWdFeHAocHJlTWFyayArIFwiKC4rPylcIiArIHRhaWxNYXJrLCBcImdcIiksXHJcbiAgICAgICAgICAgIHJlRXhwID0gLyheKCApPyh2YXJ8bGV0fGlmfGZvcnxlbHNlfHN3aXRjaHxjYXNlfGRlZmF1bHR8YnJlYWt8e3x9fDspKSguKyk/L2csXHJcbiAgICAgICAgICAgIGN1cnNvciA9IDAsXHJcbiAgICAgICAgICAgIGNvZGUgPSAndmFyIHI9W107XFxuJyxcclxuICAgICAgICAgICAgbWF0Y2g7XHJcbiAgICAgICAgbGV0IGFkZCA9IGZ1bmN0aW9uKGxpbmUsIGpzKSB7XHJcbiAgICAgICAgICAgIGpzID8gKGNvZGUgKz0gbGluZS5tYXRjaChyZUV4cCkgPyBsaW5lICsgJ1xcbicgOiAnci5wdXNoKCcgKyBsaW5lICsgJyk7XFxuJykgOlxyXG4gICAgICAgICAgICAgICAgKGNvZGUgKz0gbGluZSAhPSAnJyA/ICdyLnB1c2goXCInICsgbGluZS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykgKyAnXCIpO1xcbicgOiAnJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBhZGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChtYXRjaCA9IHJlLmV4ZWMoaHRtbCkpIHtcclxuICAgICAgICAgICAgYWRkKGh0bWwuc2xpY2UoY3Vyc29yLCBtYXRjaC5pbmRleCkpKG1hdGNoWzFdLCB0cnVlKTtcclxuICAgICAgICAgICAgY3Vyc29yID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFkZChodG1sLnN1YnN0cihjdXJzb3IsIGh0bWwubGVuZ3RoIC0gY3Vyc29yKSk7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gKGNvZGUgKyAncmV0dXJuIHIuam9pbihcIlwiKTsnKS5yZXBsYWNlKC9bXFxyXFx0XFxuXS9nLCAnICcpO1xyXG5cclxuICAgICAgICAvLyBqb2ludCBmb3IgYmluZFxyXG4gICAgICAgIC8vIHRoaXMucHJlaHRtbCh0aGlzLmpvaW50KHt9KSlcclxuICAgIH1cclxuICAgIGpvaW50KG9wdGlvbnMsIHBvaV9pZCkge1xyXG4gICAgICAgIGxldCByZXN1bHRcclxuICAgICAgICAvLyByZXN1bHQgPSBuZXcgRnVuY3Rpb24oJ29iaicsIFwid2l0aChvYmope1wiK3RoaXMuY29kZStcIn1cIikuYXBwbHkob3B0aW9ucywgW29wdGlvbnNdKTtcclxuICAgICAgICByZXN1bHQgPSBKc1ZtLnNhZmUodGhpcy5jb2RlLCBvcHRpb25zKTtcclxuICAgICAgICAvLyByZXN1bHQgPSBKc1ZtLnZtKHRoaXMuY29kZSwgZGVlcENsb25lKG9wdGlvbnMpKTtcclxuICAgICAgICBpZihwb2lfaWQhPXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHJldHVybiBhZnRlckpvaW50KHJlc3VsdCwgcG9pX2lkKVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZW1wbGF0ZUVuZ2luZTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/template.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime-module.js\");\n/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\nconst Poi = __webpack_require__(/*! ./core/Poi */ \"./src/core/Poi.js\");\r\n// const EventObj = require(\"./core/event\");\r\n// const TplEng = require(\"./core/template\");\r\n// const Jsvm = require(\"./util/JsVm\");\r\n\r\n// Poi.__TEST__ = {\r\n//     ev: (() => {\r\n//         let evobj = new EventObj(document);\r\n//         evobj.on(\"__TEST__\", () => {\r\n//             console.log(\"event manger is working!\")\r\n//         })\r\n//         return evobj;\r\n//     })(),\r\n//     tpl: (_t, _d) => {\r\n//         return new TplEng(_t).joint(_d || {});\r\n//     },\r\n//     vm: Jsvm\r\n// };\r\nif(typeof window != 'undefined')window.Poi = Poi\r\n\r\nlet usage = () => {\r\n    if (console) {\r\n        let msg = `\r\n        thx for u using!!!!poi~\r\n\r\n        now,poi is working!have fun.\r\n        `;\r\n        console.log(msg);\r\n    }\r\n}\r\nusage();\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXCJyZWdlbmVyYXRvci1ydW50aW1lXCI7XHJcblxyXG5jb25zdCBQb2kgPSByZXF1aXJlKFwiLi9jb3JlL1BvaVwiKTtcclxuLy8gY29uc3QgRXZlbnRPYmogPSByZXF1aXJlKFwiLi9jb3JlL2V2ZW50XCIpO1xyXG4vLyBjb25zdCBUcGxFbmcgPSByZXF1aXJlKFwiLi9jb3JlL3RlbXBsYXRlXCIpO1xyXG4vLyBjb25zdCBKc3ZtID0gcmVxdWlyZShcIi4vdXRpbC9Kc1ZtXCIpO1xyXG5cclxuLy8gUG9pLl9fVEVTVF9fID0ge1xyXG4vLyAgICAgZXY6ICgoKSA9PiB7XHJcbi8vICAgICAgICAgbGV0IGV2b2JqID0gbmV3IEV2ZW50T2JqKGRvY3VtZW50KTtcclxuLy8gICAgICAgICBldm9iai5vbihcIl9fVEVTVF9fXCIsICgpID0+IHtcclxuLy8gICAgICAgICAgICAgY29uc29sZS5sb2coXCJldmVudCBtYW5nZXIgaXMgd29ya2luZyFcIilcclxuLy8gICAgICAgICB9KVxyXG4vLyAgICAgICAgIHJldHVybiBldm9iajtcclxuLy8gICAgIH0pKCksXHJcbi8vICAgICB0cGw6IChfdCwgX2QpID0+IHtcclxuLy8gICAgICAgICByZXR1cm4gbmV3IFRwbEVuZyhfdCkuam9pbnQoX2QgfHwge30pO1xyXG4vLyAgICAgfSxcclxuLy8gICAgIHZtOiBKc3ZtXHJcbi8vIH07XHJcbmlmKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcpd2luZG93LlBvaSA9IFBvaVxyXG5cclxubGV0IHVzYWdlID0gKCkgPT4ge1xyXG4gICAgaWYgKGNvbnNvbGUpIHtcclxuICAgICAgICBsZXQgbXNnID0gYFxyXG4gICAgICAgIHRoeCBmb3IgdSB1c2luZyEhISFwb2l+XHJcblxyXG4gICAgICAgIG5vdyxwb2kgaXMgd29ya2luZyFoYXZlIGZ1bi5cclxuICAgICAgICBgO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XHJcbiAgICB9XHJcbn1cclxudXNhZ2UoKTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/util/JsVm.js":
/*!**************************!*\
  !*** ./src/util/JsVm.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("let extend = (o, n) => {\r\n    for (var p in n) {\r\n        if (n.hasOwnProperty(p) && (!o.hasOwnProperty(p)))\r\n            o[p] = n[p];\r\n    }\r\n};\r\nlet JSvm = (code, sandbox) => {\r\n    let rep_non_print = (text) => {\r\n        return text.replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\").replace(\"\\f\", \"\\\\f\").replace(\"\\v\", \"\\\\v\").replace(\"\\r\", \"\\\\r\")\r\n    }\r\n    sandbox = sandbox || {};\r\n    const fn = new Function('sandbox', `with(sandbox){${rep_non_print(code)}}`);\r\n    const _proxy = new Proxy(sandbox, {\r\n        has(target, key) {\r\n            return true;\r\n        }\r\n    });\r\n    return fn(_proxy);\r\n};\r\nlet multiCode2Tuple = (code) => {\r\n    return code.replace(/(^|;)return /g, \"\").replace(/([\"'])(.+?)(;)(.+?)\\1/g, \"$1$2$3#$4$1\").split(/;(?!#)/g).join(\",\").replace(\";#\", \";\");\r\n};\r\n\r\nclass VmError extends Error {\r\n    constructor(message) {\r\n        super();\r\n        Error.captureStackTrace(this, this.constructor);\r\n        this.message = message || 'Undefined error';\r\n        this.name = 'VmError';\r\n    }\r\n}\r\nlet JSafeVmWithBlackList = (code, sandbox, mixBlack) => {\r\n    let blacklist = [\"eval\", \"Function\"]\r\n    mixBlack = mixBlack ? mixBlack.push.apply(mixBlack, blacklist) : blacklist\r\n    let rep_non_print = (text) => {\r\n        return text.replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\").replace(\"\\f\", \"\\\\f\").replace(\"\\v\", \"\\\\v\").replace(\"\\r\", \"\\\\r\")\r\n    }\r\n    sandbox = sandbox || {};\r\n    const fn = new Function('sandbox', `with(sandbox){${rep_non_print(code)}}`);\r\n    const _proxy = new Proxy(sandbox, {\r\n        has(target, key) {\r\n            if(mixBlack.indexOf(key) != -1){\r\n                return true\r\n            }\r\n            return key in target;\r\n        }\r\n    });\r\n    return fn(_proxy);\r\n};\r\nlet micVm = (code, data) => {\r\n    let result;\r\n    // try {\r\n    result = new Function('obj', \"with(obj){\" + code + \"}\").apply(data, [data])\r\n    // } catch (err) {\r\n    //     console.error(\"'\" + err.message + \"'\", \" in \\n\\nCode:\\n\", code.replace(/;/g, \";\\n\").replace(/({|})/g, \"$1\\n\"));\r\n    // }\r\n    return result;\r\n}\r\n\r\nmodule.exports = {\r\n    safe: JSafeVmWithBlackList,\r\n    vm: JSvm,\r\n    micVm: micVm\r\n};\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbC9Kc1ZtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvSnNWbS5qcz84MmExIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBleHRlbmQgPSAobywgbikgPT4ge1xyXG4gICAgZm9yICh2YXIgcCBpbiBuKSB7XHJcbiAgICAgICAgaWYgKG4uaGFzT3duUHJvcGVydHkocCkgJiYgKCFvLmhhc093blByb3BlcnR5KHApKSlcclxuICAgICAgICAgICAgb1twXSA9IG5bcF07XHJcbiAgICB9XHJcbn07XHJcbmxldCBKU3ZtID0gKGNvZGUsIHNhbmRib3gpID0+IHtcclxuICAgIGxldCByZXBfbm9uX3ByaW50ID0gKHRleHQpID0+IHtcclxuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKFwiXFxuXCIsIFwiXFxcXG5cIikucmVwbGFjZShcIlxcdFwiLCBcIlxcXFx0XCIpLnJlcGxhY2UoXCJcXGZcIiwgXCJcXFxcZlwiKS5yZXBsYWNlKFwiXFx2XCIsIFwiXFxcXHZcIikucmVwbGFjZShcIlxcclwiLCBcIlxcXFxyXCIpXHJcbiAgICB9XHJcbiAgICBzYW5kYm94ID0gc2FuZGJveCB8fCB7fTtcclxuICAgIGNvbnN0IGZuID0gbmV3IEZ1bmN0aW9uKCdzYW5kYm94JywgYHdpdGgoc2FuZGJveCl7JHtyZXBfbm9uX3ByaW50KGNvZGUpfX1gKTtcclxuICAgIGNvbnN0IF9wcm94eSA9IG5ldyBQcm94eShzYW5kYm94LCB7XHJcbiAgICAgICAgaGFzKHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGZuKF9wcm94eSk7XHJcbn07XHJcbmxldCBtdWx0aUNvZGUyVHVwbGUgPSAoY29kZSkgPT4ge1xyXG4gICAgcmV0dXJuIGNvZGUucmVwbGFjZSgvKF58OylyZXR1cm4gL2csIFwiXCIpLnJlcGxhY2UoLyhbXCInXSkoLis/KSg7KSguKz8pXFwxL2csIFwiJDEkMiQzIyQ0JDFcIikuc3BsaXQoLzsoPyEjKS9nKS5qb2luKFwiLFwiKS5yZXBsYWNlKFwiOyNcIiwgXCI7XCIpO1xyXG59O1xyXG5cclxuY2xhc3MgVm1FcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1VuZGVmaW5lZCBlcnJvcic7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ1ZtRXJyb3InO1xyXG4gICAgfVxyXG59XHJcbmxldCBKU2FmZVZtV2l0aEJsYWNrTGlzdCA9IChjb2RlLCBzYW5kYm94LCBtaXhCbGFjaykgPT4ge1xyXG4gICAgbGV0IGJsYWNrbGlzdCA9IFtcImV2YWxcIiwgXCJGdW5jdGlvblwiXVxyXG4gICAgbWl4QmxhY2sgPSBtaXhCbGFjayA/IG1peEJsYWNrLnB1c2guYXBwbHkobWl4QmxhY2ssIGJsYWNrbGlzdCkgOiBibGFja2xpc3RcclxuICAgIGxldCByZXBfbm9uX3ByaW50ID0gKHRleHQpID0+IHtcclxuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKFwiXFxuXCIsIFwiXFxcXG5cIikucmVwbGFjZShcIlxcdFwiLCBcIlxcXFx0XCIpLnJlcGxhY2UoXCJcXGZcIiwgXCJcXFxcZlwiKS5yZXBsYWNlKFwiXFx2XCIsIFwiXFxcXHZcIikucmVwbGFjZShcIlxcclwiLCBcIlxcXFxyXCIpXHJcbiAgICB9XHJcbiAgICBzYW5kYm94ID0gc2FuZGJveCB8fCB7fTtcclxuICAgIGNvbnN0IGZuID0gbmV3IEZ1bmN0aW9uKCdzYW5kYm94JywgYHdpdGgoc2FuZGJveCl7JHtyZXBfbm9uX3ByaW50KGNvZGUpfX1gKTtcclxuICAgIGNvbnN0IF9wcm94eSA9IG5ldyBQcm94eShzYW5kYm94LCB7XHJcbiAgICAgICAgaGFzKHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgICAgIGlmKG1peEJsYWNrLmluZGV4T2Yoa2V5KSAhPSAtMSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBrZXkgaW4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGZuKF9wcm94eSk7XHJcbn07XHJcbmxldCBtaWNWbSA9IChjb2RlLCBkYXRhKSA9PiB7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgLy8gdHJ5IHtcclxuICAgIHJlc3VsdCA9IG5ldyBGdW5jdGlvbignb2JqJywgXCJ3aXRoKG9iail7XCIgKyBjb2RlICsgXCJ9XCIpLmFwcGx5KGRhdGEsIFtkYXRhXSlcclxuICAgIC8vIH0gY2F0Y2ggKGVycikge1xyXG4gICAgLy8gICAgIGNvbnNvbGUuZXJyb3IoXCInXCIgKyBlcnIubWVzc2FnZSArIFwiJ1wiLCBcIiBpbiBcXG5cXG5Db2RlOlxcblwiLCBjb2RlLnJlcGxhY2UoLzsvZywgXCI7XFxuXCIpLnJlcGxhY2UoLyh7fH0pL2csIFwiJDFcXG5cIikpO1xyXG4gICAgLy8gfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBzYWZlOiBKU2FmZVZtV2l0aEJsYWNrTGlzdCxcclxuICAgIHZtOiBKU3ZtLFxyXG4gICAgbWljVm06IG1pY1ZtXHJcbn07XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/util/JsVm.js\n");

/***/ }),

/***/ "./src/util/domApi.js":
/*!****************************!*\
  !*** ./src/util/domApi.js ***!
  \****************************/
/*! exports provided: domApi */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"domApi\", function() { return domApi; });\n\r\nconst arrDiffer = (a, b) => {\r\n    // if the other array is a falsy value, return\r\n    if (!a || !b)\r\n        return false\r\n    // compare lengths - can save a lot of time\r\n    if (a.length != b.length)\r\n        return false\r\n    let isIn = (arr1, arr2) => {\r\n        for (let i in arr1) {\r\n            let nullInOther = true\r\n            for (let j in arr2) {\r\n                if (arr1[i] == arr2[j]) {\r\n                    nullInOther = false\r\n                }\r\n            }\r\n            if (nullInOther) {\r\n                return false\r\n            }\r\n        }\r\n        return true\r\n    }\r\n    return isIn(a, b) && isIn(b, a)\r\n}\r\n\r\nconst domApi = {\r\n    $: _selector => {\r\n        let ele = document.querySelector(_selector)\r\n        ele.html = function(_newHtml) {\r\n            if (this.empty) {\r\n                return ''\r\n            }\r\n            if (_newHtml != undefined) {\r\n                this.innerHTML = _newHtml;\r\n                return _newHtml;\r\n            } else {\r\n                return this.innerHTML;\r\n            }\r\n        };\r\n        return ele\r\n    },\r\n    createDom: _html => {\r\n        let tempRoot = document.createElement(\"div\")\r\n        tempRoot.innerHTML = _html\r\n        return tempRoot.children[0]\r\n    },\r\n    createDomTree: _html => {\r\n        let tempRoot = document.createElement(\"div\")\r\n        tempRoot.innerHTML = _html\r\n        return tempRoot.childNodes\r\n    },\r\n    append: (newElement, targetElement) => {\r\n        newElement = typeof newElement == typeof \"\" ? domApi.createDom(newElement) : newElement\r\n        return targetElement.appendChild(newElement)\r\n    },\r\n    insertBefore: (newElement, targetElement) => {\r\n        let parent = targetElement.parentNode\r\n        newElement = typeof newElement == typeof \"\" ? domApi.createDom(newElement) : newElement\r\n        return parent.insertBefore(newElement, targetElement)\r\n    },\r\n    insertAfter: (newElement, targetElement) => {\r\n        var parent = targetElement.parentNode;\r\n        if (parent.lastChild == targetElement) {\r\n            parent.appendChild(newElement);\r\n        } else {\r\n            parent.insertBefore(newElement, targetElement.nextSibling)\r\n        }\r\n    },\r\n    remove: targetElement => {\r\n        if (targetElement == undefined) return\r\n        let parent = targetElement.parentNode\r\n        if (parent == undefined) {\r\n            targetElement = null\r\n            return\r\n        }\r\n        parent.removeChild(targetElement)\r\n    },\r\n    isSame: (ele1, ele2) => {\r\n        if (ele1 == undefined || ele2 == undefined) return false;\r\n        if (ele1.nodeType != ele2.nodeType) return false;\r\n        if (ele1.nodeType == 1) {\r\n            // node\r\n            return (\r\n                ele1.nodeName == ele2.nodeName &&\r\n                ele1.id == ele2.id &&\r\n                ele1.innerText.trim() == ele2.innerText.trim()\r\n                // && ele1.className == ele2.className\r\n            )\r\n        }\r\n        if (ele1.nodeType == 3) {\r\n            // text node\r\n            return (\r\n                // domApi.isSame(ele1.parentNode, ele2.parentNode) &&\r\n                ele1.textContent == ele2.textContent\r\n            )\r\n        }\r\n    },\r\n    classListDiff: (ele1, ele2) => {\r\n        if (ele1.classList.length != ele2.classList.length) {\r\n            return false\r\n        }\r\n        let cList2Arr = ele => {\r\n            let res = []\r\n            ele.classList.forEach(val => {\r\n                res.push(val)\r\n            })\r\n            return res\r\n        }\r\n        return arrDiffer(cList2Arr(ele1), cList2Arr(ele2))\r\n    },\r\n    attributesDiff: (ele1, ele2) => {\r\n        // *** bad idea! ***\r\n        // if(ele1.attributes.length!=ele2.attributes.length){\r\n        //     return false\r\n        // }\r\n        let attributes2Arr = ele => {\r\n            let res = []\r\n            let tempCur = 0\r\n            let blacks = [\"class\"]\r\n            while (true) {\r\n                let curNode = ele.attributes[tempCur]\r\n                if (curNode) {\r\n                    if (/(.+?):.+?/g.test(curNode.name)) {\r\n                        blacks.push(/(.+?):(.+)/g.exec(curNode.name)[2])\r\n                        tempCur += 1\r\n                        continue\r\n                    }\r\n                    if (blacks.indexOf(curNode.name) != -1) {\r\n                        tempCur += 1\r\n                        continue\r\n                    }\r\n                    res.push(curNode.nodeValue)\r\n                } else {\r\n                    break\r\n                }\r\n                tempCur += 1\r\n            }\r\n            return res\r\n        }\r\n        return arrDiffer(attributes2Arr(ele1), attributes2Arr(ele2))\r\n    },\r\n    // #901\r\n    // Failed to execute 'setNamedItem' on 'NamedNodeMap':\r\n    // The node provided is an attribute node that is alre-\r\n    // ady an attribute of another Element; attribute node-\r\n    // s must be explicitly cloned.\r\n    //\r\n    attributesClone: (ele, to) => {\r\n        for (let attr of ele.attributes) {\r\n            ele.attributes.removeNamedItem(attr.name)\r\n        }\r\n        for (let attr of to.attributes) {\r\n            ele.attributes.setNamedItem(attr.cloneNode(true))\r\n        }\r\n    },\r\n    Comparable: (ele1, ele2) => {\r\n        if (ele1 == undefined || ele2 == undefined) return false;\r\n        if (ele1.nodeType != ele2.nodeType) return false;\r\n        if (ele1.nodeType == 3) return true;\r\n        return (\r\n            ele1.nodeName == ele2.nodeName &&\r\n            ele1.id == ele2.id &&\r\n            ele1.className == ele2.className\r\n        )\r\n    }\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbC9kb21BcGkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9kb21BcGkuanM/Mjc2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuY29uc3QgYXJyRGlmZmVyID0gKGEsIGIpID0+IHtcclxuICAgIC8vIGlmIHRoZSBvdGhlciBhcnJheSBpcyBhIGZhbHN5IHZhbHVlLCByZXR1cm5cclxuICAgIGlmICghYSB8fCAhYilcclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgIC8vIGNvbXBhcmUgbGVuZ3RocyAtIGNhbiBzYXZlIGEgbG90IG9mIHRpbWVcclxuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgIGxldCBpc0luID0gKGFycjEsIGFycjIpID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpIGluIGFycjEpIHtcclxuICAgICAgICAgICAgbGV0IG51bGxJbk90aGVyID0gdHJ1ZVxyXG4gICAgICAgICAgICBmb3IgKGxldCBqIGluIGFycjIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhcnIxW2ldID09IGFycjJbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICBudWxsSW5PdGhlciA9IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG51bGxJbk90aGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzSW4oYSwgYikgJiYgaXNJbihiLCBhKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZG9tQXBpID0ge1xyXG4gICAgJDogX3NlbGVjdG9yID0+IHtcclxuICAgICAgICBsZXQgZWxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihfc2VsZWN0b3IpXHJcbiAgICAgICAgZWxlLmh0bWwgPSBmdW5jdGlvbihfbmV3SHRtbCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5lbXB0eSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKF9uZXdIdG1sICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lckhUTUwgPSBfbmV3SHRtbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfbmV3SHRtbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlubmVySFRNTDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGVsZVxyXG4gICAgfSxcclxuICAgIGNyZWF0ZURvbTogX2h0bWwgPT4ge1xyXG4gICAgICAgIGxldCB0ZW1wUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcclxuICAgICAgICB0ZW1wUm9vdC5pbm5lckhUTUwgPSBfaHRtbFxyXG4gICAgICAgIHJldHVybiB0ZW1wUm9vdC5jaGlsZHJlblswXVxyXG4gICAgfSxcclxuICAgIGNyZWF0ZURvbVRyZWU6IF9odG1sID0+IHtcclxuICAgICAgICBsZXQgdGVtcFJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXHJcbiAgICAgICAgdGVtcFJvb3QuaW5uZXJIVE1MID0gX2h0bWxcclxuICAgICAgICByZXR1cm4gdGVtcFJvb3QuY2hpbGROb2Rlc1xyXG4gICAgfSxcclxuICAgIGFwcGVuZDogKG5ld0VsZW1lbnQsIHRhcmdldEVsZW1lbnQpID0+IHtcclxuICAgICAgICBuZXdFbGVtZW50ID0gdHlwZW9mIG5ld0VsZW1lbnQgPT0gdHlwZW9mIFwiXCIgPyBkb21BcGkuY3JlYXRlRG9tKG5ld0VsZW1lbnQpIDogbmV3RWxlbWVudFxyXG4gICAgICAgIHJldHVybiB0YXJnZXRFbGVtZW50LmFwcGVuZENoaWxkKG5ld0VsZW1lbnQpXHJcbiAgICB9LFxyXG4gICAgaW5zZXJ0QmVmb3JlOiAobmV3RWxlbWVudCwgdGFyZ2V0RWxlbWVudCkgPT4ge1xyXG4gICAgICAgIGxldCBwYXJlbnQgPSB0YXJnZXRFbGVtZW50LnBhcmVudE5vZGVcclxuICAgICAgICBuZXdFbGVtZW50ID0gdHlwZW9mIG5ld0VsZW1lbnQgPT0gdHlwZW9mIFwiXCIgPyBkb21BcGkuY3JlYXRlRG9tKG5ld0VsZW1lbnQpIDogbmV3RWxlbWVudFxyXG4gICAgICAgIHJldHVybiBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5ld0VsZW1lbnQsIHRhcmdldEVsZW1lbnQpXHJcbiAgICB9LFxyXG4gICAgaW5zZXJ0QWZ0ZXI6IChuZXdFbGVtZW50LCB0YXJnZXRFbGVtZW50KSA9PiB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRhcmdldEVsZW1lbnQucGFyZW50Tm9kZTtcclxuICAgICAgICBpZiAocGFyZW50Lmxhc3RDaGlsZCA9PSB0YXJnZXRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChuZXdFbGVtZW50KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5ld0VsZW1lbnQsIHRhcmdldEVsZW1lbnQubmV4dFNpYmxpbmcpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlbW92ZTogdGFyZ2V0RWxlbWVudCA9PiB7XHJcbiAgICAgICAgaWYgKHRhcmdldEVsZW1lbnQgPT0gdW5kZWZpbmVkKSByZXR1cm5cclxuICAgICAgICBsZXQgcGFyZW50ID0gdGFyZ2V0RWxlbWVudC5wYXJlbnROb2RlXHJcbiAgICAgICAgaWYgKHBhcmVudCA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudCA9IG51bGxcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0YXJnZXRFbGVtZW50KVxyXG4gICAgfSxcclxuICAgIGlzU2FtZTogKGVsZTEsIGVsZTIpID0+IHtcclxuICAgICAgICBpZiAoZWxlMSA9PSB1bmRlZmluZWQgfHwgZWxlMiA9PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoZWxlMS5ub2RlVHlwZSAhPSBlbGUyLm5vZGVUeXBlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKGVsZTEubm9kZVR5cGUgPT0gMSkge1xyXG4gICAgICAgICAgICAvLyBub2RlXHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICBlbGUxLm5vZGVOYW1lID09IGVsZTIubm9kZU5hbWUgJiZcclxuICAgICAgICAgICAgICAgIGVsZTEuaWQgPT0gZWxlMi5pZCAmJlxyXG4gICAgICAgICAgICAgICAgZWxlMS5pbm5lclRleHQudHJpbSgpID09IGVsZTIuaW5uZXJUZXh0LnRyaW0oKVxyXG4gICAgICAgICAgICAgICAgLy8gJiYgZWxlMS5jbGFzc05hbWUgPT0gZWxlMi5jbGFzc05hbWVcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWxlMS5ub2RlVHlwZSA9PSAzKSB7XHJcbiAgICAgICAgICAgIC8vIHRleHQgbm9kZVxyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgLy8gZG9tQXBpLmlzU2FtZShlbGUxLnBhcmVudE5vZGUsIGVsZTIucGFyZW50Tm9kZSkgJiZcclxuICAgICAgICAgICAgICAgIGVsZTEudGV4dENvbnRlbnQgPT0gZWxlMi50ZXh0Q29udGVudFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNsYXNzTGlzdERpZmY6IChlbGUxLCBlbGUyKSA9PiB7XHJcbiAgICAgICAgaWYgKGVsZTEuY2xhc3NMaXN0Lmxlbmd0aCAhPSBlbGUyLmNsYXNzTGlzdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjTGlzdDJBcnIgPSBlbGUgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcmVzID0gW11cclxuICAgICAgICAgICAgZWxlLmNsYXNzTGlzdC5mb3JFYWNoKHZhbCA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXMucHVzaCh2YWwpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIHJldHVybiByZXNcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFyckRpZmZlcihjTGlzdDJBcnIoZWxlMSksIGNMaXN0MkFycihlbGUyKSlcclxuICAgIH0sXHJcbiAgICBhdHRyaWJ1dGVzRGlmZjogKGVsZTEsIGVsZTIpID0+IHtcclxuICAgICAgICAvLyAqKiogYmFkIGlkZWEhICoqKlxyXG4gICAgICAgIC8vIGlmKGVsZTEuYXR0cmlidXRlcy5sZW5ndGghPWVsZTIuYXR0cmlidXRlcy5sZW5ndGgpe1xyXG4gICAgICAgIC8vICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgbGV0IGF0dHJpYnV0ZXMyQXJyID0gZWxlID0+IHtcclxuICAgICAgICAgICAgbGV0IHJlcyA9IFtdXHJcbiAgICAgICAgICAgIGxldCB0ZW1wQ3VyID0gMFxyXG4gICAgICAgICAgICBsZXQgYmxhY2tzID0gW1wiY2xhc3NcIl1cclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjdXJOb2RlID0gZWxlLmF0dHJpYnV0ZXNbdGVtcEN1cl1cclxuICAgICAgICAgICAgICAgIGlmIChjdXJOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKC8oLis/KTouKz8vZy50ZXN0KGN1ck5vZGUubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmxhY2tzLnB1c2goLyguKz8pOiguKykvZy5leGVjKGN1ck5vZGUubmFtZSlbMl0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBDdXIgKz0gMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmxhY2tzLmluZGV4T2YoY3VyTm9kZS5uYW1lKSAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wQ3VyICs9IDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goY3VyTm9kZS5ub2RlVmFsdWUpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0ZW1wQ3VyICs9IDFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnJEaWZmZXIoYXR0cmlidXRlczJBcnIoZWxlMSksIGF0dHJpYnV0ZXMyQXJyKGVsZTIpKVxyXG4gICAgfSxcclxuICAgIC8vICM5MDFcclxuICAgIC8vIEZhaWxlZCB0byBleGVjdXRlICdzZXROYW1lZEl0ZW0nIG9uICdOYW1lZE5vZGVNYXAnOlxyXG4gICAgLy8gVGhlIG5vZGUgcHJvdmlkZWQgaXMgYW4gYXR0cmlidXRlIG5vZGUgdGhhdCBpcyBhbHJlLVxyXG4gICAgLy8gYWR5IGFuIGF0dHJpYnV0ZSBvZiBhbm90aGVyIEVsZW1lbnQ7IGF0dHJpYnV0ZSBub2RlLVxyXG4gICAgLy8gcyBtdXN0IGJlIGV4cGxpY2l0bHkgY2xvbmVkLlxyXG4gICAgLy9cclxuICAgIGF0dHJpYnV0ZXNDbG9uZTogKGVsZSwgdG8pID0+IHtcclxuICAgICAgICBmb3IgKGxldCBhdHRyIG9mIGVsZS5hdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgIGVsZS5hdHRyaWJ1dGVzLnJlbW92ZU5hbWVkSXRlbShhdHRyLm5hbWUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGF0dHIgb2YgdG8uYXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICBlbGUuYXR0cmlidXRlcy5zZXROYW1lZEl0ZW0oYXR0ci5jbG9uZU5vZGUodHJ1ZSkpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIENvbXBhcmFibGU6IChlbGUxLCBlbGUyKSA9PiB7XHJcbiAgICAgICAgaWYgKGVsZTEgPT0gdW5kZWZpbmVkIHx8IGVsZTIgPT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKGVsZTEubm9kZVR5cGUgIT0gZWxlMi5ub2RlVHlwZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChlbGUxLm5vZGVUeXBlID09IDMpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIGVsZTEubm9kZU5hbWUgPT0gZWxlMi5ub2RlTmFtZSAmJlxyXG4gICAgICAgICAgICBlbGUxLmlkID09IGVsZTIuaWQgJiZcclxuICAgICAgICAgICAgZWxlMS5jbGFzc05hbWUgPT0gZWxlMi5jbGFzc05hbWVcclxuICAgICAgICApXHJcbiAgICB9XHJcbn1cclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/util/domApi.js\n");

/***/ }),

/***/ "./src/util/frameify.js":
/*!******************************!*\
  !*** ./src/util/frameify.js ***!
  \******************************/
/*! exports provided: frameify */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frameify\", function() { return frameify; });\n// 很奇怪的做法，主要是为了实现time slice，\r\n// 将主体为生成器的task化为promise，\r\n// 从而支持await和async\r\n\r\nvar reqIdleFrame = ((window) => {\r\n    return window.requestIdleCallback || function(cb) {\r\n        var start = Date.now();\r\n        return setTimeout(function() {\r\n            cb({\r\n                didTimeout: false,\r\n                timeRemaining: function() {\r\n                    return Math.max(0, 50 - (Date.now() - start));\r\n                },\r\n            });\r\n        }, 1);\r\n    };\r\n})(window);\r\n\r\nfunction frameify(gen) {\r\n    return new Promise((resolve, reject) => {\r\n        function inner() {\r\n            reqIdleFrame((deadline) => {\r\n                while (deadline.timeRemaining() > 0) {\r\n                    var n = gen.next();\r\n                    if (n.done) {\r\n                        resolve(n.value);\r\n                        return void 0;\r\n                    }\r\n                }\r\n                inner();\r\n            })\r\n        }\r\n        try {\r\n            inner()\r\n        } catch (e) {\r\n            reject(e)\r\n        }\r\n    })\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbC9mcmFtZWlmeS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy91dGlsL2ZyYW1laWZ5LmpzPzllMDQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8g5b6I5aWH5oCq55qE5YGa5rOV77yM5Li76KaB5piv5Li65LqG5a6e546wdGltZSBzbGljZe+8jFxyXG4vLyDlsIbkuLvkvZPkuLrnlJ/miJDlmajnmoR0YXNr5YyW5Li6cHJvbWlzZe+8jFxyXG4vLyDku47ogIzmlK/mjIFhd2FpdOWSjGFzeW5jXHJcblxyXG52YXIgcmVxSWRsZUZyYW1lID0gKCh3aW5kb3cpID0+IHtcclxuICAgIHJldHVybiB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayB8fCBmdW5jdGlvbihjYikge1xyXG4gICAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGNiKHtcclxuICAgICAgICAgICAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIDUwIC0gKERhdGUubm93KCkgLSBzdGFydCkpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgMSk7XHJcbiAgICB9O1xyXG59KSh3aW5kb3cpO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZyYW1laWZ5KGdlbikge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBmdW5jdGlvbiBpbm5lcigpIHtcclxuICAgICAgICAgICAgcmVxSWRsZUZyYW1lKChkZWFkbGluZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGRlYWRsaW5lLnRpbWVSZW1haW5pbmcoKSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGdlbi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4uZG9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG4udmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlubmVyKCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlubmVyKClcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJlamVjdChlKVxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbn1cclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/util/frameify.js\n");

/***/ }),

/***/ "./src/util/util.js":
/*!**************************!*\
  !*** ./src/util/util.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function getType(obj) {\r\n    //tostring会返回对应不同的标签的构造函数\r\n    var toString = Object.prototype.toString;\r\n    var map = {\r\n        '[object Boolean]': 'boolean',\r\n        '[object Number]': 'number',\r\n        '[object String]': 'string',\r\n        '[object Function]': 'function',\r\n        '[object Array]': 'array',\r\n        '[object Date]': 'date',\r\n        '[object RegExp]': 'regExp',\r\n        '[object Undefined]': 'undefined',\r\n        '[object Null]': 'null',\r\n        '[object Object]': 'object'\r\n    };\r\n    if (obj instanceof Element) {\r\n        return 'element';\r\n    }\r\n    return map[toString.call(obj)];\r\n}\r\n\r\nfunction deepClone(data) {\r\n    var type = getType(data);\r\n    var obj;\r\n    if (type === 'array') {\r\n        obj = [];\r\n    } else if (type === 'object') {\r\n        obj = {};\r\n    } else {\r\n        //不再具有下一层次\r\n        return data;\r\n    }\r\n    if (type === 'array') {\r\n        for (var i = 0, len = data.length; i < len; i++) {\r\n            obj.push(deepClone(data[i]));\r\n        }\r\n    } else if (type === 'object') {\r\n        for (var key in data) {\r\n            obj[key] = deepClone(data[key]);\r\n        }\r\n    }\r\n    return obj;\r\n}\r\n\r\nlet extend = (o, n) => {\r\n    for (var p in n) {\r\n        if (n.hasOwnProperty(p) && (!o.hasOwnProperty(p)))\r\n            o[p] = n[p];\r\n    }\r\n};\r\n\r\nlet arrMerge = (a, b) => {\r\n    a.push.apply(a, b);\r\n};\r\n\r\nlet support_list = [\"resize\", \"load\", \"click\", \"dblclick\", \"change\", \"blur\", \"focus\", \"keydown\", \"keyup\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"select\", \"keypress\"];\r\n\r\nlet GetAttrElement = (attr, val) => {\r\n    let e = document.all;\r\n    let a = new Array();\r\n    for (let i = 0; i < e.length; i++) {\r\n        if (e[i].getAttribute(attr) == val) {\r\n            a.push(e[i])\r\n        }\r\n    }\r\n    return a;\r\n}\r\n\r\nfunction proxy_arr_len(arr, cb) {\r\n    return new Proxy(arr, {\r\n        set(obj, prop, val) {\r\n            obj[prop] = val\r\n            if (prop == 'length') cb(obj);\r\n            return true;\r\n        }\r\n    })\r\n}\r\n\r\nfunction proxy_catch_set(that, cb){\r\n    if(Object.prototype.toString.call(that) == \"[object Array]\"){\r\n        return proxy_arr(that, cb);\r\n    }\r\n    return new Proxy(that, {\r\n        set(obj, prop, val) {\r\n            if(obj[prop] != val){\r\n                obj[prop] = val;\r\n                cb();\r\n            }\r\n            return true;\r\n        }\r\n    })\r\n}\r\n\r\nfunction proxy_arr(arr, cb) {\r\n    if(arr.length!=0){\r\n        for (var i = 0; i < arr.length; i++) {\r\n            arr[i] = proxy_catch_set(arr[i],()=>cb(arr));\r\n        }\r\n    }\r\n    return new Proxy(arr, {\r\n        set(obj, prop, val) {\r\n            obj[prop] = val\r\n            if (prop == 'length') cb(obj);\r\n            return true;\r\n        }\r\n    })\r\n}\r\n\r\n\r\nmodule.exports = {\r\n    deepClone: deepClone,\r\n    extend: extend,\r\n    arrMerge: arrMerge,\r\n    ev_supList: support_list,\r\n    GetAttrElement: GetAttrElement,\r\n    proxyArr: proxy_arr_len\r\n};\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbC91dGlsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvdXRpbC5qcz8wZTBiIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGdldFR5cGUob2JqKSB7XHJcbiAgICAvL3Rvc3RyaW5n5Lya6L+U5Zue5a+55bqU5LiN5ZCM55qE5qCH562+55qE5p6E6YCg5Ye95pWwXHJcbiAgICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG4gICAgdmFyIG1hcCA9IHtcclxuICAgICAgICAnW29iamVjdCBCb29sZWFuXSc6ICdib29sZWFuJyxcclxuICAgICAgICAnW29iamVjdCBOdW1iZXJdJzogJ251bWJlcicsXHJcbiAgICAgICAgJ1tvYmplY3QgU3RyaW5nXSc6ICdzdHJpbmcnLFxyXG4gICAgICAgICdbb2JqZWN0IEZ1bmN0aW9uXSc6ICdmdW5jdGlvbicsXHJcbiAgICAgICAgJ1tvYmplY3QgQXJyYXldJzogJ2FycmF5JyxcclxuICAgICAgICAnW29iamVjdCBEYXRlXSc6ICdkYXRlJyxcclxuICAgICAgICAnW29iamVjdCBSZWdFeHBdJzogJ3JlZ0V4cCcsXHJcbiAgICAgICAgJ1tvYmplY3QgVW5kZWZpbmVkXSc6ICd1bmRlZmluZWQnLFxyXG4gICAgICAgICdbb2JqZWN0IE51bGxdJzogJ251bGwnLFxyXG4gICAgICAgICdbb2JqZWN0IE9iamVjdF0nOiAnb2JqZWN0J1xyXG4gICAgfTtcclxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuICdlbGVtZW50JztcclxuICAgIH1cclxuICAgIHJldHVybiBtYXBbdG9TdHJpbmcuY2FsbChvYmopXTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVlcENsb25lKGRhdGEpIHtcclxuICAgIHZhciB0eXBlID0gZ2V0VHlwZShkYXRhKTtcclxuICAgIHZhciBvYmo7XHJcbiAgICBpZiAodHlwZSA9PT0gJ2FycmF5Jykge1xyXG4gICAgICAgIG9iaiA9IFtdO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIG9iaiA9IHt9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvL+S4jeWGjeWFt+acieS4i+S4gOWxguasoVxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGUgPT09ICdhcnJheScpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBvYmoucHVzaChkZWVwQ2xvbmUoZGF0YVtpXSkpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xyXG4gICAgICAgICAgICBvYmpba2V5XSA9IGRlZXBDbG9uZShkYXRhW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbmxldCBleHRlbmQgPSAobywgbikgPT4ge1xyXG4gICAgZm9yICh2YXIgcCBpbiBuKSB7XHJcbiAgICAgICAgaWYgKG4uaGFzT3duUHJvcGVydHkocCkgJiYgKCFvLmhhc093blByb3BlcnR5KHApKSlcclxuICAgICAgICAgICAgb1twXSA9IG5bcF07XHJcbiAgICB9XHJcbn07XHJcblxyXG5sZXQgYXJyTWVyZ2UgPSAoYSwgYikgPT4ge1xyXG4gICAgYS5wdXNoLmFwcGx5KGEsIGIpO1xyXG59O1xyXG5cclxubGV0IHN1cHBvcnRfbGlzdCA9IFtcInJlc2l6ZVwiLCBcImxvYWRcIiwgXCJjbGlja1wiLCBcImRibGNsaWNrXCIsIFwiY2hhbmdlXCIsIFwiYmx1clwiLCBcImZvY3VzXCIsIFwia2V5ZG93blwiLCBcImtleXVwXCIsIFwibW91c2Vkb3duXCIsIFwibW91c2Vtb3ZlXCIsIFwibW91c2VvdXRcIiwgXCJtb3VzZW92ZXJcIiwgXCJtb3VzZXVwXCIsIFwic2VsZWN0XCIsIFwia2V5cHJlc3NcIl07XHJcblxyXG5sZXQgR2V0QXR0ckVsZW1lbnQgPSAoYXR0ciwgdmFsKSA9PiB7XHJcbiAgICBsZXQgZSA9IGRvY3VtZW50LmFsbDtcclxuICAgIGxldCBhID0gbmV3IEFycmF5KCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoZVtpXS5nZXRBdHRyaWJ1dGUoYXR0cikgPT0gdmFsKSB7XHJcbiAgICAgICAgICAgIGEucHVzaChlW2ldKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBhO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcm94eV9hcnJfbGVuKGFyciwgY2IpIHtcclxuICAgIHJldHVybiBuZXcgUHJveHkoYXJyLCB7XHJcbiAgICAgICAgc2V0KG9iaiwgcHJvcCwgdmFsKSB7XHJcbiAgICAgICAgICAgIG9ialtwcm9wXSA9IHZhbFxyXG4gICAgICAgICAgICBpZiAocHJvcCA9PSAnbGVuZ3RoJykgY2Iob2JqKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxufVxyXG5cclxuZnVuY3Rpb24gcHJveHlfY2F0Y2hfc2V0KHRoYXQsIGNiKXtcclxuICAgIGlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGF0KSA9PSBcIltvYmplY3QgQXJyYXldXCIpe1xyXG4gICAgICAgIHJldHVybiBwcm94eV9hcnIodGhhdCwgY2IpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBQcm94eSh0aGF0LCB7XHJcbiAgICAgICAgc2V0KG9iaiwgcHJvcCwgdmFsKSB7XHJcbiAgICAgICAgICAgIGlmKG9ialtwcm9wXSAhPSB2YWwpe1xyXG4gICAgICAgICAgICAgICAgb2JqW3Byb3BdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgY2IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG59XHJcblxyXG5mdW5jdGlvbiBwcm94eV9hcnIoYXJyLCBjYikge1xyXG4gICAgaWYoYXJyLmxlbmd0aCE9MCl7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYXJyW2ldID0gcHJveHlfY2F0Y2hfc2V0KGFycltpXSwoKT0+Y2IoYXJyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBQcm94eShhcnIsIHtcclxuICAgICAgICBzZXQob2JqLCBwcm9wLCB2YWwpIHtcclxuICAgICAgICAgICAgb2JqW3Byb3BdID0gdmFsXHJcbiAgICAgICAgICAgIGlmIChwcm9wID09ICdsZW5ndGgnKSBjYihvYmopO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBkZWVwQ2xvbmU6IGRlZXBDbG9uZSxcclxuICAgIGV4dGVuZDogZXh0ZW5kLFxyXG4gICAgYXJyTWVyZ2U6IGFyck1lcmdlLFxyXG4gICAgZXZfc3VwTGlzdDogc3VwcG9ydF9saXN0LFxyXG4gICAgR2V0QXR0ckVsZW1lbnQ6IEdldEF0dHJFbGVtZW50LFxyXG4gICAgcHJveHlBcnI6IHByb3h5X2Fycl9sZW5cclxufTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/util/util.js\n");

/***/ })

/******/ });
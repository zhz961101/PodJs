/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/regenerator-runtime/runtime-module.js":
/*!************************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime-module.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzP2JiZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime-module.js\n");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcz85NmNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXG4gIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKClcbik7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n");

/***/ }),

/***/ "./src/Poi.js":
/*!********************!*\
  !*** ./src/Poi.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Poi = __webpack_require__(/*! ./core/Poi */ \"./src/core/Poi.js\")\r\nconst {\r\n    $,\r\n    HTMLClean\r\n} = __webpack_require__(/*! ./core/util/util */ \"./src/core/util/util.js\")\r\nconst {\r\n    Jx\r\n} = __webpack_require__(/*! ./core/jx */ \"./src/core/jx.js\")\r\nconst {\r\n    creatCustomEle,\r\n    tplLoader\r\n} = __webpack_require__(/*! ./component/component */ \"./src/component/component.js\")\r\nconst {\r\n    FSM\r\n} = __webpack_require__(/*! ./stateMachine/fsm */ \"./src/stateMachine/fsm.js\")\r\n\r\n\r\nconst GlobalJxEnviron = new Jx()\r\n\r\nfunction configWapper(config) {\r\n    // ele option\r\n    if (!(config.el instanceof Element)) {\r\n        let s = config.el[0];\r\n        if (s == \"#\") config.el = $(config.el)\r\n        else config.el = $(\"#\" + config.el)\r\n    }\r\n    // tpl option\r\n    if (config.tpl) {\r\n        let s = config.tpl[0];\r\n        if (s == \"#\") {\r\n            // tpl selector\r\n            config.tpl = HTMLClean($(config.tpl).innerHTML);\r\n        }\r\n    } else {\r\n        config.tpl = HTMLClean(config.el.innerHTML)\r\n    }\r\n\r\n    // other ...\r\n    return config\r\n}\r\n\r\nfunction PoiApi(config) {\r\n    config = configWapper(config)\r\n    let that = Object.create(null);\r\n    that = Poi.call(that, config, GlobalJxEnviron);\r\n\r\n    if(config.states && config.initState){\r\n        that.$M = new FSM(config, that.$data)\r\n    }\r\n\r\n    return that;\r\n}\r\n\r\nPoiApi.mod = (...args) => GlobalJxEnviron.mod.apply(GlobalJxEnviron, args)\r\nPoiApi.ele = function cusEle(name, option) {\r\n    let innerOp = option\r\n    let html = `<style>${option.css || \"\"}</style>` + (option.tpl || \"\")\r\n    delete innerOp.tpl\r\n    delete innerOp.extern\r\n    delete innerOp.css\r\n    try {\r\n        creatCustomEle(name, html, option, option.extern)\r\n    } catch (err) {\r\n        console.warn(err.message)\r\n    }\r\n}\r\nPoiApi.loadEle = tplLoader\r\n\r\nmodule.exports = PoiApi\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvUG9pLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL1BvaS5qcz9iYWUxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFBvaSA9IHJlcXVpcmUoXCIuL2NvcmUvUG9pXCIpXHJcbmNvbnN0IHtcclxuICAgICQsXHJcbiAgICBIVE1MQ2xlYW5cclxufSA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbC91dGlsXCIpXHJcbmNvbnN0IHtcclxuICAgIEp4XHJcbn0gPSByZXF1aXJlKFwiLi9jb3JlL2p4XCIpXHJcbmNvbnN0IHtcclxuICAgIGNyZWF0Q3VzdG9tRWxlLFxyXG4gICAgdHBsTG9hZGVyXHJcbn0gPSByZXF1aXJlKFwiLi9jb21wb25lbnQvY29tcG9uZW50XCIpXHJcbmNvbnN0IHtcclxuICAgIEZTTVxyXG59ID0gcmVxdWlyZShcIi4vc3RhdGVNYWNoaW5lL2ZzbVwiKVxyXG5cclxuXHJcbmNvbnN0IEdsb2JhbEp4RW52aXJvbiA9IG5ldyBKeCgpXHJcblxyXG5mdW5jdGlvbiBjb25maWdXYXBwZXIoY29uZmlnKSB7XHJcbiAgICAvLyBlbGUgb3B0aW9uXHJcbiAgICBpZiAoIShjb25maWcuZWwgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xyXG4gICAgICAgIGxldCBzID0gY29uZmlnLmVsWzBdO1xyXG4gICAgICAgIGlmIChzID09IFwiI1wiKSBjb25maWcuZWwgPSAkKGNvbmZpZy5lbClcclxuICAgICAgICBlbHNlIGNvbmZpZy5lbCA9ICQoXCIjXCIgKyBjb25maWcuZWwpXHJcbiAgICB9XHJcbiAgICAvLyB0cGwgb3B0aW9uXHJcbiAgICBpZiAoY29uZmlnLnRwbCkge1xyXG4gICAgICAgIGxldCBzID0gY29uZmlnLnRwbFswXTtcclxuICAgICAgICBpZiAocyA9PSBcIiNcIikge1xyXG4gICAgICAgICAgICAvLyB0cGwgc2VsZWN0b3JcclxuICAgICAgICAgICAgY29uZmlnLnRwbCA9IEhUTUxDbGVhbigkKGNvbmZpZy50cGwpLmlubmVySFRNTCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25maWcudHBsID0gSFRNTENsZWFuKGNvbmZpZy5lbC5pbm5lckhUTUwpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gb3RoZXIgLi4uXHJcbiAgICByZXR1cm4gY29uZmlnXHJcbn1cclxuXHJcbmZ1bmN0aW9uIFBvaUFwaShjb25maWcpIHtcclxuICAgIGNvbmZpZyA9IGNvbmZpZ1dhcHBlcihjb25maWcpXHJcbiAgICBsZXQgdGhhdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICB0aGF0ID0gUG9pLmNhbGwodGhhdCwgY29uZmlnLCBHbG9iYWxKeEVudmlyb24pO1xyXG5cclxuICAgIGlmKGNvbmZpZy5zdGF0ZXMgJiYgY29uZmlnLmluaXRTdGF0ZSl7XHJcbiAgICAgICAgdGhhdC4kTSA9IG5ldyBGU00oY29uZmlnLCB0aGF0LiRkYXRhKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGF0O1xyXG59XHJcblxyXG5Qb2lBcGkubW9kID0gKC4uLmFyZ3MpID0+IEdsb2JhbEp4RW52aXJvbi5tb2QuYXBwbHkoR2xvYmFsSnhFbnZpcm9uLCBhcmdzKVxyXG5Qb2lBcGkuZWxlID0gZnVuY3Rpb24gY3VzRWxlKG5hbWUsIG9wdGlvbikge1xyXG4gICAgbGV0IGlubmVyT3AgPSBvcHRpb25cclxuICAgIGxldCBodG1sID0gYDxzdHlsZT4ke29wdGlvbi5jc3MgfHwgXCJcIn08L3N0eWxlPmAgKyAob3B0aW9uLnRwbCB8fCBcIlwiKVxyXG4gICAgZGVsZXRlIGlubmVyT3AudHBsXHJcbiAgICBkZWxldGUgaW5uZXJPcC5leHRlcm5cclxuICAgIGRlbGV0ZSBpbm5lck9wLmNzc1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjcmVhdEN1c3RvbUVsZShuYW1lLCBodG1sLCBvcHRpb24sIG9wdGlvbi5leHRlcm4pXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oZXJyLm1lc3NhZ2UpXHJcbiAgICB9XHJcbn1cclxuUG9pQXBpLmxvYWRFbGUgPSB0cGxMb2FkZXJcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9pQXBpIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Poi.js\n");

/***/ }),

/***/ "./src/component/component.js":
/*!************************************!*\
  !*** ./src/component/component.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\r\n    creatCustomEle,\r\n    tplLoader\r\n}\r\n\r\nfunction callable(o) {\r\n    if (!o) return false\r\n    return typeof o == \"function\"\r\n}\r\n\r\n/**\r\n * creat custom element\r\n * @param {String} tagName customEle tagname\r\n * @param {String} shadowHtml shadow inner html, include style and other\r\n * @param {Object} option Ele option{init,get xx,set xx...}\r\n * @param {Class} base defautl is HTMLElement\r\n */\r\nfunction creatCustomEle(tagName, shadowHtml = \"\", option, onShadow = true, base = HTMLElement) {\r\n    function thatEle(...args) {\r\n        return Reflect.construct(base, [], this.constructor);\r\n    }\r\n    thatEle.prototype = Object.create(base.prototype);\r\n    thatEle.prototype.constructor = thatEle;\r\n    Object.setPrototypeOf(thatEle, base);\r\n    thatEle.prototype.connectedCallback = function () {\r\n        if (onShadow) {\r\n            this.shadowRoot = this.attachShadow({\r\n                mode: 'open' // self-closing is hard to control\r\n            });\r\n            this.shadowRoot.innerHTML = shadowHtml\r\n        }\r\n        if (callable(option.init)) {\r\n            option.init.call(this)\r\n        }\r\n    }\r\n    thatEle.prototype = Object.assign(thatEle.prototype, option)\r\n    // registered\r\n    window.customElements.define(tagName, thatEle)\r\n}\r\n\r\nfunction tplLoader(text) {\r\n    let re = /<script[\\s\\S]*?>([\\s\\S]*?)<\\/script>/i,\r\n        script = text.match(re)[1],\r\n        html = text.replace(re, \"\"),\r\n        options = eval(`(function(){let options;${script}\\nreturn options})()`)\r\n    creatCustomEle(options.name, html, options)\r\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50L2NvbXBvbmVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb21wb25lbnQvY29tcG9uZW50LmpzPzc1ZTMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBjcmVhdEN1c3RvbUVsZSxcclxuICAgIHRwbExvYWRlclxyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxsYWJsZShvKSB7XHJcbiAgICBpZiAoIW8pIHJldHVybiBmYWxzZVxyXG4gICAgcmV0dXJuIHR5cGVvZiBvID09IFwiZnVuY3Rpb25cIlxyXG59XHJcblxyXG4vKipcclxuICogY3JlYXQgY3VzdG9tIGVsZW1lbnRcclxuICogQHBhcmFtIHtTdHJpbmd9IHRhZ05hbWUgY3VzdG9tRWxlIHRhZ25hbWVcclxuICogQHBhcmFtIHtTdHJpbmd9IHNoYWRvd0h0bWwgc2hhZG93IGlubmVyIGh0bWwsIGluY2x1ZGUgc3R5bGUgYW5kIG90aGVyXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb24gRWxlIG9wdGlvbntpbml0LGdldCB4eCxzZXQgeHguLi59XHJcbiAqIEBwYXJhbSB7Q2xhc3N9IGJhc2UgZGVmYXV0bCBpcyBIVE1MRWxlbWVudFxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRDdXN0b21FbGUodGFnTmFtZSwgc2hhZG93SHRtbCA9IFwiXCIsIG9wdGlvbiwgb25TaGFkb3cgPSB0cnVlLCBiYXNlID0gSFRNTEVsZW1lbnQpIHtcclxuICAgIGZ1bmN0aW9uIHRoYXRFbGUoLi4uYXJncykge1xyXG4gICAgICAgIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdChiYXNlLCBbXSwgdGhpcy5jb25zdHJ1Y3Rvcik7XHJcbiAgICB9XHJcbiAgICB0aGF0RWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZS5wcm90b3R5cGUpO1xyXG4gICAgdGhhdEVsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSB0aGF0RWxlO1xyXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoYXRFbGUsIGJhc2UpO1xyXG4gICAgdGhhdEVsZS5wcm90b3R5cGUuY29ubmVjdGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKG9uU2hhZG93KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHtcclxuICAgICAgICAgICAgICAgIG1vZGU6ICdvcGVuJyAvLyBzZWxmLWNsb3NpbmcgaXMgaGFyZCB0byBjb250cm9sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuaW5uZXJIVE1MID0gc2hhZG93SHRtbFxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FsbGFibGUob3B0aW9uLmluaXQpKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbi5pbml0LmNhbGwodGhpcylcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGF0RWxlLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24odGhhdEVsZS5wcm90b3R5cGUsIG9wdGlvbilcclxuICAgIC8vIHJlZ2lzdGVyZWRcclxuICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgdGhhdEVsZSlcclxufVxyXG5cclxuZnVuY3Rpb24gdHBsTG9hZGVyKHRleHQpIHtcclxuICAgIGxldCByZSA9IC88c2NyaXB0W1xcc1xcU10qPz4oW1xcc1xcU10qPyk8XFwvc2NyaXB0Pi9pLFxyXG4gICAgICAgIHNjcmlwdCA9IHRleHQubWF0Y2gocmUpWzFdLFxyXG4gICAgICAgIGh0bWwgPSB0ZXh0LnJlcGxhY2UocmUsIFwiXCIpLFxyXG4gICAgICAgIG9wdGlvbnMgPSBldmFsKGAoZnVuY3Rpb24oKXtsZXQgb3B0aW9uczske3NjcmlwdH1cXG5yZXR1cm4gb3B0aW9uc30pKClgKVxyXG4gICAgY3JlYXRDdXN0b21FbGUob3B0aW9ucy5uYW1lLCBodG1sLCBvcHRpb25zKVxyXG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/component/component.js\n");

/***/ }),

/***/ "./src/component/req.comp.js":
/*!***********************************!*\
  !*** ./src/component/req.comp.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\r\n    creatCustomEle,\r\n    tplLoader\r\n} = __webpack_require__(/*! ./component */ \"./src/component/component.js\")\r\nconst {\r\n    domApi\r\n} = __webpack_require__(/*! ../domapi.js */ \"./src/domapi.js\");\r\n\r\nconst eleTagName = \"p-require\"\r\n\r\nmodule.exports = function requireEleInit(){\r\n    function readTextFile(file, callback){\r\n        var rawFile = new XMLHttpRequest();\r\n        rawFile.open(\"GET\", file, false);\r\n        rawFile.onreadystatechange = function (){\r\n            if(rawFile.readyState === 4){\r\n                if(rawFile.status === 200 || rawFile.status == 0){\r\n                    var allText = rawFile.responseText;\r\n                    callback(allText)\r\n                }\r\n            }\r\n        }\r\n        rawFile.send(null);\r\n    }\r\n    function readText(url){\r\n        return new Promise((reslove,reject)=>{\r\n            try {\r\n                readTextFile(url,res=>{\r\n                    reslove(res)\r\n                })\r\n            } catch (err) {\r\n                reject(err)\r\n            }\r\n        })\r\n    }\r\n    function appendReqEle(from){\r\n        let $body = domApi.$(\"body\")\r\n        let dom = domApi.createDom(`<${eleTagName} from=\"${from}\"></${eleTagName}>`)\r\n        domApi.append(dom,$body)\r\n    }\r\n    creatCustomEle(eleTagName,\"<style>:host{display:none;}</style>\",{\r\n        init() {\r\n            if(this.getAttribute(\"from\")){\r\n                readText(this.getAttribute(\"from\"))\r\n                .then(text=>tplLoader(text))\r\n            }else if(this.getAttribute(\"fromOf\")){\r\n                let reqLs = this.getAttribute(\"fromOf\").trim().split(\";\").map(v=>v.trim())\r\n                for (const from of reqLs) {\r\n                    if(from == \"\")continue\r\n                    appendReqEle(from)\r\n                }\r\n            }\r\n        }\r\n    })\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50L3JlcS5jb21wLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudC9yZXEuY29tcC5qcz8zNWNhIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHtcclxuICAgIGNyZWF0Q3VzdG9tRWxlLFxyXG4gICAgdHBsTG9hZGVyXHJcbn0gPSByZXF1aXJlKFwiLi9jb21wb25lbnRcIilcclxuY29uc3Qge1xyXG4gICAgZG9tQXBpXHJcbn0gPSByZXF1aXJlKFwiLi4vZG9tYXBpLmpzXCIpO1xyXG5cclxuY29uc3QgZWxlVGFnTmFtZSA9IFwicC1yZXF1aXJlXCJcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVxdWlyZUVsZUluaXQoKXtcclxuICAgIGZ1bmN0aW9uIHJlYWRUZXh0RmlsZShmaWxlLCBjYWxsYmFjayl7XHJcbiAgICAgICAgdmFyIHJhd0ZpbGUgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICByYXdGaWxlLm9wZW4oXCJHRVRcIiwgZmlsZSwgZmFsc2UpO1xyXG4gICAgICAgIHJhd0ZpbGUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCl7XHJcbiAgICAgICAgICAgIGlmKHJhd0ZpbGUucmVhZHlTdGF0ZSA9PT0gNCl7XHJcbiAgICAgICAgICAgICAgICBpZihyYXdGaWxlLnN0YXR1cyA9PT0gMjAwIHx8IHJhd0ZpbGUuc3RhdHVzID09IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbGxUZXh0ID0gcmF3RmlsZS5yZXNwb25zZVRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soYWxsVGV4dClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByYXdGaWxlLnNlbmQobnVsbCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWFkVGV4dCh1cmwpe1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzbG92ZSxyZWplY3QpPT57XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZWFkVGV4dEZpbGUodXJsLHJlcz0+e1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc2xvdmUocmVzKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFwcGVuZFJlcUVsZShmcm9tKXtcclxuICAgICAgICBsZXQgJGJvZHkgPSBkb21BcGkuJChcImJvZHlcIilcclxuICAgICAgICBsZXQgZG9tID0gZG9tQXBpLmNyZWF0ZURvbShgPCR7ZWxlVGFnTmFtZX0gZnJvbT1cIiR7ZnJvbX1cIj48LyR7ZWxlVGFnTmFtZX0+YClcclxuICAgICAgICBkb21BcGkuYXBwZW5kKGRvbSwkYm9keSlcclxuICAgIH1cclxuICAgIGNyZWF0Q3VzdG9tRWxlKGVsZVRhZ05hbWUsXCI8c3R5bGU+Omhvc3R7ZGlzcGxheTpub25lO308L3N0eWxlPlwiLHtcclxuICAgICAgICBpbml0KCkge1xyXG4gICAgICAgICAgICBpZih0aGlzLmdldEF0dHJpYnV0ZShcImZyb21cIikpe1xyXG4gICAgICAgICAgICAgICAgcmVhZFRleHQodGhpcy5nZXRBdHRyaWJ1dGUoXCJmcm9tXCIpKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4odGV4dD0+dHBsTG9hZGVyKHRleHQpKVxyXG4gICAgICAgICAgICB9ZWxzZSBpZih0aGlzLmdldEF0dHJpYnV0ZShcImZyb21PZlwiKSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVxTHMgPSB0aGlzLmdldEF0dHJpYnV0ZShcImZyb21PZlwiKS50cmltKCkuc3BsaXQoXCI7XCIpLm1hcCh2PT52LnRyaW0oKSlcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZnJvbSBvZiByZXFMcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGZyb20gPT0gXCJcIiljb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZFJlcUVsZShmcm9tKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxufVxyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/component/req.comp.js\n");

/***/ }),

/***/ "./src/core/Po.js":
/*!************************!*\
  !*** ./src/core/Po.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\r\n    deepClone,\r\n    extend,\r\n    GetAttrElement,\r\n    proxyArr\r\n} = __webpack_require__(/*! ./util/util */ \"./src/core/util/util.js\");\r\nconst attrRoster = __webpack_require__(/*! ./util/attrRoster */ \"./src/core/util/attrRoster.js\");\r\n// const TplEng = require(\"./template\");\r\nconst {\r\n    JxTpl\r\n} = __webpack_require__(/*! ./jx */ \"./src/core/jx.js\")\r\nconst Jsvm = __webpack_require__(/*! ./util/JsVm */ \"./src/core/util/JsVm.js\");\r\n\r\n// let replaceSubNode = (html, subPos, supper, localPo) => {\r\n//     let resloveData = attrs => {\r\n//         let res = {}\r\n//         if (attrs == undefined || attrs.length == 0) return res\r\n//         let arr = attrs.split(\" \")\r\n//         let re = new RegExp(`(.+?)=([\"'])(.+?)\\\\2`)\r\n//         for (let attr of arr) {\r\n//             if (attr.trim() == \"\") continue\r\n//             let reg$arr = re.exec(attr)\r\n//             res[reg$arr[1]] = reg$arr[3]\r\n//         }\r\n//         return res\r\n//     }\r\n//     let reslove = html\r\n//     let localCur = 0\r\n//     for (let subName in subPos) {\r\n//         let sub = subPos[subName]\r\n//         let re = new RegExp(\"<(\" + subName + \")(( [^<> ]*)*)>([^<>]*)<\\/\" + subName + \">\", \"gi\")\r\n//         let subArr = html.match(re)\r\n//         if (!subArr) continue\r\n//         for (let _si in subArr) {\r\n//             let _s = subArr[_si]\r\n//             re = new RegExp(\"<(\" + subName + \")(( [^<> ]*)*)>([^<>]*)<\\/\" + subName + \">\", \"gi\")\r\n//             let reg$arr = re.exec(_s)\r\n//             let tempData = resloveData(reg$arr[2])\r\n//             tempData._content = reg$arr[4]\r\n//             if (localPo[localCur] == undefined) {\r\n//                 localPo.push(sub.Clone(tempData))\r\n//             }\r\n//             let temp = localPo[localCur].assemble(supper, localCur)\r\n//             reslove = reslove.replace(_s, temp)\r\n//             localCur += 1\r\n//         }\r\n//     }\r\n//     return reslove\r\n// }\r\n\r\nlet _init_DateValueProperty = (data, EventManager) => {\r\n    let source = deepClone(data)\r\n    for (let variable in data) {\r\n        let srcVal = data[variable];\r\n        let option = {}\r\n        if (Object.prototype.toString.call(srcVal) == \"[object Array]\") {\r\n            // #101 length problem\r\n            srcVal = proxyArr(srcVal, newVal => {\r\n                EventManager.emit(\"SET_\" + variable, newVal);\r\n                EventManager.emit(\"_rerender_\");\r\n                if (source[variable].length == newVal.length) return\r\n                source[variable] = newVal;\r\n            })\r\n        }\r\n        if (typeof srcVal === \"function\") {\r\n            if (/EventManager.emit/g.test(srcVal.toString()))\r\n                continue\r\n            // function in data\r\n            data[variable] = (...args) => srcVal.apply(data, args)\r\n            continue;\r\n        } else {\r\n            option.get = () => source[variable];\r\n        }\r\n        option.set = newVal => {\r\n            if (source[variable] == newVal) return\r\n            source[variable] = newVal;\r\n            EventManager.emit(\"SET_\" + variable, newVal);\r\n            EventManager.emit(\"_rerender_\");\r\n        }\r\n        Object.defineProperty(data, variable, option)\r\n        data[variable] = srcVal;\r\n    }\r\n    return data;\r\n}\r\n\r\nlet hitchOnEv = (EventManager, onTypeEventArr, data, localArr) => {\r\n    for (var event_ in onTypeEventArr) {\r\n        if (onTypeEventArr.hasOwnProperty(event_)) {\r\n            let thisOption = onTypeEventArr[event_],\r\n                evName = thisOption.eventName,\r\n                coStr = thisOption.codeStr,\r\n                that_data = data,\r\n                ele = thisOption.ele,\r\n                withData = {};\r\n            EventManager.addEventLookUp(evName)\r\n            if (ele.attributes[\"PoiId\"] != undefined) {\r\n                let _index = ele.attributes[\"PoiId\"].nodeValue\r\n                withData = localArr[_index].data\r\n            }\r\n            EventManager.on(evName, e => {\r\n                if (e.target === ele) {\r\n                    let dataobj = Object.assign(that_data, {\r\n                        e: e,\r\n                        self: e.target\r\n                    }, withData)\r\n                    Jsvm.safe(coStr, that_data);\r\n\r\n                    EventManager.emit(\"_rerender_\");\r\n                }\r\n            })\r\n        }\r\n    }\r\n    // on_ev end\r\n}\r\nlet hitchBindEv = (EventManager, bindTypeEventArr, data, localArr) => {\r\n    for (var EventConf in bindTypeEventArr) {\r\n        if (bindTypeEventArr.hasOwnProperty(EventConf)) {\r\n            let thisOption = bindTypeEventArr[EventConf],\r\n                eventName = thisOption.eventName,\r\n                innerCODE = thisOption.codeStr,\r\n                that_data = data,\r\n                ele = thisOption.ele,\r\n                withData = {};\r\n            if (ele.attributes[\"PoiId\"] != undefined) {\r\n                let _index = ele.attributes[\"PoiId\"].nodeValue\r\n                withData = localArr[_index].data\r\n            }\r\n            if (eventName == \"class\")\r\n                eventName = \"className\"\r\n            ele[eventName] = Jsvm.safe(\"return(\" + innerCODE + \")\", Object.assign(deepClone(withData), that_data));\r\n            // init value\r\n            EventManager.on(\"_rerender_\", () => {\r\n                if (ele && ele.parentNode != null) {\r\n                    // require(\"../util/JsVm.js\").micVm(innerCODE, that_data);\r\n                    ele[eventName] = Jsvm.safe(\"return(\" + innerCODE + \")\", Object.assign(deepClone(withData), that_data))\r\n                }\r\n            })\r\n        }\r\n    }\r\n};\r\n\r\nlet hitchWath = (watchTypeEventArr, EventManager) => {\r\n    for (let wathValueOfKey in watchTypeEventArr) {\r\n        if (typeof watchTypeEventArr[wathValueOfKey] === \"function\") {\r\n            EventManager.on(\"SET_\" + wathValueOfKey, (newVal) => {\r\n                watchTypeEventArr[wathValueOfKey](newVal);\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\nfunction Po(JxTplText, data, watch, evManger, mixwith, Jx) {\r\n    // mixwith\r\n    if (mixwith) extend(data, deepClone(mixwith.$pureData));\r\n\r\n    this.$pureData = deepClone(data)\r\n    // tpl\r\n    this.Clone = _data => {\r\n        return {\r\n            $pureData: Object.assign(deepClone(_data), this.$pureData),\r\n            tpl: this.tpl,\r\n            data: _init_DateValueProperty(deepClone(Object.assign(deepClone(_data), deepClone(this.$pureData))), evManger),\r\n            assemble: function(data, _id) {\r\n                return this.tpl.joint(Object.assign(this.data, data), _id)\r\n            }\r\n        }\r\n    }\r\n    // data\r\n    this.data = _init_DateValueProperty(data, evManger)\r\n    //\r\n    // subPo\r\n    this.tpl = new JxTpl(JxTplText, Jx); //new Template(template,subPos);\r\n    if (watch) hitchWath(watch, evManger);\r\n    // error everyday\r\n    //\r\n    this.$localPo = []\r\n    this.assemble = function(data, _id) {\r\n        if (data != undefined) {\r\n            Object.assign(deepClone(data), this.data)\r\n        } else {\r\n            data = deepClone(this.data)\r\n        }\r\n        let res = this.tpl.joint(data, _id)\r\n        // if (subPos != undefined) {\r\n        //     return replaceSubNode(res, subPos, this.data, this.$localPo)\r\n        // } else {\r\n        return res\r\n        // }\r\n    };\r\n\r\n    this.$bind = patchs => {\r\n        if (patchs.length == 0) return\r\n        let bindArr = [],\r\n            onArr = [];\r\n        let splitEv = ele => {\r\n            if (ele.nodeType == 3) return\r\n            if (ele.children.length != 0) {\r\n                for (let _chi in ele.children) {\r\n                    if (_chi == \"length\") break\r\n                    let _ch = ele.children[_chi]\r\n                    splitEv(_ch)\r\n                }\r\n            }\r\n            let attrs = ele.attributes\r\n            if (attrs.length == 0) return\r\n            const isOn = node => /on:/g.test(node.nodeName);\r\n            const isBind = node => /bind:/g.test(node.nodeName);\r\n\r\n            for (let attri in attrs) {\r\n                let attr = attrs[attri]\r\n                if (isOn(attr)) {\r\n                    onArr.push({\r\n                        ele: ele,\r\n                        eventName: attr.nodeName.split(\":\")[1],\r\n                        codeStr: attr.nodeValue\r\n                    })\r\n                }\r\n                if (isBind(attr)) {\r\n                    let evName = attr.nodeName.split(\":\")[1]\r\n                    if(evName in attrRoster)evName = attrRoster[evName]\r\n                    bindArr.push({\r\n                        ele: ele,\r\n                        eventName: evName,\r\n                        codeStr: attr.nodeValue\r\n                    })\r\n                }\r\n            }\r\n        }\r\n        for (let _patchi in patchs) {\r\n            let _patch = patchs[_patchi]\r\n            if (_patch.option == \"add\" || _patch.option == \"attributesChange\") {\r\n                splitEv(_patch.ele)\r\n            }\r\n        }\r\n        if (onArr.length != 0)\r\n            hitchOnEv(evManger, onArr, this.data, this.$localPo)\r\n        if (bindArr.length != 0)\r\n            hitchBindEv(evManger, bindArr, this.data, this.$localPo);\r\n    };\r\n}\r\n\r\nlet generateSubPo = function(poList, evManger) {\r\n    // banned\r\n    // =========================================\r\n    // let res = {}\r\n    // for (let poName in poList) {\r\n    //     let sub = poList[poName],\r\n    //         tplText\r\n    //     if (sub.tpl[0] == \"#\") {\r\n    //         tplText = document.querySelector(sub.tpl).innerHTML;\r\n    //     } else {\r\n    //         tplText = sub.tpl\r\n    //     }\r\n    //     res[poName] = new Po(tplText, deepClone(sub.data), {}, evManger)\r\n    // }\r\n    // return res\r\n}\r\n\r\nmodule.exports = {\r\n    Po,\r\n    generateSubPo\r\n};\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9Qby5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb3JlL1BvLmpzPzIyNDQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qge1xyXG4gICAgZGVlcENsb25lLFxyXG4gICAgZXh0ZW5kLFxyXG4gICAgR2V0QXR0ckVsZW1lbnQsXHJcbiAgICBwcm94eUFyclxyXG59ID0gcmVxdWlyZShcIi4vdXRpbC91dGlsXCIpO1xyXG5jb25zdCBhdHRyUm9zdGVyID0gcmVxdWlyZShcIi4vdXRpbC9hdHRyUm9zdGVyXCIpO1xyXG4vLyBjb25zdCBUcGxFbmcgPSByZXF1aXJlKFwiLi90ZW1wbGF0ZVwiKTtcclxuY29uc3Qge1xyXG4gICAgSnhUcGxcclxufSA9IHJlcXVpcmUoXCIuL2p4XCIpXHJcbmNvbnN0IEpzdm0gPSByZXF1aXJlKFwiLi91dGlsL0pzVm1cIik7XHJcblxyXG4vLyBsZXQgcmVwbGFjZVN1Yk5vZGUgPSAoaHRtbCwgc3ViUG9zLCBzdXBwZXIsIGxvY2FsUG8pID0+IHtcclxuLy8gICAgIGxldCByZXNsb3ZlRGF0YSA9IGF0dHJzID0+IHtcclxuLy8gICAgICAgICBsZXQgcmVzID0ge31cclxuLy8gICAgICAgICBpZiAoYXR0cnMgPT0gdW5kZWZpbmVkIHx8IGF0dHJzLmxlbmd0aCA9PSAwKSByZXR1cm4gcmVzXHJcbi8vICAgICAgICAgbGV0IGFyciA9IGF0dHJzLnNwbGl0KFwiIFwiKVxyXG4vLyAgICAgICAgIGxldCByZSA9IG5ldyBSZWdFeHAoYCguKz8pPShbXCInXSkoLis/KVxcXFwyYClcclxuLy8gICAgICAgICBmb3IgKGxldCBhdHRyIG9mIGFycikge1xyXG4vLyAgICAgICAgICAgICBpZiAoYXR0ci50cmltKCkgPT0gXCJcIikgY29udGludWVcclxuLy8gICAgICAgICAgICAgbGV0IHJlZyRhcnIgPSByZS5leGVjKGF0dHIpXHJcbi8vICAgICAgICAgICAgIHJlc1tyZWckYXJyWzFdXSA9IHJlZyRhcnJbM11cclxuLy8gICAgICAgICB9XHJcbi8vICAgICAgICAgcmV0dXJuIHJlc1xyXG4vLyAgICAgfVxyXG4vLyAgICAgbGV0IHJlc2xvdmUgPSBodG1sXHJcbi8vICAgICBsZXQgbG9jYWxDdXIgPSAwXHJcbi8vICAgICBmb3IgKGxldCBzdWJOYW1lIGluIHN1YlBvcykge1xyXG4vLyAgICAgICAgIGxldCBzdWIgPSBzdWJQb3Nbc3ViTmFtZV1cclxuLy8gICAgICAgICBsZXQgcmUgPSBuZXcgUmVnRXhwKFwiPChcIiArIHN1Yk5hbWUgKyBcIikoKCBbXjw+IF0qKSopPihbXjw+XSopPFxcL1wiICsgc3ViTmFtZSArIFwiPlwiLCBcImdpXCIpXHJcbi8vICAgICAgICAgbGV0IHN1YkFyciA9IGh0bWwubWF0Y2gocmUpXHJcbi8vICAgICAgICAgaWYgKCFzdWJBcnIpIGNvbnRpbnVlXHJcbi8vICAgICAgICAgZm9yIChsZXQgX3NpIGluIHN1YkFycikge1xyXG4vLyAgICAgICAgICAgICBsZXQgX3MgPSBzdWJBcnJbX3NpXVxyXG4vLyAgICAgICAgICAgICByZSA9IG5ldyBSZWdFeHAoXCI8KFwiICsgc3ViTmFtZSArIFwiKSgoIFtePD4gXSopKik+KFtePD5dKik8XFwvXCIgKyBzdWJOYW1lICsgXCI+XCIsIFwiZ2lcIilcclxuLy8gICAgICAgICAgICAgbGV0IHJlZyRhcnIgPSByZS5leGVjKF9zKVxyXG4vLyAgICAgICAgICAgICBsZXQgdGVtcERhdGEgPSByZXNsb3ZlRGF0YShyZWckYXJyWzJdKVxyXG4vLyAgICAgICAgICAgICB0ZW1wRGF0YS5fY29udGVudCA9IHJlZyRhcnJbNF1cclxuLy8gICAgICAgICAgICAgaWYgKGxvY2FsUG9bbG9jYWxDdXJdID09IHVuZGVmaW5lZCkge1xyXG4vLyAgICAgICAgICAgICAgICAgbG9jYWxQby5wdXNoKHN1Yi5DbG9uZSh0ZW1wRGF0YSkpXHJcbi8vICAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgICAgbGV0IHRlbXAgPSBsb2NhbFBvW2xvY2FsQ3VyXS5hc3NlbWJsZShzdXBwZXIsIGxvY2FsQ3VyKVxyXG4vLyAgICAgICAgICAgICByZXNsb3ZlID0gcmVzbG92ZS5yZXBsYWNlKF9zLCB0ZW1wKVxyXG4vLyAgICAgICAgICAgICBsb2NhbEN1ciArPSAxXHJcbi8vICAgICAgICAgfVxyXG4vLyAgICAgfVxyXG4vLyAgICAgcmV0dXJuIHJlc2xvdmVcclxuLy8gfVxyXG5cclxubGV0IF9pbml0X0RhdGVWYWx1ZVByb3BlcnR5ID0gKGRhdGEsIEV2ZW50TWFuYWdlcikgPT4ge1xyXG4gICAgbGV0IHNvdXJjZSA9IGRlZXBDbG9uZShkYXRhKVxyXG4gICAgZm9yIChsZXQgdmFyaWFibGUgaW4gZGF0YSkge1xyXG4gICAgICAgIGxldCBzcmNWYWwgPSBkYXRhW3ZhcmlhYmxlXTtcclxuICAgICAgICBsZXQgb3B0aW9uID0ge31cclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNyY1ZhbCkgPT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XHJcbiAgICAgICAgICAgIC8vICMxMDEgbGVuZ3RoIHByb2JsZW1cclxuICAgICAgICAgICAgc3JjVmFsID0gcHJveHlBcnIoc3JjVmFsLCBuZXdWYWwgPT4ge1xyXG4gICAgICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLmVtaXQoXCJTRVRfXCIgKyB2YXJpYWJsZSwgbmV3VmFsKTtcclxuICAgICAgICAgICAgICAgIEV2ZW50TWFuYWdlci5lbWl0KFwiX3JlcmVuZGVyX1wiKTtcclxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VbdmFyaWFibGVdLmxlbmd0aCA9PSBuZXdWYWwubGVuZ3RoKSByZXR1cm5cclxuICAgICAgICAgICAgICAgIHNvdXJjZVt2YXJpYWJsZV0gPSBuZXdWYWw7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygc3JjVmFsID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgaWYgKC9FdmVudE1hbmFnZXIuZW1pdC9nLnRlc3Qoc3JjVmFsLnRvU3RyaW5nKCkpKVxyXG4gICAgICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgICAgLy8gZnVuY3Rpb24gaW4gZGF0YVxyXG4gICAgICAgICAgICBkYXRhW3ZhcmlhYmxlXSA9ICguLi5hcmdzKSA9PiBzcmNWYWwuYXBwbHkoZGF0YSwgYXJncylcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgb3B0aW9uLmdldCA9ICgpID0+IHNvdXJjZVt2YXJpYWJsZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9wdGlvbi5zZXQgPSBuZXdWYWwgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc291cmNlW3ZhcmlhYmxlXSA9PSBuZXdWYWwpIHJldHVyblxyXG4gICAgICAgICAgICBzb3VyY2VbdmFyaWFibGVdID0gbmV3VmFsO1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuZW1pdChcIlNFVF9cIiArIHZhcmlhYmxlLCBuZXdWYWwpO1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuZW1pdChcIl9yZXJlbmRlcl9cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhLCB2YXJpYWJsZSwgb3B0aW9uKVxyXG4gICAgICAgIGRhdGFbdmFyaWFibGVdID0gc3JjVmFsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn1cclxuXHJcbmxldCBoaXRjaE9uRXYgPSAoRXZlbnRNYW5hZ2VyLCBvblR5cGVFdmVudEFyciwgZGF0YSwgbG9jYWxBcnIpID0+IHtcclxuICAgIGZvciAodmFyIGV2ZW50XyBpbiBvblR5cGVFdmVudEFycikge1xyXG4gICAgICAgIGlmIChvblR5cGVFdmVudEFyci5oYXNPd25Qcm9wZXJ0eShldmVudF8pKSB7XHJcbiAgICAgICAgICAgIGxldCB0aGlzT3B0aW9uID0gb25UeXBlRXZlbnRBcnJbZXZlbnRfXSxcclxuICAgICAgICAgICAgICAgIGV2TmFtZSA9IHRoaXNPcHRpb24uZXZlbnROYW1lLFxyXG4gICAgICAgICAgICAgICAgY29TdHIgPSB0aGlzT3B0aW9uLmNvZGVTdHIsXHJcbiAgICAgICAgICAgICAgICB0aGF0X2RhdGEgPSBkYXRhLFxyXG4gICAgICAgICAgICAgICAgZWxlID0gdGhpc09wdGlvbi5lbGUsXHJcbiAgICAgICAgICAgICAgICB3aXRoRGF0YSA9IHt9O1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuYWRkRXZlbnRMb29rVXAoZXZOYW1lKVxyXG4gICAgICAgICAgICBpZiAoZWxlLmF0dHJpYnV0ZXNbXCJQb2lJZFwiXSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBfaW5kZXggPSBlbGUuYXR0cmlidXRlc1tcIlBvaUlkXCJdLm5vZGVWYWx1ZVxyXG4gICAgICAgICAgICAgICAgd2l0aERhdGEgPSBsb2NhbEFycltfaW5kZXhdLmRhdGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIub24oZXZOYW1lLCBlID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlLnRhcmdldCA9PT0gZWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFvYmogPSBPYmplY3QuYXNzaWduKHRoYXRfZGF0YSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlOiBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmOiBlLnRhcmdldFxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHdpdGhEYXRhKVxyXG4gICAgICAgICAgICAgICAgICAgIEpzdm0uc2FmZShjb1N0ciwgdGhhdF9kYXRhKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLmVtaXQoXCJfcmVyZW5kZXJfXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG9uX2V2IGVuZFxyXG59XHJcbmxldCBoaXRjaEJpbmRFdiA9IChFdmVudE1hbmFnZXIsIGJpbmRUeXBlRXZlbnRBcnIsIGRhdGEsIGxvY2FsQXJyKSA9PiB7XHJcbiAgICBmb3IgKHZhciBFdmVudENvbmYgaW4gYmluZFR5cGVFdmVudEFycikge1xyXG4gICAgICAgIGlmIChiaW5kVHlwZUV2ZW50QXJyLmhhc093blByb3BlcnR5KEV2ZW50Q29uZikpIHtcclxuICAgICAgICAgICAgbGV0IHRoaXNPcHRpb24gPSBiaW5kVHlwZUV2ZW50QXJyW0V2ZW50Q29uZl0sXHJcbiAgICAgICAgICAgICAgICBldmVudE5hbWUgPSB0aGlzT3B0aW9uLmV2ZW50TmFtZSxcclxuICAgICAgICAgICAgICAgIGlubmVyQ09ERSA9IHRoaXNPcHRpb24uY29kZVN0cixcclxuICAgICAgICAgICAgICAgIHRoYXRfZGF0YSA9IGRhdGEsXHJcbiAgICAgICAgICAgICAgICBlbGUgPSB0aGlzT3B0aW9uLmVsZSxcclxuICAgICAgICAgICAgICAgIHdpdGhEYXRhID0ge307XHJcbiAgICAgICAgICAgIGlmIChlbGUuYXR0cmlidXRlc1tcIlBvaUlkXCJdICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IF9pbmRleCA9IGVsZS5hdHRyaWJ1dGVzW1wiUG9pSWRcIl0ubm9kZVZhbHVlXHJcbiAgICAgICAgICAgICAgICB3aXRoRGF0YSA9IGxvY2FsQXJyW19pbmRleF0uZGF0YVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT0gXCJjbGFzc1wiKVxyXG4gICAgICAgICAgICAgICAgZXZlbnROYW1lID0gXCJjbGFzc05hbWVcIlxyXG4gICAgICAgICAgICBlbGVbZXZlbnROYW1lXSA9IEpzdm0uc2FmZShcInJldHVybihcIiArIGlubmVyQ09ERSArIFwiKVwiLCBPYmplY3QuYXNzaWduKGRlZXBDbG9uZSh3aXRoRGF0YSksIHRoYXRfZGF0YSkpO1xyXG4gICAgICAgICAgICAvLyBpbml0IHZhbHVlXHJcbiAgICAgICAgICAgIEV2ZW50TWFuYWdlci5vbihcIl9yZXJlbmRlcl9cIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZSAmJiBlbGUucGFyZW50Tm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVxdWlyZShcIi4uL3V0aWwvSnNWbS5qc1wiKS5taWNWbShpbm5lckNPREUsIHRoYXRfZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlW2V2ZW50TmFtZV0gPSBKc3ZtLnNhZmUoXCJyZXR1cm4oXCIgKyBpbm5lckNPREUgKyBcIilcIiwgT2JqZWN0LmFzc2lnbihkZWVwQ2xvbmUod2l0aERhdGEpLCB0aGF0X2RhdGEpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbmxldCBoaXRjaFdhdGggPSAod2F0Y2hUeXBlRXZlbnRBcnIsIEV2ZW50TWFuYWdlcikgPT4ge1xyXG4gICAgZm9yIChsZXQgd2F0aFZhbHVlT2ZLZXkgaW4gd2F0Y2hUeXBlRXZlbnRBcnIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdhdGNoVHlwZUV2ZW50QXJyW3dhdGhWYWx1ZU9mS2V5XSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIEV2ZW50TWFuYWdlci5vbihcIlNFVF9cIiArIHdhdGhWYWx1ZU9mS2V5LCAobmV3VmFsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB3YXRjaFR5cGVFdmVudEFyclt3YXRoVmFsdWVPZktleV0obmV3VmFsKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFBvKEp4VHBsVGV4dCwgZGF0YSwgd2F0Y2gsIGV2TWFuZ2VyLCBtaXh3aXRoLCBKeCkge1xyXG4gICAgLy8gbWl4d2l0aFxyXG4gICAgaWYgKG1peHdpdGgpIGV4dGVuZChkYXRhLCBkZWVwQ2xvbmUobWl4d2l0aC4kcHVyZURhdGEpKTtcclxuXHJcbiAgICB0aGlzLiRwdXJlRGF0YSA9IGRlZXBDbG9uZShkYXRhKVxyXG4gICAgLy8gdHBsXHJcbiAgICB0aGlzLkNsb25lID0gX2RhdGEgPT4ge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICRwdXJlRGF0YTogT2JqZWN0LmFzc2lnbihkZWVwQ2xvbmUoX2RhdGEpLCB0aGlzLiRwdXJlRGF0YSksXHJcbiAgICAgICAgICAgIHRwbDogdGhpcy50cGwsXHJcbiAgICAgICAgICAgIGRhdGE6IF9pbml0X0RhdGVWYWx1ZVByb3BlcnR5KGRlZXBDbG9uZShPYmplY3QuYXNzaWduKGRlZXBDbG9uZShfZGF0YSksIGRlZXBDbG9uZSh0aGlzLiRwdXJlRGF0YSkpKSwgZXZNYW5nZXIpLFxyXG4gICAgICAgICAgICBhc3NlbWJsZTogZnVuY3Rpb24oZGF0YSwgX2lkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cGwuam9pbnQoT2JqZWN0LmFzc2lnbih0aGlzLmRhdGEsIGRhdGEpLCBfaWQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBkYXRhXHJcbiAgICB0aGlzLmRhdGEgPSBfaW5pdF9EYXRlVmFsdWVQcm9wZXJ0eShkYXRhLCBldk1hbmdlcilcclxuICAgIC8vXHJcbiAgICAvLyBzdWJQb1xyXG4gICAgdGhpcy50cGwgPSBuZXcgSnhUcGwoSnhUcGxUZXh0LCBKeCk7IC8vbmV3IFRlbXBsYXRlKHRlbXBsYXRlLHN1YlBvcyk7XHJcbiAgICBpZiAod2F0Y2gpIGhpdGNoV2F0aCh3YXRjaCwgZXZNYW5nZXIpO1xyXG4gICAgLy8gZXJyb3IgZXZlcnlkYXlcclxuICAgIC8vXHJcbiAgICB0aGlzLiRsb2NhbFBvID0gW11cclxuICAgIHRoaXMuYXNzZW1ibGUgPSBmdW5jdGlvbihkYXRhLCBfaWQpIHtcclxuICAgICAgICBpZiAoZGF0YSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihkZWVwQ2xvbmUoZGF0YSksIHRoaXMuZGF0YSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkYXRhID0gZGVlcENsb25lKHRoaXMuZGF0YSlcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlcyA9IHRoaXMudHBsLmpvaW50KGRhdGEsIF9pZClcclxuICAgICAgICAvLyBpZiAoc3ViUG9zICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vICAgICByZXR1cm4gcmVwbGFjZVN1Yk5vZGUocmVzLCBzdWJQb3MsIHRoaXMuZGF0YSwgdGhpcy4kbG9jYWxQbylcclxuICAgICAgICAvLyB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiByZXNcclxuICAgICAgICAvLyB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuJGJpbmQgPSBwYXRjaHMgPT4ge1xyXG4gICAgICAgIGlmIChwYXRjaHMubGVuZ3RoID09IDApIHJldHVyblxyXG4gICAgICAgIGxldCBiaW5kQXJyID0gW10sXHJcbiAgICAgICAgICAgIG9uQXJyID0gW107XHJcbiAgICAgICAgbGV0IHNwbGl0RXYgPSBlbGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZWxlLm5vZGVUeXBlID09IDMpIHJldHVyblxyXG4gICAgICAgICAgICBpZiAoZWxlLmNoaWxkcmVuLmxlbmd0aCAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBfY2hpIGluIGVsZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfY2hpID09IFwibGVuZ3RoXCIpIGJyZWFrXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IF9jaCA9IGVsZS5jaGlsZHJlbltfY2hpXVxyXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0RXYoX2NoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBhdHRycyA9IGVsZS5hdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgIGlmIChhdHRycy5sZW5ndGggPT0gMCkgcmV0dXJuXHJcbiAgICAgICAgICAgIGNvbnN0IGlzT24gPSBub2RlID0+IC9vbjovZy50ZXN0KG5vZGUubm9kZU5hbWUpO1xyXG4gICAgICAgICAgICBjb25zdCBpc0JpbmQgPSBub2RlID0+IC9iaW5kOi9nLnRlc3Qobm9kZS5ub2RlTmFtZSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBhdHRyaSBpbiBhdHRycykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGF0dHIgPSBhdHRyc1thdHRyaV1cclxuICAgICAgICAgICAgICAgIGlmIChpc09uKGF0dHIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25BcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZTogZWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudE5hbWU6IGF0dHIubm9kZU5hbWUuc3BsaXQoXCI6XCIpWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlU3RyOiBhdHRyLm5vZGVWYWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNCaW5kKGF0dHIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV2TmFtZSA9IGF0dHIubm9kZU5hbWUuc3BsaXQoXCI6XCIpWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZXZOYW1lIGluIGF0dHJSb3N0ZXIpZXZOYW1lID0gYXR0clJvc3Rlcltldk5hbWVdXHJcbiAgICAgICAgICAgICAgICAgICAgYmluZEFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlOiBlbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZTogZXZOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlU3RyOiBhdHRyLm5vZGVWYWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgX3BhdGNoaSBpbiBwYXRjaHMpIHtcclxuICAgICAgICAgICAgbGV0IF9wYXRjaCA9IHBhdGNoc1tfcGF0Y2hpXVxyXG4gICAgICAgICAgICBpZiAoX3BhdGNoLm9wdGlvbiA9PSBcImFkZFwiIHx8IF9wYXRjaC5vcHRpb24gPT0gXCJhdHRyaWJ1dGVzQ2hhbmdlXCIpIHtcclxuICAgICAgICAgICAgICAgIHNwbGl0RXYoX3BhdGNoLmVsZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob25BcnIubGVuZ3RoICE9IDApXHJcbiAgICAgICAgICAgIGhpdGNoT25Fdihldk1hbmdlciwgb25BcnIsIHRoaXMuZGF0YSwgdGhpcy4kbG9jYWxQbylcclxuICAgICAgICBpZiAoYmluZEFyci5sZW5ndGggIT0gMClcclxuICAgICAgICAgICAgaGl0Y2hCaW5kRXYoZXZNYW5nZXIsIGJpbmRBcnIsIHRoaXMuZGF0YSwgdGhpcy4kbG9jYWxQbyk7XHJcbiAgICB9O1xyXG59XHJcblxyXG5sZXQgZ2VuZXJhdGVTdWJQbyA9IGZ1bmN0aW9uKHBvTGlzdCwgZXZNYW5nZXIpIHtcclxuICAgIC8vIGJhbm5lZFxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIGxldCByZXMgPSB7fVxyXG4gICAgLy8gZm9yIChsZXQgcG9OYW1lIGluIHBvTGlzdCkge1xyXG4gICAgLy8gICAgIGxldCBzdWIgPSBwb0xpc3RbcG9OYW1lXSxcclxuICAgIC8vICAgICAgICAgdHBsVGV4dFxyXG4gICAgLy8gICAgIGlmIChzdWIudHBsWzBdID09IFwiI1wiKSB7XHJcbiAgICAvLyAgICAgICAgIHRwbFRleHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHN1Yi50cGwpLmlubmVySFRNTDtcclxuICAgIC8vICAgICB9IGVsc2Uge1xyXG4gICAgLy8gICAgICAgICB0cGxUZXh0ID0gc3ViLnRwbFxyXG4gICAgLy8gICAgIH1cclxuICAgIC8vICAgICByZXNbcG9OYW1lXSA9IG5ldyBQbyh0cGxUZXh0LCBkZWVwQ2xvbmUoc3ViLmRhdGEpLCB7fSwgZXZNYW5nZXIpXHJcbiAgICAvLyB9XHJcbiAgICAvLyByZXR1cm4gcmVzXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgUG8sXHJcbiAgICBnZW5lcmF0ZVN1YlBvXHJcbn07XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/Po.js\n");

/***/ }),

/***/ "./src/core/Poi.js":
/*!*************************!*\
  !*** ./src/core/Poi.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const EventOnEle = __webpack_require__(/*! ./event */ \"./src/core/event.js\");\r\nconst diff = __webpack_require__(/*! ./diff/diff */ \"./src/core/diff/diff.js\");\r\nconst {\r\n    Po,\r\n    generateSubPo\r\n} = __webpack_require__(/*! ./Po */ \"./src/core/Po.js\");\r\n\r\nfunction INT_OBJ(){\r\n    return {\r\n        wtever: false, // async Interrupt flag\r\n        clear: null // Interrupt call\r\n    }\r\n}\r\n\r\nfunction async_diff(ctx) {\r\n    if (ctx.current_render_INT_OBJ) {\r\n        // Interrupt check\r\n        ctx.current_render_INT_OBJ.wtever = true;\r\n        if (ctx.current_render_INT_OBJ.clear)\r\n            ctx.current_render_INT_OBJ.clear()\r\n        // unblock async render task\r\n        ctx.current_render_INT_OBJ = new INT_OBJ();\r\n    }\r\n    (async () => {\r\n        // render mount before\r\n        if(ctx.mounts && ctx.mounts.renderBefore)\r\n            ctx.mounts.renderBefore.call(ctx.Po.data, ctx.el)\r\n\r\n        // dirty checking maybe\r\n        let patchArr = await diff(ctx.el, ctx.Po.assemble(), ctx.current_render_INT_OBJ);\r\n        ctx.Po.$bind(patchArr)\r\n\r\n        // render mount after\r\n        if(ctx.mounts && ctx.mounts.renderAfter && patchArr.length != 0)\r\n            ctx.mounts.renderAfter.call(ctx.Po.data, ctx.el)\r\n    })();\r\n}\r\n\r\nfunction polyOptions(options){\r\n    // poly old ver\r\n    let {\r\n        el:_ele,\r\n        ele,\r\n        tpl,\r\n        template,\r\n        data,\r\n        watch,\r\n        subPos:components,\r\n        mixwith,\r\n        mount:mounts,\r\n        mounted:_mounts\r\n    } = options;\r\n    return {\r\n        el: ele || _ele,\r\n        tpl: template || tpl,\r\n        data,\r\n        watch,\r\n        components,\r\n        mixwith,\r\n        mount: mounts || _mounts\r\n    }\r\n}\r\n\r\nfunction Poi(options, GlobalJxEnviron) {\r\n    // options\r\n    let {\r\n        el:ele,\r\n        tpl:template,\r\n        data,\r\n        watch,\r\n        components:subPos,\r\n        mixwith,\r\n        mount:mounts\r\n    } = polyOptions(options);\r\n    this.el = ele;\r\n    // on,emit\r\n    // bind evlisenter\r\n    this.Event = new EventOnEle(this.el);\r\n\r\n    // #401 babel es5 leads to mistakes\r\n    \r\n    // async diff render\r\n    this.current_render_INT_OBJ = new INT_OBJ();\r\n    this.render = () => async_diff(this);\r\n    \r\n    // sub components ====\\\\\r\n    // let subPoi = subPos ? generateSubPo(subPos, this.Event) : undefined\r\n    // sub components ====\\\\\r\n    // #402 mounted init function\r\n    if (mixwith && mixwith.mounts){\r\n        for (let key in mixwith.mounts) {\r\n            if (key in mounts)\r\n            mounts[key] = () => {\r\n                mixwith.mounts[key].apply(this)\r\n                mounts[key].apply(this)\r\n            };\r\n            else mounts[key] = mixwith.mounts[key];\r\n        }\r\n    }\r\n    this.mounts = mounts\r\n    // instance\r\n    this.Po = new Po(template, data, watch, this.Event, mixwith, GlobalJxEnviron);\r\n    \r\n    // init hook\r\n    if (mounts && mounts.init) mounts.init.apply(this.Po.data);\r\n\r\n    // event on rerender\r\n    this.Event.on(\"_rerender_\", () => this.render())\r\n    // first render\r\n    this.el.innerHTML = \"\";\r\n    this.render();\r\n    \r\n    const that = this;\r\n    // public api\r\n    return {\r\n        $ele: ele,\r\n        $data: that.Po.data,\r\n        $on(...args){\r\n            that.Event.on.apply(that.Event, args)\r\n        },\r\n        $emit(...args){\r\n            that.Event.emit.apply(that.Event, arguments)\r\n        }\r\n    };\r\n}\r\n\r\nmodule.exports = Poi\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9Qb2kuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9Qb2kuanM/OGI3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFdmVudE9uRWxlID0gcmVxdWlyZShcIi4vZXZlbnRcIik7XHJcbmNvbnN0IGRpZmYgPSByZXF1aXJlKFwiLi9kaWZmL2RpZmZcIik7XHJcbmNvbnN0IHtcclxuICAgIFBvLFxyXG4gICAgZ2VuZXJhdGVTdWJQb1xyXG59ID0gcmVxdWlyZShcIi4vUG9cIik7XHJcblxyXG5mdW5jdGlvbiBJTlRfT0JKKCl7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHd0ZXZlcjogZmFsc2UsIC8vIGFzeW5jIEludGVycnVwdCBmbGFnXHJcbiAgICAgICAgY2xlYXI6IG51bGwgLy8gSW50ZXJydXB0IGNhbGxcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXN5bmNfZGlmZihjdHgpIHtcclxuICAgIGlmIChjdHguY3VycmVudF9yZW5kZXJfSU5UX09CSikge1xyXG4gICAgICAgIC8vIEludGVycnVwdCBjaGVja1xyXG4gICAgICAgIGN0eC5jdXJyZW50X3JlbmRlcl9JTlRfT0JKLnd0ZXZlciA9IHRydWU7XHJcbiAgICAgICAgaWYgKGN0eC5jdXJyZW50X3JlbmRlcl9JTlRfT0JKLmNsZWFyKVxyXG4gICAgICAgICAgICBjdHguY3VycmVudF9yZW5kZXJfSU5UX09CSi5jbGVhcigpXHJcbiAgICAgICAgLy8gdW5ibG9jayBhc3luYyByZW5kZXIgdGFza1xyXG4gICAgICAgIGN0eC5jdXJyZW50X3JlbmRlcl9JTlRfT0JKID0gbmV3IElOVF9PQkooKTtcclxuICAgIH1cclxuICAgIChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgLy8gcmVuZGVyIG1vdW50IGJlZm9yZVxyXG4gICAgICAgIGlmKGN0eC5tb3VudHMgJiYgY3R4Lm1vdW50cy5yZW5kZXJCZWZvcmUpXHJcbiAgICAgICAgICAgIGN0eC5tb3VudHMucmVuZGVyQmVmb3JlLmNhbGwoY3R4LlBvLmRhdGEsIGN0eC5lbClcclxuXHJcbiAgICAgICAgLy8gZGlydHkgY2hlY2tpbmcgbWF5YmVcclxuICAgICAgICBsZXQgcGF0Y2hBcnIgPSBhd2FpdCBkaWZmKGN0eC5lbCwgY3R4LlBvLmFzc2VtYmxlKCksIGN0eC5jdXJyZW50X3JlbmRlcl9JTlRfT0JKKTtcclxuICAgICAgICBjdHguUG8uJGJpbmQocGF0Y2hBcnIpXHJcblxyXG4gICAgICAgIC8vIHJlbmRlciBtb3VudCBhZnRlclxyXG4gICAgICAgIGlmKGN0eC5tb3VudHMgJiYgY3R4Lm1vdW50cy5yZW5kZXJBZnRlciAmJiBwYXRjaEFyci5sZW5ndGggIT0gMClcclxuICAgICAgICAgICAgY3R4Lm1vdW50cy5yZW5kZXJBZnRlci5jYWxsKGN0eC5Qby5kYXRhLCBjdHguZWwpXHJcbiAgICB9KSgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwb2x5T3B0aW9ucyhvcHRpb25zKXtcclxuICAgIC8vIHBvbHkgb2xkIHZlclxyXG4gICAgbGV0IHtcclxuICAgICAgICBlbDpfZWxlLFxyXG4gICAgICAgIGVsZSxcclxuICAgICAgICB0cGwsXHJcbiAgICAgICAgdGVtcGxhdGUsXHJcbiAgICAgICAgZGF0YSxcclxuICAgICAgICB3YXRjaCxcclxuICAgICAgICBzdWJQb3M6Y29tcG9uZW50cyxcclxuICAgICAgICBtaXh3aXRoLFxyXG4gICAgICAgIG1vdW50Om1vdW50cyxcclxuICAgICAgICBtb3VudGVkOl9tb3VudHNcclxuICAgIH0gPSBvcHRpb25zO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBlbDogZWxlIHx8IF9lbGUsXHJcbiAgICAgICAgdHBsOiB0ZW1wbGF0ZSB8fCB0cGwsXHJcbiAgICAgICAgZGF0YSxcclxuICAgICAgICB3YXRjaCxcclxuICAgICAgICBjb21wb25lbnRzLFxyXG4gICAgICAgIG1peHdpdGgsXHJcbiAgICAgICAgbW91bnQ6IG1vdW50cyB8fCBfbW91bnRzXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFBvaShvcHRpb25zLCBHbG9iYWxKeEVudmlyb24pIHtcclxuICAgIC8vIG9wdGlvbnNcclxuICAgIGxldCB7XHJcbiAgICAgICAgZWw6ZWxlLFxyXG4gICAgICAgIHRwbDp0ZW1wbGF0ZSxcclxuICAgICAgICBkYXRhLFxyXG4gICAgICAgIHdhdGNoLFxyXG4gICAgICAgIGNvbXBvbmVudHM6c3ViUG9zLFxyXG4gICAgICAgIG1peHdpdGgsXHJcbiAgICAgICAgbW91bnQ6bW91bnRzXHJcbiAgICB9ID0gcG9seU9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICB0aGlzLmVsID0gZWxlO1xyXG4gICAgLy8gb24sZW1pdFxyXG4gICAgLy8gYmluZCBldmxpc2VudGVyXHJcbiAgICB0aGlzLkV2ZW50ID0gbmV3IEV2ZW50T25FbGUodGhpcy5lbCk7XHJcblxyXG4gICAgLy8gIzQwMSBiYWJlbCBlczUgbGVhZHMgdG8gbWlzdGFrZXNcclxuICAgIFxyXG4gICAgLy8gYXN5bmMgZGlmZiByZW5kZXJcclxuICAgIHRoaXMuY3VycmVudF9yZW5kZXJfSU5UX09CSiA9IG5ldyBJTlRfT0JKKCk7XHJcbiAgICB0aGlzLnJlbmRlciA9ICgpID0+IGFzeW5jX2RpZmYodGhpcyk7XHJcbiAgICBcclxuICAgIC8vIHN1YiBjb21wb25lbnRzID09PT1cXFxcXHJcbiAgICAvLyBsZXQgc3ViUG9pID0gc3ViUG9zID8gZ2VuZXJhdGVTdWJQbyhzdWJQb3MsIHRoaXMuRXZlbnQpIDogdW5kZWZpbmVkXHJcbiAgICAvLyBzdWIgY29tcG9uZW50cyA9PT09XFxcXFxyXG4gICAgLy8gIzQwMiBtb3VudGVkIGluaXQgZnVuY3Rpb25cclxuICAgIGlmIChtaXh3aXRoICYmIG1peHdpdGgubW91bnRzKXtcclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gbWl4d2l0aC5tb3VudHMpIHtcclxuICAgICAgICAgICAgaWYgKGtleSBpbiBtb3VudHMpXHJcbiAgICAgICAgICAgIG1vdW50c1trZXldID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbWl4d2l0aC5tb3VudHNba2V5XS5hcHBseSh0aGlzKVxyXG4gICAgICAgICAgICAgICAgbW91bnRzW2tleV0uYXBwbHkodGhpcylcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZWxzZSBtb3VudHNba2V5XSA9IG1peHdpdGgubW91bnRzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5tb3VudHMgPSBtb3VudHNcclxuICAgIC8vIGluc3RhbmNlXHJcbiAgICB0aGlzLlBvID0gbmV3IFBvKHRlbXBsYXRlLCBkYXRhLCB3YXRjaCwgdGhpcy5FdmVudCwgbWl4d2l0aCwgR2xvYmFsSnhFbnZpcm9uKTtcclxuICAgIFxyXG4gICAgLy8gaW5pdCBob29rXHJcbiAgICBpZiAobW91bnRzICYmIG1vdW50cy5pbml0KSBtb3VudHMuaW5pdC5hcHBseSh0aGlzLlBvLmRhdGEpO1xyXG5cclxuICAgIC8vIGV2ZW50IG9uIHJlcmVuZGVyXHJcbiAgICB0aGlzLkV2ZW50Lm9uKFwiX3JlcmVuZGVyX1wiLCAoKSA9PiB0aGlzLnJlbmRlcigpKVxyXG4gICAgLy8gZmlyc3QgcmVuZGVyXHJcbiAgICB0aGlzLmVsLmlubmVySFRNTCA9IFwiXCI7XHJcbiAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgXHJcbiAgICBjb25zdCB0aGF0ID0gdGhpcztcclxuICAgIC8vIHB1YmxpYyBhcGlcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgJGVsZTogZWxlLFxyXG4gICAgICAgICRkYXRhOiB0aGF0LlBvLmRhdGEsXHJcbiAgICAgICAgJG9uKC4uLmFyZ3Mpe1xyXG4gICAgICAgICAgICB0aGF0LkV2ZW50Lm9uLmFwcGx5KHRoYXQuRXZlbnQsIGFyZ3MpXHJcbiAgICAgICAgfSxcclxuICAgICAgICAkZW1pdCguLi5hcmdzKXtcclxuICAgICAgICAgICAgdGhhdC5FdmVudC5lbWl0LmFwcGx5KHRoYXQuRXZlbnQsIGFyZ3VtZW50cylcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvaVxyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/Poi.js\n");

/***/ }),

/***/ "./src/core/diff/diff.js":
/*!*******************************!*\
  !*** ./src/core/diff/diff.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\r\n    domApi\r\n} = __webpack_require__(/*! ../../domapi */ \"./src/domapi.js\");\r\n\r\nconst {\r\n    frameify\r\n} = __webpack_require__(/*! ../util/frameify.js */ \"./src/core/util/frameify.js\");\r\n\r\nconst {\r\n    LCS,\r\n    NullSeq\r\n} = __webpack_require__(/*! ./lcs */ \"./src/core/diff/lcs.js\");\r\n\r\nconst {\r\n    childClean,\r\n    isSameTree,\r\n    reload_pplan\r\n} = __webpack_require__(/*! ./util */ \"./src/core/diff/util.js\")\r\n\r\n\r\nlet diffDomArr = async (newDomEles, oldDomEles, targetDom, INT_OBJ) => {\r\n    let planArr = [];\r\n    if (oldDomEles.length == 0) {\r\n        for (let nEli in newDomEles) {\r\n            planArr.push({\r\n                option: \"add\",\r\n                ele: newDomEles[nEli],\r\n                upper: targetDom\r\n            })\r\n        }\r\n        return planArr\r\n    }\r\n    if (newDomEles.length == 0) {\r\n        for (let oEli in oldDomEles) {\r\n            planArr.push({\r\n                option: \"delete\",\r\n                ele: oldDomEles[oEli]\r\n            })\r\n        }\r\n        return planArr\r\n    }\r\n    let lcs = new LCS(newDomEles,oldDomEles, domApi.isSame, false)\r\n    // let lcs = new LCS(newDomEles,oldDomEles, domApi.isSameLayerNode, false)\r\n    let _ = await frameify(lcs.genFillMat(), INT_OBJ)\r\n    if(_ == undefined)return planArr // []\r\n    // Interrupt Request\r\n    // react的做法是通过throw一个非error对象，然后在最顶层捕获\r\n    // 这里我没搞这么麻烦(机智)，就回复空return就行\r\n    // 毕竟只是针对单一用例(只有rerender需要协程支持)\r\n    let NonCommon = lcs.getTraceback(false)\r\n    let Common = lcs.getTraceback(true)\r\n\r\n    const isEmpty_lcs = arr => arr.bufA.length == 0 && arr.bufB.length == 0\r\n\r\n    if (isEmpty_lcs(NonCommon) && isEmpty_lcs(Common))return planArr // []\r\n\r\n    // common part\r\n    for (let index = 0; index < Common.bufA.length; index++) {\r\n        const newEle = Common.bufA[index];\r\n        const oldEle = Common.bufB[index];\r\n\r\n        if(newEle.item.classList && !domApi.classListDiff(newEle.item, oldEle.item)){\r\n            planArr.push({\r\n                option: \"classChange\",\r\n                ele: oldEle.item,\r\n                target: newEle.item\r\n            })\r\n        }\r\n\r\n        if(newEle.item.attributes && !domApi.attributesDiff(newEle.item, oldEle.item)){\r\n            planArr.push({\r\n                option: \"attributesChange\",\r\n                ele: oldEle.item,\r\n                target: newEle.item\r\n            })\r\n        }\r\n    }\r\n\r\n    // NonCommon part\r\n    for (let index = 0; index < NonCommon.bufA.length; index++) {\r\n        const newEle = NonCommon.bufA[index];\r\n        const oldEle = NonCommon.bufB[index];\r\n\r\n        if(newEle.item == NullSeq){\r\n            planArr.push({\r\n                option: \"delete\",\r\n                ele: oldEle.item\r\n            })\r\n        }else if(oldEle.item == NullSeq){\r\n            planArr.push({\r\n                option: \"add\",\r\n                ele: newEle.item,\r\n                before: oldDomEles[oldEle.index],\r\n                upper: targetDom\r\n            })\r\n        }else{\r\n            if(isSameTree(oldEle.item,newEle.item))continue\r\n            planArr.push({\r\n                option: \"delete\",\r\n                ele: oldEle.item\r\n            })\r\n            planArr.push({\r\n                option: \"add\",\r\n                ele: newEle.item,\r\n                before: oldEle.item,\r\n                upper: targetDom\r\n            })\r\n        }\r\n    }\r\n    return planArr\r\n}\r\n\r\nlet diffDomtree = async (newChildren, oldTree, INT_OBJ) => {\r\n    newChildren = childClean(newChildren)\r\n    // ----\r\n    let Nchi = [],\r\n        Ochi = [],\r\n        planArr = [],\r\n        NsubTree = [],\r\n        OsubTree = []\r\n    for (let index in newChildren) {\r\n        if (index == \"length\") break;\r\n        let child = newChildren[index]\r\n        if (child.nodeType == 3 && child.textContent.trim().replace(/\\n/g, \"\") == \"\") continue;\r\n        // if (child.childNodes.length == 0) {\r\n        if (child.nodeType == 3 || child.children.length == 0) {\r\n            Nchi.push(child)\r\n        } else {\r\n            NsubTree.push({\r\n                before: newChildren[Number(index) - 1],\r\n                ele: child,\r\n                after: newChildren[Number(index) + 1],\r\n            })\r\n        }\r\n    }\r\n    for (let index in oldTree.childNodes) {\r\n        if (index == \"length\") break;\r\n        let child = oldTree.childNodes[index]\r\n        if (child.nodeType == 3 && child.textContent.trim().replace(/\\n/g, \"\") == \"\") continue;\r\n        // if (child.childNodes.length == 0) {\r\n        if (child.nodeType == 3 || child.children.length == 0) {\r\n            let isgoto = false\r\n            if (child.nodeType != 3) {\r\n                for (let _c of NsubTree) {\r\n                    if (domApi.isSame(_c.ele, child)) {\r\n                        OsubTree.push(child)\r\n                        isgoto = true\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (isgoto) continue\r\n            Ochi.push(child)\r\n        } else {\r\n            OsubTree.push(child)\r\n        }\r\n    }\r\n    if (Ochi.length == 0 && OsubTree.length == 0) {\r\n        for (let index in newChildren) {\r\n            return newChildren.map(v=>({\r\n                option: \"add\",\r\n                ele: v,\r\n                upper: oldTree\r\n            }))\r\n        }\r\n    }\r\n\r\n    let oldT = (()=>{\r\n        let ret = []\r\n        for (const e of oldTree.childNodes) {\r\n            if(e.nodeType == 3 && e.nodeValue.trim() == \"\")\r\n                continue\r\n            ret.push(e)\r\n        }\r\n        return ret\r\n    })()\r\n\r\n    let plan = await diffDomArr(newChildren, oldT, oldTree, INT_OBJ)\r\n\r\n    // 清除被diff了的树\r\n    // 确认不相同的需要diff的树\r\n    // 会移除NsubTree和OsubTree\r\n    // 因为他们不需要更深层的diff了\r\n\r\n    if (plan.length != 0) {\r\n        planArr.push.apply(planArr, plan)\r\n    }\r\n    for (let ni in NsubTree) {\r\n        let ntree = NsubTree[ni].ele\r\n        for (let oi in OsubTree) {\r\n            let otree = OsubTree[oi]\r\n            if (isSameTree(ntree, otree)) {\r\n                // compare\r\n                if (ntree.classList != undefined) {\r\n                    if (!domApi.classListDiff(ntree, otree))\r\n                        planArr.push({\r\n                            option: \"classChange\",\r\n                            ele: otree,\r\n                            target: ntree\r\n                        })\r\n                }\r\n                // attributesDiff\r\n                if (ntree.attributes != undefined) {\r\n                    if (!domApi.attributesDiff(ntree, otree))\r\n                        planArr.push({\r\n                            option: \"attributesChange\",\r\n                            ele: otree,\r\n                            target: ntree\r\n                        })\r\n                }\r\n                // diff ending\r\n                if (planArr.length != 0) {\r\n                    planArr.push.apply(planArr, await diffDomtree(ntree.childNodes, otree, INT_OBJ))\r\n                } else {\r\n                    planArr = await diffDomtree(ntree.childNodes, otree, INT_OBJ)\r\n                }\r\n                delete NsubTree[ni]\r\n                delete OsubTree[oi]\r\n                // NsubTree.splice(ni, 1)\r\n                // OsubTree.splice(oi, 1)\r\n                break\r\n            }\r\n        }\r\n    }\r\n    // -------------\r\n    // 如果能回忆出这里为什么这么写，那么就彻底删除...\r\n    // -------------\r\n    // for (let ni in NsubTree) {\r\n    //     if (NsubTree[ni]) {\r\n    //         if (NsubTree[ni].ele.nodeType == 3 && NsubTree[ni].ele.textContent.trim().replace(/\\n/g, \"\") == \"\") continue;\r\n    //         planArr.push({\r\n    //             option: \"add\",\r\n    //             before: nodeForTree(NsubTree[ni].before, OsubTree),\r\n    //             after: nodeForTree(NsubTree[ni].after, OsubTree),\r\n    //             ele: NsubTree[ni].ele,\r\n    //             upper: oldTree\r\n    //         })\r\n    //     }\r\n    // }\r\n    // for (let ni in OsubTree) {\r\n    //     if (OsubTree[ni]) {\r\n    //         planArr.push({\r\n    //             option: \"delete\",\r\n    //             ele: OsubTree[ni]\r\n    //         })\r\n    //     }\r\n    // }\r\n\r\n    return planArr\r\n}\r\n\r\nlet patch = function* (plan) {\r\n    function patch_on(oldDOM, newDOM) {\r\n        if (oldDOM.nodeType == 3) {\r\n            if (oldDOM.textContent != newDOM.textContent) oldDOM.textContent = newDOM.textContent\r\n        } else {\r\n            oldDOM.classList = newDOM.classList;\r\n            domApi.attributesClone(oldDOM, newDOM);\r\n            if (oldDOM.innerHTML.trim() != newDOM.innerHTML.trim()) oldDOM.innerHTML = newDOM.innerHTML;\r\n        }\r\n    }\r\n    plan = reload_pplan(plan)\r\n    for (let ch of plan) {\r\n        yield void 0;\r\n        switch (ch.option) {\r\n            case \"after\":\r\n                domApi.insertBefore(ch.ele, ch.after)\r\n                ch.upper.loseIndex = true\r\n                break;\r\n            case \"before\":\r\n                domApi.insertAfter(ch.ele, ch.before)\r\n                ch.upper.loseIndex = true\r\n                break;\r\n            case \"append\":\r\n                domApi.append(ch.ele, ch.upper)\r\n                ch.upper.loseIndex = true\r\n                break;\r\n            case \"delete\":\r\n                domApi.remove(ch.ele)\r\n                break;\r\n            case \"classChange\":\r\n                ch.ele.classList = ch.target.classList\r\n                break;\r\n            case \"attributesChange\":\r\n                domApi.attributesClone(ch.ele, ch.target)\r\n                break;\r\n            case \"patch\":\r\n                patch_on(ch.old, ch.new)\r\n                break;\r\n            default:\r\n                void 0;\r\n        }\r\n    }\r\n}\r\nlet diff = async (targetDom, newHtml, INT_OBJ) => {\r\n    let newTreeChilds = domApi.createDomTree(newHtml)\r\n    let patchArr = await diffDomtree(newTreeChilds, targetDom, INT_OBJ)\r\n    // dont int patch func\r\n    if (INT_OBJ && INT_OBJ.wtever) return []\r\n    await frameify(patch(patchArr), INT_OBJ)\r\n    // patch(patchArr)\r\n    return patchArr\r\n}\r\n\r\nmodule.exports = diff\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9kaWZmL2RpZmYuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9kaWZmL2RpZmYuanM/YTQ2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7XHJcbiAgICBkb21BcGlcclxufSA9IHJlcXVpcmUoXCIuLi8uLi9kb21hcGlcIik7XHJcblxyXG5jb25zdCB7XHJcbiAgICBmcmFtZWlmeVxyXG59ID0gcmVxdWlyZSgnLi4vdXRpbC9mcmFtZWlmeS5qcycpO1xyXG5cclxuY29uc3Qge1xyXG4gICAgTENTLFxyXG4gICAgTnVsbFNlcVxyXG59ID0gcmVxdWlyZShcIi4vbGNzXCIpO1xyXG5cclxuY29uc3Qge1xyXG4gICAgY2hpbGRDbGVhbixcclxuICAgIGlzU2FtZVRyZWUsXHJcbiAgICByZWxvYWRfcHBsYW5cclxufSA9IHJlcXVpcmUoXCIuL3V0aWxcIilcclxuXHJcblxyXG5sZXQgZGlmZkRvbUFyciA9IGFzeW5jIChuZXdEb21FbGVzLCBvbGREb21FbGVzLCB0YXJnZXREb20sIElOVF9PQkopID0+IHtcclxuICAgIGxldCBwbGFuQXJyID0gW107XHJcbiAgICBpZiAob2xkRG9tRWxlcy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgIGZvciAobGV0IG5FbGkgaW4gbmV3RG9tRWxlcykge1xyXG4gICAgICAgICAgICBwbGFuQXJyLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uOiBcImFkZFwiLFxyXG4gICAgICAgICAgICAgICAgZWxlOiBuZXdEb21FbGVzW25FbGldLFxyXG4gICAgICAgICAgICAgICAgdXBwZXI6IHRhcmdldERvbVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGxhbkFyclxyXG4gICAgfVxyXG4gICAgaWYgKG5ld0RvbUVsZXMubGVuZ3RoID09IDApIHtcclxuICAgICAgICBmb3IgKGxldCBvRWxpIGluIG9sZERvbUVsZXMpIHtcclxuICAgICAgICAgICAgcGxhbkFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbjogXCJkZWxldGVcIixcclxuICAgICAgICAgICAgICAgIGVsZTogb2xkRG9tRWxlc1tvRWxpXVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGxhbkFyclxyXG4gICAgfVxyXG4gICAgbGV0IGxjcyA9IG5ldyBMQ1MobmV3RG9tRWxlcyxvbGREb21FbGVzLCBkb21BcGkuaXNTYW1lLCBmYWxzZSlcclxuICAgIC8vIGxldCBsY3MgPSBuZXcgTENTKG5ld0RvbUVsZXMsb2xkRG9tRWxlcywgZG9tQXBpLmlzU2FtZUxheWVyTm9kZSwgZmFsc2UpXHJcbiAgICBsZXQgXyA9IGF3YWl0IGZyYW1laWZ5KGxjcy5nZW5GaWxsTWF0KCksIElOVF9PQkopXHJcbiAgICBpZihfID09IHVuZGVmaW5lZClyZXR1cm4gcGxhbkFyciAvLyBbXVxyXG4gICAgLy8gSW50ZXJydXB0IFJlcXVlc3RcclxuICAgIC8vIHJlYWN055qE5YGa5rOV5piv6YCa6L+HdGhyb3fkuIDkuKrpnZ5lcnJvcuWvueixoe+8jOeEtuWQjuWcqOacgOmhtuWxguaNleiOt1xyXG4gICAgLy8g6L+Z6YeM5oiR5rKh5pCe6L+Z5LmI6bq754OmKOacuuaZuinvvIzlsLHlm57lpI3nqbpyZXR1cm7lsLHooYxcclxuICAgIC8vIOavleern+WPquaYr+mSiOWvueWNleS4gOeUqOS+iyjlj6rmnIlyZXJlbmRlcumcgOimgeWNj+eoi+aUr+aMgSlcclxuICAgIGxldCBOb25Db21tb24gPSBsY3MuZ2V0VHJhY2ViYWNrKGZhbHNlKVxyXG4gICAgbGV0IENvbW1vbiA9IGxjcy5nZXRUcmFjZWJhY2sodHJ1ZSlcclxuXHJcbiAgICBjb25zdCBpc0VtcHR5X2xjcyA9IGFyciA9PiBhcnIuYnVmQS5sZW5ndGggPT0gMCAmJiBhcnIuYnVmQi5sZW5ndGggPT0gMFxyXG5cclxuICAgIGlmIChpc0VtcHR5X2xjcyhOb25Db21tb24pICYmIGlzRW1wdHlfbGNzKENvbW1vbikpcmV0dXJuIHBsYW5BcnIgLy8gW11cclxuXHJcbiAgICAvLyBjb21tb24gcGFydFxyXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IENvbW1vbi5idWZBLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgIGNvbnN0IG5ld0VsZSA9IENvbW1vbi5idWZBW2luZGV4XTtcclxuICAgICAgICBjb25zdCBvbGRFbGUgPSBDb21tb24uYnVmQltpbmRleF07XHJcblxyXG4gICAgICAgIGlmKG5ld0VsZS5pdGVtLmNsYXNzTGlzdCAmJiAhZG9tQXBpLmNsYXNzTGlzdERpZmYobmV3RWxlLml0ZW0sIG9sZEVsZS5pdGVtKSl7XHJcbiAgICAgICAgICAgIHBsYW5BcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBvcHRpb246IFwiY2xhc3NDaGFuZ2VcIixcclxuICAgICAgICAgICAgICAgIGVsZTogb2xkRWxlLml0ZW0sXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IG5ld0VsZS5pdGVtXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihuZXdFbGUuaXRlbS5hdHRyaWJ1dGVzICYmICFkb21BcGkuYXR0cmlidXRlc0RpZmYobmV3RWxlLml0ZW0sIG9sZEVsZS5pdGVtKSl7XHJcbiAgICAgICAgICAgIHBsYW5BcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBvcHRpb246IFwiYXR0cmlidXRlc0NoYW5nZVwiLFxyXG4gICAgICAgICAgICAgICAgZWxlOiBvbGRFbGUuaXRlbSxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogbmV3RWxlLml0ZW1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm9uQ29tbW9uIHBhcnRcclxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBOb25Db21tb24uYnVmQS5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICBjb25zdCBuZXdFbGUgPSBOb25Db21tb24uYnVmQVtpbmRleF07XHJcbiAgICAgICAgY29uc3Qgb2xkRWxlID0gTm9uQ29tbW9uLmJ1ZkJbaW5kZXhdO1xyXG5cclxuICAgICAgICBpZihuZXdFbGUuaXRlbSA9PSBOdWxsU2VxKXtcclxuICAgICAgICAgICAgcGxhbkFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbjogXCJkZWxldGVcIixcclxuICAgICAgICAgICAgICAgIGVsZTogb2xkRWxlLml0ZW1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9ZWxzZSBpZihvbGRFbGUuaXRlbSA9PSBOdWxsU2VxKXtcclxuICAgICAgICAgICAgcGxhbkFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbjogXCJhZGRcIixcclxuICAgICAgICAgICAgICAgIGVsZTogbmV3RWxlLml0ZW0sXHJcbiAgICAgICAgICAgICAgICBiZWZvcmU6IG9sZERvbUVsZXNbb2xkRWxlLmluZGV4XSxcclxuICAgICAgICAgICAgICAgIHVwcGVyOiB0YXJnZXREb21cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgaWYoaXNTYW1lVHJlZShvbGRFbGUuaXRlbSxuZXdFbGUuaXRlbSkpY29udGludWVcclxuICAgICAgICAgICAgcGxhbkFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbjogXCJkZWxldGVcIixcclxuICAgICAgICAgICAgICAgIGVsZTogb2xkRWxlLml0ZW1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgcGxhbkFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbjogXCJhZGRcIixcclxuICAgICAgICAgICAgICAgIGVsZTogbmV3RWxlLml0ZW0sXHJcbiAgICAgICAgICAgICAgICBiZWZvcmU6IG9sZEVsZS5pdGVtLFxyXG4gICAgICAgICAgICAgICAgdXBwZXI6IHRhcmdldERvbVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwbGFuQXJyXHJcbn1cclxuXHJcbmxldCBkaWZmRG9tdHJlZSA9IGFzeW5jIChuZXdDaGlsZHJlbiwgb2xkVHJlZSwgSU5UX09CSikgPT4ge1xyXG4gICAgbmV3Q2hpbGRyZW4gPSBjaGlsZENsZWFuKG5ld0NoaWxkcmVuKVxyXG4gICAgLy8gLS0tLVxyXG4gICAgbGV0IE5jaGkgPSBbXSxcclxuICAgICAgICBPY2hpID0gW10sXHJcbiAgICAgICAgcGxhbkFyciA9IFtdLFxyXG4gICAgICAgIE5zdWJUcmVlID0gW10sXHJcbiAgICAgICAgT3N1YlRyZWUgPSBbXVxyXG4gICAgZm9yIChsZXQgaW5kZXggaW4gbmV3Q2hpbGRyZW4pIHtcclxuICAgICAgICBpZiAoaW5kZXggPT0gXCJsZW5ndGhcIikgYnJlYWs7XHJcbiAgICAgICAgbGV0IGNoaWxkID0gbmV3Q2hpbGRyZW5baW5kZXhdXHJcbiAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMgJiYgY2hpbGQudGV4dENvbnRlbnQudHJpbSgpLnJlcGxhY2UoL1xcbi9nLCBcIlwiKSA9PSBcIlwiKSBjb250aW51ZTtcclxuICAgICAgICAvLyBpZiAoY2hpbGQuY2hpbGROb2Rlcy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzIHx8IGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIE5jaGkucHVzaChjaGlsZClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBOc3ViVHJlZS5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGJlZm9yZTogbmV3Q2hpbGRyZW5bTnVtYmVyKGluZGV4KSAtIDFdLFxyXG4gICAgICAgICAgICAgICAgZWxlOiBjaGlsZCxcclxuICAgICAgICAgICAgICAgIGFmdGVyOiBuZXdDaGlsZHJlbltOdW1iZXIoaW5kZXgpICsgMV0sXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaW5kZXggaW4gb2xkVHJlZS5jaGlsZE5vZGVzKSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IFwibGVuZ3RoXCIpIGJyZWFrO1xyXG4gICAgICAgIGxldCBjaGlsZCA9IG9sZFRyZWUuY2hpbGROb2Rlc1tpbmRleF1cclxuICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMyAmJiBjaGlsZC50ZXh0Q29udGVudC50cmltKCkucmVwbGFjZSgvXFxuL2csIFwiXCIpID09IFwiXCIpIGNvbnRpbnVlO1xyXG4gICAgICAgIC8vIGlmIChjaGlsZC5jaGlsZE5vZGVzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMgfHwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgbGV0IGlzZ290byA9IGZhbHNlXHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSAhPSAzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBfYyBvZiBOc3ViVHJlZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21BcGkuaXNTYW1lKF9jLmVsZSwgY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE9zdWJUcmVlLnB1c2goY2hpbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzZ290byA9IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc2dvdG8pIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIE9jaGkucHVzaChjaGlsZClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBPc3ViVHJlZS5wdXNoKGNoaWxkKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChPY2hpLmxlbmd0aCA9PSAwICYmIE9zdWJUcmVlLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaW5kZXggaW4gbmV3Q2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkcmVuLm1hcCh2PT4oe1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uOiBcImFkZFwiLFxyXG4gICAgICAgICAgICAgICAgZWxlOiB2LFxyXG4gICAgICAgICAgICAgICAgdXBwZXI6IG9sZFRyZWVcclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBvbGRUID0gKCgpPT57XHJcbiAgICAgICAgbGV0IHJldCA9IFtdXHJcbiAgICAgICAgZm9yIChjb25zdCBlIG9mIG9sZFRyZWUuY2hpbGROb2Rlcykge1xyXG4gICAgICAgICAgICBpZihlLm5vZGVUeXBlID09IDMgJiYgZS5ub2RlVmFsdWUudHJpbSgpID09IFwiXCIpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgICByZXQucHVzaChlKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0XHJcbiAgICB9KSgpXHJcblxyXG4gICAgbGV0IHBsYW4gPSBhd2FpdCBkaWZmRG9tQXJyKG5ld0NoaWxkcmVuLCBvbGRULCBvbGRUcmVlLCBJTlRfT0JKKVxyXG5cclxuICAgIC8vIOa4hemZpOiiq2RpZmbkuobnmoTmoJFcclxuICAgIC8vIOehruiupOS4jeebuOWQjOeahOmcgOimgWRpZmbnmoTmoJFcclxuICAgIC8vIOS8muenu+mZpE5zdWJUcmVl5ZKMT3N1YlRyZWVcclxuICAgIC8vIOWboOS4uuS7luS7rOS4jemcgOimgeabtOa3seWxgueahGRpZmbkuoZcclxuXHJcbiAgICBpZiAocGxhbi5sZW5ndGggIT0gMCkge1xyXG4gICAgICAgIHBsYW5BcnIucHVzaC5hcHBseShwbGFuQXJyLCBwbGFuKVxyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgbmkgaW4gTnN1YlRyZWUpIHtcclxuICAgICAgICBsZXQgbnRyZWUgPSBOc3ViVHJlZVtuaV0uZWxlXHJcbiAgICAgICAgZm9yIChsZXQgb2kgaW4gT3N1YlRyZWUpIHtcclxuICAgICAgICAgICAgbGV0IG90cmVlID0gT3N1YlRyZWVbb2ldXHJcbiAgICAgICAgICAgIGlmIChpc1NhbWVUcmVlKG50cmVlLCBvdHJlZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBhcmVcclxuICAgICAgICAgICAgICAgIGlmIChudHJlZS5jbGFzc0xpc3QgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb21BcGkuY2xhc3NMaXN0RGlmZihudHJlZSwgb3RyZWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFuQXJyLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uOiBcImNsYXNzQ2hhbmdlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGU6IG90cmVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBudHJlZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gYXR0cmlidXRlc0RpZmZcclxuICAgICAgICAgICAgICAgIGlmIChudHJlZS5hdHRyaWJ1dGVzICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9tQXBpLmF0dHJpYnV0ZXNEaWZmKG50cmVlLCBvdHJlZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYW5BcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb246IFwiYXR0cmlidXRlc0NoYW5nZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlOiBvdHJlZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogbnRyZWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGRpZmYgZW5kaW5nXHJcbiAgICAgICAgICAgICAgICBpZiAocGxhbkFyci5sZW5ndGggIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBsYW5BcnIucHVzaC5hcHBseShwbGFuQXJyLCBhd2FpdCBkaWZmRG9tdHJlZShudHJlZS5jaGlsZE5vZGVzLCBvdHJlZSwgSU5UX09CSikpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBsYW5BcnIgPSBhd2FpdCBkaWZmRG9tdHJlZShudHJlZS5jaGlsZE5vZGVzLCBvdHJlZSwgSU5UX09CSilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBOc3ViVHJlZVtuaV1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBPc3ViVHJlZVtvaV1cclxuICAgICAgICAgICAgICAgIC8vIE5zdWJUcmVlLnNwbGljZShuaSwgMSlcclxuICAgICAgICAgICAgICAgIC8vIE9zdWJUcmVlLnNwbGljZShvaSwgMSlcclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tXHJcbiAgICAvLyDlpoLmnpzog73lm57lv4blh7rov5nph4zkuLrku4DkuYjov5nkuYjlhpnvvIzpgqPkuYjlsLHlvbvlupXliKDpmaQuLi5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS1cclxuICAgIC8vIGZvciAobGV0IG5pIGluIE5zdWJUcmVlKSB7XHJcbiAgICAvLyAgICAgaWYgKE5zdWJUcmVlW25pXSkge1xyXG4gICAgLy8gICAgICAgICBpZiAoTnN1YlRyZWVbbmldLmVsZS5ub2RlVHlwZSA9PSAzICYmIE5zdWJUcmVlW25pXS5lbGUudGV4dENvbnRlbnQudHJpbSgpLnJlcGxhY2UoL1xcbi9nLCBcIlwiKSA9PSBcIlwiKSBjb250aW51ZTtcclxuICAgIC8vICAgICAgICAgcGxhbkFyci5wdXNoKHtcclxuICAgIC8vICAgICAgICAgICAgIG9wdGlvbjogXCJhZGRcIixcclxuICAgIC8vICAgICAgICAgICAgIGJlZm9yZTogbm9kZUZvclRyZWUoTnN1YlRyZWVbbmldLmJlZm9yZSwgT3N1YlRyZWUpLFxyXG4gICAgLy8gICAgICAgICAgICAgYWZ0ZXI6IG5vZGVGb3JUcmVlKE5zdWJUcmVlW25pXS5hZnRlciwgT3N1YlRyZWUpLFxyXG4gICAgLy8gICAgICAgICAgICAgZWxlOiBOc3ViVHJlZVtuaV0uZWxlLFxyXG4gICAgLy8gICAgICAgICAgICAgdXBwZXI6IG9sZFRyZWVcclxuICAgIC8vICAgICAgICAgfSlcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyB9XHJcbiAgICAvLyBmb3IgKGxldCBuaSBpbiBPc3ViVHJlZSkge1xyXG4gICAgLy8gICAgIGlmIChPc3ViVHJlZVtuaV0pIHtcclxuICAgIC8vICAgICAgICAgcGxhbkFyci5wdXNoKHtcclxuICAgIC8vICAgICAgICAgICAgIG9wdGlvbjogXCJkZWxldGVcIixcclxuICAgIC8vICAgICAgICAgICAgIGVsZTogT3N1YlRyZWVbbmldXHJcbiAgICAvLyAgICAgICAgIH0pXHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gfVxyXG5cclxuICAgIHJldHVybiBwbGFuQXJyXHJcbn1cclxuXHJcbmxldCBwYXRjaCA9IGZ1bmN0aW9uKiAocGxhbikge1xyXG4gICAgZnVuY3Rpb24gcGF0Y2hfb24ob2xkRE9NLCBuZXdET00pIHtcclxuICAgICAgICBpZiAob2xkRE9NLm5vZGVUeXBlID09IDMpIHtcclxuICAgICAgICAgICAgaWYgKG9sZERPTS50ZXh0Q29udGVudCAhPSBuZXdET00udGV4dENvbnRlbnQpIG9sZERPTS50ZXh0Q29udGVudCA9IG5ld0RPTS50ZXh0Q29udGVudFxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG9sZERPTS5jbGFzc0xpc3QgPSBuZXdET00uY2xhc3NMaXN0O1xyXG4gICAgICAgICAgICBkb21BcGkuYXR0cmlidXRlc0Nsb25lKG9sZERPTSwgbmV3RE9NKTtcclxuICAgICAgICAgICAgaWYgKG9sZERPTS5pbm5lckhUTUwudHJpbSgpICE9IG5ld0RPTS5pbm5lckhUTUwudHJpbSgpKSBvbGRET00uaW5uZXJIVE1MID0gbmV3RE9NLmlubmVySFRNTDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwbGFuID0gcmVsb2FkX3BwbGFuKHBsYW4pXHJcbiAgICBmb3IgKGxldCBjaCBvZiBwbGFuKSB7XHJcbiAgICAgICAgeWllbGQgdm9pZCAwO1xyXG4gICAgICAgIHN3aXRjaCAoY2gub3B0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJhZnRlclwiOlxyXG4gICAgICAgICAgICAgICAgZG9tQXBpLmluc2VydEJlZm9yZShjaC5lbGUsIGNoLmFmdGVyKVxyXG4gICAgICAgICAgICAgICAgY2gudXBwZXIubG9zZUluZGV4ID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJiZWZvcmVcIjpcclxuICAgICAgICAgICAgICAgIGRvbUFwaS5pbnNlcnRBZnRlcihjaC5lbGUsIGNoLmJlZm9yZSlcclxuICAgICAgICAgICAgICAgIGNoLnVwcGVyLmxvc2VJbmRleCA9IHRydWVcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiYXBwZW5kXCI6XHJcbiAgICAgICAgICAgICAgICBkb21BcGkuYXBwZW5kKGNoLmVsZSwgY2gudXBwZXIpXHJcbiAgICAgICAgICAgICAgICBjaC51cHBlci5sb3NlSW5kZXggPSB0cnVlXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVwiOlxyXG4gICAgICAgICAgICAgICAgZG9tQXBpLnJlbW92ZShjaC5lbGUpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImNsYXNzQ2hhbmdlXCI6XHJcbiAgICAgICAgICAgICAgICBjaC5lbGUuY2xhc3NMaXN0ID0gY2gudGFyZ2V0LmNsYXNzTGlzdFxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJhdHRyaWJ1dGVzQ2hhbmdlXCI6XHJcbiAgICAgICAgICAgICAgICBkb21BcGkuYXR0cmlidXRlc0Nsb25lKGNoLmVsZSwgY2gudGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwYXRjaFwiOlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hfb24oY2gub2xkLCBjaC5uZXcpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHZvaWQgMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxubGV0IGRpZmYgPSBhc3luYyAodGFyZ2V0RG9tLCBuZXdIdG1sLCBJTlRfT0JKKSA9PiB7XHJcbiAgICBsZXQgbmV3VHJlZUNoaWxkcyA9IGRvbUFwaS5jcmVhdGVEb21UcmVlKG5ld0h0bWwpXHJcbiAgICBsZXQgcGF0Y2hBcnIgPSBhd2FpdCBkaWZmRG9tdHJlZShuZXdUcmVlQ2hpbGRzLCB0YXJnZXREb20sIElOVF9PQkopXHJcbiAgICAvLyBkb250IGludCBwYXRjaCBmdW5jXHJcbiAgICBpZiAoSU5UX09CSiAmJiBJTlRfT0JKLnd0ZXZlcikgcmV0dXJuIFtdXHJcbiAgICBhd2FpdCBmcmFtZWlmeShwYXRjaChwYXRjaEFyciksIElOVF9PQkopXHJcbiAgICAvLyBwYXRjaChwYXRjaEFycilcclxuICAgIHJldHVybiBwYXRjaEFyclxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGRpZmYiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/diff/diff.js\n");

/***/ }),

/***/ "./src/core/diff/lcs.js":
/*!******************************!*\
  !*** ./src/core/diff/lcs.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\r\n// refer :\r\n// https://www.ibm.com/developerworks/cn/java/j-seqalign/index.html?mhq=LCS%20dna&mhsrc=ibmsearch_a\r\n\r\nconst NullSeq = Symbol(\"[Null Seq]\")\r\nconst map = o => Array.prototype.map.bind(o)\r\n\r\nclass cell{\r\n    constructor(v,p){\r\n        this.val = v\r\n        this.point = p\r\n        this.row = -1\r\n        this.col = -1\r\n    }\r\n}\r\nconst NullCell = new cell(0,null)\r\n\r\n\r\n// #101 Time complexity: O(arr1.length * arr2.length)\r\nclass LCS{\r\n    constructor(seqA,seqB,compareFn,autoInit=true){\r\n        this.seqA = seqA\r\n        this.seqB = seqB\r\n        this.comp = compareFn || ((a,b)=>a==b)\r\n        this.Mat = []\r\n        this.filled = false\r\n        if(autoInit)this.fillMat()\r\n    }\r\n    fillCell(iA,iB,above,left,leftAbove){\r\n        let cellScore,temp;\r\n        if (this.comp(iA, iB)) {\r\n            cellScore = leftAbove.val + 1\r\n        }else{            \r\n            cellScore = leftAbove.val\r\n        }\r\n        temp = cellScore\r\n        cellScore = Math.max(cellScore,above.val,left.val)\r\n        let point;\r\n        if(cellScore == temp){\r\n            point = leftAbove\r\n        }else if(cellScore == above.val){\r\n            point = above\r\n        }else{\r\n            point = left\r\n        }\r\n        return new cell(cellScore,point);\r\n    }\r\n    genFillMat(){\r\n        let _this = this\r\n        return (function*(){\r\n            let lcsArr = [];\r\n            for (let X in _this.seqA) {\r\n                let rowArr = [],\r\n                    itemA = _this.seqA[X];\r\n                for (let Y in _this.seqB) {\r\n                    yield void 0;\r\n                    let itemB = _this.seqB[Y],\r\n                        left = Y == 0 ? NullCell : rowArr[Y - 1],\r\n                        above = X == 0 ? NullCell : lcsArr[X - 1][Y],\r\n                        leftAbove = Y != 0 && X != 0 ? lcsArr[X - 1][Y - 1] : NullCell;\r\n                    let nxtCell = _this.fillCell(itemA,itemB,above,left,leftAbove)\r\n                    nxtCell.row = X\r\n                    nxtCell.col = Y\r\n                    rowArr.push(nxtCell);\r\n                    nxtCell = undefined;\r\n                }\r\n                lcsArr.push(rowArr);\r\n                rowArr = undefined;\r\n            }\r\n            _this.Mat = lcsArr;\r\n            _this.filled = true;\r\n            return true;\r\n        })()\r\n    }\r\n    fillMat(){\r\n        let lcsArr = [];\r\n        for (let X in this.seqA) {\r\n            let rowArr = [],\r\n                itemA = this.seqA[X];\r\n            for (let Y in this.seqB) {\r\n                let itemB = this.seqB[Y],\r\n                    left = Y == 0 ? NullCell : rowArr[Y - 1],\r\n                    above = X == 0 ? NullCell : lcsArr[X - 1][Y],\r\n                    leftAbove = Y != 0 && X != 0 ? lcsArr[X - 1][Y - 1] : NullCell;\r\n                let nxtCell = this.fillCell(itemA,itemB,above,left,leftAbove)\r\n                nxtCell.row = X\r\n                nxtCell.col = Y\r\n                rowArr.push(nxtCell);\r\n            }\r\n            lcsArr.push(rowArr);\r\n        }\r\n        this.Mat = lcsArr;\r\n        this.filled = true;\r\n    }\r\n    getFinCell(){\r\n        if(this.filled){\r\n            let rMax = this.Mat.length-1\r\n            let cMax = this.Mat[0].length-1\r\n            return this.Mat[rMax][cMax]\r\n        }\r\n    }\r\n    getTraceback(Common=true){\r\n        let cell = this.getFinCell()\r\n        let bufA = [],bufB = []\r\n        let last\r\n        while(cell.point != null){\r\n            let prev = cell.point\r\n            if(cell.row - prev.row == 1 && cell.col - prev.col == 1 && cell.val - prev.val == 1){\r\n                if(Common){\r\n                    // called for LCS\r\n                    bufA.unshift({\r\n                        item: this.seqA[cell.row],\r\n                        index: cell.row\r\n                    })\r\n                    bufB.unshift({\r\n                        item: this.seqB[cell.col],\r\n                        index: cell.col\r\n                    })\r\n                }\r\n            }else{\r\n                if(!Common){\r\n                    let itemA,itemB\r\n                    if(cell.col != prev.col){\r\n                        itemB = this.seqB[cell.col]\r\n                    }else{\r\n                        itemB = NullSeq\r\n                    }\r\n                    bufB.unshift({\r\n                        item: itemB,\r\n                        index: cell.col\r\n                    })\r\n                    if(cell.row != prev.row){\r\n                        itemA = this.seqA[cell.row]\r\n                    }else{\r\n                        itemA = NullSeq\r\n                    }\r\n                    bufA.unshift({\r\n                        item: itemA,\r\n                        index: cell.row\r\n                    })\r\n                }\r\n            }\r\n            last = cell\r\n            cell = prev\r\n        }\r\n        if(!Common){\r\n            // if early closure\r\n            if(last.col != 0 ){\r\n                let Bhat = this.seqB.slice(0,last.col)\r\n                bufB = map(Bhat)((v,i)=>{\r\n                    return {\r\n                        item:v,\r\n                        index:i\r\n                    }\r\n                }).concat(bufB)\r\n                bufA =  map(Bhat)(()=>{\r\n                    return {\r\n                        item:NullSeq,\r\n                        index:-1\r\n                    }\r\n                }).concat(bufA)\r\n            }else if(last.row != 0){\r\n                let Ahat = this.seqA.slice(0,last.row)\r\n                bufA = map(Ahat)((v,i)=>{\r\n                    return {\r\n                        item:v,\r\n                        index:i\r\n                    }\r\n                }).concat(bufA)\r\n                bufB =  map(Ahat)(()=>{\r\n                    return {\r\n                        item:NullSeq,\r\n                        index:-1\r\n                    }\r\n                }).concat(bufB)\r\n            }\r\n        }\r\n        return {bufA,bufB}\r\n    }\r\n    logMat(){\r\n        let content = \"\"\r\n        for (const row of this.Mat) {\r\n            content += row.map(v=>v.val).join(\" , \")\r\n            content += \"\\n\"\r\n        }\r\n        console.log(content)\r\n    }\r\n}\r\n\r\n\r\nmodule.exports = {\r\n    LCS,\r\n    NullSeq\r\n}\r\n\r\n// let l = new LCS(\"ABABAB\",\"ABAAB\")\r\n// let l = new LCS(\"AB\",\"ABCABB\")\r\n// let l = new LCS(\"AB\",\"ABCD\")\r\n// let l = new LCS(\"GCGCAATG\",\"GCCCTAGCG\")\r\n\r\n// l.logMat()\r\n// console.log(l.getTraceback(false))\r\n// console.log(l.getTraceback())\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9kaWZmL2xjcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb3JlL2RpZmYvbGNzLmpzPzI0OTgiXSwic291cmNlc0NvbnRlbnQiOlsiXHJcbi8vIHJlZmVyIDpcclxuLy8gaHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9qYXZhL2otc2VxYWxpZ24vaW5kZXguaHRtbD9taHE9TENTJTIwZG5hJm1oc3JjPWlibXNlYXJjaF9hXHJcblxyXG5jb25zdCBOdWxsU2VxID0gU3ltYm9sKFwiW051bGwgU2VxXVwiKVxyXG5jb25zdCBtYXAgPSBvID0+IEFycmF5LnByb3RvdHlwZS5tYXAuYmluZChvKVxyXG5cclxuY2xhc3MgY2VsbHtcclxuICAgIGNvbnN0cnVjdG9yKHYscCl7XHJcbiAgICAgICAgdGhpcy52YWwgPSB2XHJcbiAgICAgICAgdGhpcy5wb2ludCA9IHBcclxuICAgICAgICB0aGlzLnJvdyA9IC0xXHJcbiAgICAgICAgdGhpcy5jb2wgPSAtMVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IE51bGxDZWxsID0gbmV3IGNlbGwoMCxudWxsKVxyXG5cclxuXHJcbi8vICMxMDEgVGltZSBjb21wbGV4aXR5OiBPKGFycjEubGVuZ3RoICogYXJyMi5sZW5ndGgpXHJcbmNsYXNzIExDU3tcclxuICAgIGNvbnN0cnVjdG9yKHNlcUEsc2VxQixjb21wYXJlRm4sYXV0b0luaXQ9dHJ1ZSl7XHJcbiAgICAgICAgdGhpcy5zZXFBID0gc2VxQVxyXG4gICAgICAgIHRoaXMuc2VxQiA9IHNlcUJcclxuICAgICAgICB0aGlzLmNvbXAgPSBjb21wYXJlRm4gfHwgKChhLGIpPT5hPT1iKVxyXG4gICAgICAgIHRoaXMuTWF0ID0gW11cclxuICAgICAgICB0aGlzLmZpbGxlZCA9IGZhbHNlXHJcbiAgICAgICAgaWYoYXV0b0luaXQpdGhpcy5maWxsTWF0KClcclxuICAgIH1cclxuICAgIGZpbGxDZWxsKGlBLGlCLGFib3ZlLGxlZnQsbGVmdEFib3ZlKXtcclxuICAgICAgICBsZXQgY2VsbFNjb3JlLHRlbXA7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcChpQSwgaUIpKSB7XHJcbiAgICAgICAgICAgIGNlbGxTY29yZSA9IGxlZnRBYm92ZS52YWwgKyAxXHJcbiAgICAgICAgfWVsc2V7ICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNlbGxTY29yZSA9IGxlZnRBYm92ZS52YWxcclxuICAgICAgICB9XHJcbiAgICAgICAgdGVtcCA9IGNlbGxTY29yZVxyXG4gICAgICAgIGNlbGxTY29yZSA9IE1hdGgubWF4KGNlbGxTY29yZSxhYm92ZS52YWwsbGVmdC52YWwpXHJcbiAgICAgICAgbGV0IHBvaW50O1xyXG4gICAgICAgIGlmKGNlbGxTY29yZSA9PSB0ZW1wKXtcclxuICAgICAgICAgICAgcG9pbnQgPSBsZWZ0QWJvdmVcclxuICAgICAgICB9ZWxzZSBpZihjZWxsU2NvcmUgPT0gYWJvdmUudmFsKXtcclxuICAgICAgICAgICAgcG9pbnQgPSBhYm92ZVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBwb2ludCA9IGxlZnRcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjZWxsKGNlbGxTY29yZSxwb2ludCk7XHJcbiAgICB9XHJcbiAgICBnZW5GaWxsTWF0KCl7XHJcbiAgICAgICAgbGV0IF90aGlzID0gdGhpc1xyXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24qKCl7XHJcbiAgICAgICAgICAgIGxldCBsY3NBcnIgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgWCBpbiBfdGhpcy5zZXFBKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcm93QXJyID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbUEgPSBfdGhpcy5zZXFBW1hdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgWSBpbiBfdGhpcy5zZXFCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtQiA9IF90aGlzLnNlcUJbWV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBZID09IDAgPyBOdWxsQ2VsbCA6IHJvd0FycltZIC0gMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3ZlID0gWCA9PSAwID8gTnVsbENlbGwgOiBsY3NBcnJbWCAtIDFdW1ldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QWJvdmUgPSBZICE9IDAgJiYgWCAhPSAwID8gbGNzQXJyW1ggLSAxXVtZIC0gMV0gOiBOdWxsQ2VsbDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbnh0Q2VsbCA9IF90aGlzLmZpbGxDZWxsKGl0ZW1BLGl0ZW1CLGFib3ZlLGxlZnQsbGVmdEFib3ZlKVxyXG4gICAgICAgICAgICAgICAgICAgIG54dENlbGwucm93ID0gWFxyXG4gICAgICAgICAgICAgICAgICAgIG54dENlbGwuY29sID0gWVxyXG4gICAgICAgICAgICAgICAgICAgIHJvd0Fyci5wdXNoKG54dENlbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIG54dENlbGwgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsY3NBcnIucHVzaChyb3dBcnIpO1xyXG4gICAgICAgICAgICAgICAgcm93QXJyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLk1hdCA9IGxjc0FycjtcclxuICAgICAgICAgICAgX3RoaXMuZmlsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSkoKVxyXG4gICAgfVxyXG4gICAgZmlsbE1hdCgpe1xyXG4gICAgICAgIGxldCBsY3NBcnIgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBYIGluIHRoaXMuc2VxQSkge1xyXG4gICAgICAgICAgICBsZXQgcm93QXJyID0gW10sXHJcbiAgICAgICAgICAgICAgICBpdGVtQSA9IHRoaXMuc2VxQVtYXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgWSBpbiB0aGlzLnNlcUIpIHtcclxuICAgICAgICAgICAgICAgIGxldCBpdGVtQiA9IHRoaXMuc2VxQltZXSxcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gWSA9PSAwID8gTnVsbENlbGwgOiByb3dBcnJbWSAtIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIGFib3ZlID0gWCA9PSAwID8gTnVsbENlbGwgOiBsY3NBcnJbWCAtIDFdW1ldLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRBYm92ZSA9IFkgIT0gMCAmJiBYICE9IDAgPyBsY3NBcnJbWCAtIDFdW1kgLSAxXSA6IE51bGxDZWxsO1xyXG4gICAgICAgICAgICAgICAgbGV0IG54dENlbGwgPSB0aGlzLmZpbGxDZWxsKGl0ZW1BLGl0ZW1CLGFib3ZlLGxlZnQsbGVmdEFib3ZlKVxyXG4gICAgICAgICAgICAgICAgbnh0Q2VsbC5yb3cgPSBYXHJcbiAgICAgICAgICAgICAgICBueHRDZWxsLmNvbCA9IFlcclxuICAgICAgICAgICAgICAgIHJvd0Fyci5wdXNoKG54dENlbGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxjc0Fyci5wdXNoKHJvd0Fycik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuTWF0ID0gbGNzQXJyO1xyXG4gICAgICAgIHRoaXMuZmlsbGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGdldEZpbkNlbGwoKXtcclxuICAgICAgICBpZih0aGlzLmZpbGxlZCl7XHJcbiAgICAgICAgICAgIGxldCByTWF4ID0gdGhpcy5NYXQubGVuZ3RoLTFcclxuICAgICAgICAgICAgbGV0IGNNYXggPSB0aGlzLk1hdFswXS5sZW5ndGgtMVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5NYXRbck1heF1bY01heF1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRUcmFjZWJhY2soQ29tbW9uPXRydWUpe1xyXG4gICAgICAgIGxldCBjZWxsID0gdGhpcy5nZXRGaW5DZWxsKClcclxuICAgICAgICBsZXQgYnVmQSA9IFtdLGJ1ZkIgPSBbXVxyXG4gICAgICAgIGxldCBsYXN0XHJcbiAgICAgICAgd2hpbGUoY2VsbC5wb2ludCAhPSBudWxsKXtcclxuICAgICAgICAgICAgbGV0IHByZXYgPSBjZWxsLnBvaW50XHJcbiAgICAgICAgICAgIGlmKGNlbGwucm93IC0gcHJldi5yb3cgPT0gMSAmJiBjZWxsLmNvbCAtIHByZXYuY29sID09IDEgJiYgY2VsbC52YWwgLSBwcmV2LnZhbCA9PSAxKXtcclxuICAgICAgICAgICAgICAgIGlmKENvbW1vbil7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbGVkIGZvciBMQ1NcclxuICAgICAgICAgICAgICAgICAgICBidWZBLnVuc2hpZnQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiB0aGlzLnNlcUFbY2VsbC5yb3ddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogY2VsbC5yb3dcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZkIudW5zaGlmdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IHRoaXMuc2VxQltjZWxsLmNvbF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBjZWxsLmNvbFxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgaWYoIUNvbW1vbil7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW1BLGl0ZW1CXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY2VsbC5jb2wgIT0gcHJldi5jb2wpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtQiA9IHRoaXMuc2VxQltjZWxsLmNvbF1cclxuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUIgPSBOdWxsU2VxXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZkIudW5zaGlmdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW1CLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogY2VsbC5jb2xcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNlbGwucm93ICE9IHByZXYucm93KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUEgPSB0aGlzLnNlcUFbY2VsbC5yb3ddXHJcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1BID0gTnVsbFNlcVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBidWZBLnVuc2hpZnQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtQSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGNlbGwucm93XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXN0ID0gY2VsbFxyXG4gICAgICAgICAgICBjZWxsID0gcHJldlxyXG4gICAgICAgIH1cclxuICAgICAgICBpZighQ29tbW9uKXtcclxuICAgICAgICAgICAgLy8gaWYgZWFybHkgY2xvc3VyZVxyXG4gICAgICAgICAgICBpZihsYXN0LmNvbCAhPSAwICl7XHJcbiAgICAgICAgICAgICAgICBsZXQgQmhhdCA9IHRoaXMuc2VxQi5zbGljZSgwLGxhc3QuY29sKVxyXG4gICAgICAgICAgICAgICAgYnVmQiA9IG1hcChCaGF0KSgodixpKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06dixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6aVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLmNvbmNhdChidWZCKVxyXG4gICAgICAgICAgICAgICAgYnVmQSA9ICBtYXAoQmhhdCkoKCk9PntcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtOk51bGxTZXEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Oi0xXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkuY29uY2F0KGJ1ZkEpXHJcbiAgICAgICAgICAgIH1lbHNlIGlmKGxhc3Qucm93ICE9IDApe1xyXG4gICAgICAgICAgICAgICAgbGV0IEFoYXQgPSB0aGlzLnNlcUEuc2xpY2UoMCxsYXN0LnJvdylcclxuICAgICAgICAgICAgICAgIGJ1ZkEgPSBtYXAoQWhhdCkoKHYsaSk9PntcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtOnYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OmlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KS5jb25jYXQoYnVmQSlcclxuICAgICAgICAgICAgICAgIGJ1ZkIgPSAgbWFwKEFoYXQpKCgpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTpOdWxsU2VxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDotMVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLmNvbmNhdChidWZCKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7YnVmQSxidWZCfVxyXG4gICAgfVxyXG4gICAgbG9nTWF0KCl7XHJcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBcIlwiXHJcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGhpcy5NYXQpIHtcclxuICAgICAgICAgICAgY29udGVudCArPSByb3cubWFwKHY9PnYudmFsKS5qb2luKFwiICwgXCIpXHJcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gXCJcXG5cIlxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmxvZyhjb250ZW50KVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBMQ1MsXHJcbiAgICBOdWxsU2VxXHJcbn1cclxuXHJcbi8vIGxldCBsID0gbmV3IExDUyhcIkFCQUJBQlwiLFwiQUJBQUJcIilcclxuLy8gbGV0IGwgPSBuZXcgTENTKFwiQUJcIixcIkFCQ0FCQlwiKVxyXG4vLyBsZXQgbCA9IG5ldyBMQ1MoXCJBQlwiLFwiQUJDRFwiKVxyXG4vLyBsZXQgbCA9IG5ldyBMQ1MoXCJHQ0dDQUFUR1wiLFwiR0NDQ1RBR0NHXCIpXHJcblxyXG4vLyBsLmxvZ01hdCgpXHJcbi8vIGNvbnNvbGUubG9nKGwuZ2V0VHJhY2ViYWNrKGZhbHNlKSlcclxuLy8gY29uc29sZS5sb2cobC5nZXRUcmFjZWJhY2soKSlcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/diff/lcs.js\n");

/***/ }),

/***/ "./src/core/diff/util.js":
/*!*******************************!*\
  !*** ./src/core/diff/util.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\r\n    childClean,\r\n    isSameTree,\r\n    reload_pplan\r\n}\r\n\r\nfunction childClean(chs) {\r\n    const re = /^\\s+$/\r\n    let res = []\r\n    for (const c of chs) {\r\n        if (c.nodeType == 3 && re.test(c.data)) continue\r\n        else res.push(c)\r\n    }\r\n    return res\r\n}\r\n\r\nfunction mergePlans(ps, prop) {\r\n    let prev = null,\r\n        ret = [];\r\n    for (const p of ps) {\r\n        if (prev && p[prop] == prev[prop]) {\r\n            // concat each ,if target is same dom\r\n            let o = {\r\n                option: p.option,\r\n                ele: p.ele,\r\n                upper: p.upper\r\n            }\r\n            o[prop] = prev.ele\r\n            ret.push(o)\r\n        } else {\r\n            ret.push(p)\r\n        }\r\n        prev = p\r\n    }\r\n    return ret;\r\n}\r\n\r\n\r\nconst toarr = o => Array.prototype.slice.call(o)\r\nconst layer_num = ele => ele.parentNode ? toarr(ele.parentNode.children).indexOf(ele) : 0\r\n\r\nfunction isSameTree(ele1, ele2) {\r\n    if (ele1.nodeType == 1 && ele1.children.length == 0) return false\r\n    return (\r\n        ele1.nodeName == ele2.nodeName &&\r\n        ele1.nodeType == ele2.nodeType &&\r\n        layer_num(ele1) == layer_num(ele2)\r\n    )\r\n}\r\n\r\nfunction reload_pplan(plan) {\r\n    let targetHost = new WeakMap()\r\n    for (const p of plan) {\r\n        switch (p.option) {\r\n            case \"classChange\":\r\n            case \"attributesChange\":\r\n                targetHost.set(p.target, p.ele)\r\n                break;\r\n            case \"patch\":\r\n                targetHost.set(p.new, p.old)\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n\r\n    let ret = [],\r\n        dels = [],\r\n        af = [],\r\n        bf = [],\r\n        ap = []\r\n    for (const p of plan) {\r\n        switch (p.option) {\r\n            case \"add\":\r\n                if (p.before != undefined) {\r\n                    bf.push({\r\n                        option: \"before\",\r\n                        ele: p.ele,\r\n                        before: targetHost.get(p.before) || p.before,\r\n                        upper: p.upper\r\n                    })\r\n                } else if (p.after != undefined) {\r\n                    af.push({\r\n                        option: \"after\",\r\n                        ele: p.ele,\r\n                        after: targetHost.get(p.after) || p.after,\r\n                        upper: p.upper\r\n                    })\r\n                } else {\r\n                    ap.push({\r\n                        option: \"append\",\r\n                        ele: p.ele,\r\n                        upper: targetHost.get(p.upper) || p.upper\r\n                    })\r\n                }\r\n                break;\r\n            case \"delete\":\r\n                dels.push(p)\r\n                break;\r\n            default:\r\n                ret.push(p)\r\n                break;\r\n        }\r\n    }\r\n    af = mergePlans(af.reverse(), \"after\")\r\n    bf = mergePlans(bf, \"before\")\r\n    return [].concat(ap, bf, af, ret, dels)\r\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9kaWZmL3V0aWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9kaWZmL3V0aWwuanM/ZmY5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGNoaWxkQ2xlYW4sXHJcbiAgICBpc1NhbWVUcmVlLFxyXG4gICAgcmVsb2FkX3BwbGFuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoaWxkQ2xlYW4oY2hzKSB7XHJcbiAgICBjb25zdCByZSA9IC9eXFxzKyQvXHJcbiAgICBsZXQgcmVzID0gW11cclxuICAgIGZvciAoY29uc3QgYyBvZiBjaHMpIHtcclxuICAgICAgICBpZiAoYy5ub2RlVHlwZSA9PSAzICYmIHJlLnRlc3QoYy5kYXRhKSkgY29udGludWVcclxuICAgICAgICBlbHNlIHJlcy5wdXNoKGMpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1lcmdlUGxhbnMocHMsIHByb3ApIHtcclxuICAgIGxldCBwcmV2ID0gbnVsbCxcclxuICAgICAgICByZXQgPSBbXTtcclxuICAgIGZvciAoY29uc3QgcCBvZiBwcykge1xyXG4gICAgICAgIGlmIChwcmV2ICYmIHBbcHJvcF0gPT0gcHJldltwcm9wXSkge1xyXG4gICAgICAgICAgICAvLyBjb25jYXQgZWFjaCAsaWYgdGFyZ2V0IGlzIHNhbWUgZG9tXHJcbiAgICAgICAgICAgIGxldCBvID0ge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uOiBwLm9wdGlvbixcclxuICAgICAgICAgICAgICAgIGVsZTogcC5lbGUsXHJcbiAgICAgICAgICAgICAgICB1cHBlcjogcC51cHBlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9bcHJvcF0gPSBwcmV2LmVsZVxyXG4gICAgICAgICAgICByZXQucHVzaChvKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldC5wdXNoKHApXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXYgPSBwXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG5cclxuY29uc3QgdG9hcnIgPSBvID0+IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG8pXHJcbmNvbnN0IGxheWVyX251bSA9IGVsZSA9PiBlbGUucGFyZW50Tm9kZSA/IHRvYXJyKGVsZS5wYXJlbnROb2RlLmNoaWxkcmVuKS5pbmRleE9mKGVsZSkgOiAwXHJcblxyXG5mdW5jdGlvbiBpc1NhbWVUcmVlKGVsZTEsIGVsZTIpIHtcclxuICAgIGlmIChlbGUxLm5vZGVUeXBlID09IDEgJiYgZWxlMS5jaGlsZHJlbi5sZW5ndGggPT0gMCkgcmV0dXJuIGZhbHNlXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIGVsZTEubm9kZU5hbWUgPT0gZWxlMi5ub2RlTmFtZSAmJlxyXG4gICAgICAgIGVsZTEubm9kZVR5cGUgPT0gZWxlMi5ub2RlVHlwZSAmJlxyXG4gICAgICAgIGxheWVyX251bShlbGUxKSA9PSBsYXllcl9udW0oZWxlMilcclxuICAgIClcclxufVxyXG5cclxuZnVuY3Rpb24gcmVsb2FkX3BwbGFuKHBsYW4pIHtcclxuICAgIGxldCB0YXJnZXRIb3N0ID0gbmV3IFdlYWtNYXAoKVxyXG4gICAgZm9yIChjb25zdCBwIG9mIHBsYW4pIHtcclxuICAgICAgICBzd2l0Y2ggKHAub3B0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJjbGFzc0NoYW5nZVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiYXR0cmlidXRlc0NoYW5nZVwiOlxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0SG9zdC5zZXQocC50YXJnZXQsIHAuZWxlKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwYXRjaFwiOlxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0SG9zdC5zZXQocC5uZXcsIHAub2xkKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGxldCByZXQgPSBbXSxcclxuICAgICAgICBkZWxzID0gW10sXHJcbiAgICAgICAgYWYgPSBbXSxcclxuICAgICAgICBiZiA9IFtdLFxyXG4gICAgICAgIGFwID0gW11cclxuICAgIGZvciAoY29uc3QgcCBvZiBwbGFuKSB7XHJcbiAgICAgICAgc3dpdGNoIChwLm9wdGlvbikge1xyXG4gICAgICAgICAgICBjYXNlIFwiYWRkXCI6XHJcbiAgICAgICAgICAgICAgICBpZiAocC5iZWZvcmUgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmYucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbjogXCJiZWZvcmVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlOiBwLmVsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlOiB0YXJnZXRIb3N0LmdldChwLmJlZm9yZSkgfHwgcC5iZWZvcmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyOiBwLnVwcGVyXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocC5hZnRlciAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZi5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uOiBcImFmdGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZTogcC5lbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyOiB0YXJnZXRIb3N0LmdldChwLmFmdGVyKSB8fCBwLmFmdGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cHBlcjogcC51cHBlclxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFwLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb246IFwiYXBwZW5kXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZTogcC5lbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyOiB0YXJnZXRIb3N0LmdldChwLnVwcGVyKSB8fCBwLnVwcGVyXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZGVsZXRlXCI6XHJcbiAgICAgICAgICAgICAgICBkZWxzLnB1c2gocClcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0LnB1c2gocClcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFmID0gbWVyZ2VQbGFucyhhZi5yZXZlcnNlKCksIFwiYWZ0ZXJcIilcclxuICAgIGJmID0gbWVyZ2VQbGFucyhiZiwgXCJiZWZvcmVcIilcclxuICAgIHJldHVybiBbXS5jb25jYXQoYXAsIGJmLCBhZiwgcmV0LCBkZWxzKVxyXG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/diff/util.js\n");

/***/ }),

/***/ "./src/core/event.js":
/*!***************************!*\
  !*** ./src/core/event.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// const {\r\n//     ev_supList\r\n// } = require(\"./util/util\");\r\n\r\nclass Event {\r\n    constructor() {\r\n        this.subscribe = {}\r\n    }\r\n    on(channel, fn) {\r\n        let old = this.subscribe[channel] ? this.subscribe[channel].func : undefined;\r\n        if (old == undefined) this.subscribe[channel] = {}\r\n        this.subscribe[channel].func = function(_args) {\r\n            if (typeof old == \"function\") {\r\n                old(_args);\r\n            }\r\n            fn(_args);\r\n        }\r\n    }\r\n    emit(channel, _args) {\r\n        if (this.subscribe[channel] !== undefined) {\r\n            if (typeof this.subscribe[channel].func == \"function\") {\r\n                this.subscribe[channel].func(_args);\r\n            }\r\n        }\r\n    }\r\n    clear() {\r\n        this.subscribe = {};\r\n    }\r\n}\r\nclass EventOnEle extends Event {\r\n    constructor(ele) {\r\n        super();\r\n        this.el = ele;\r\n        // this.__init_nativeEv();\r\n        this.loopUp = []\r\n    }\r\n    // __init_nativeEv() {\r\n    //     ev_supList.forEach(evName => {\r\n    //         let fn_body = e => this.emit(evName, e)\r\n    //         this.el.addEventListener(evName, fn_body, true)\r\n    //     })\r\n    // }\r\n    addEventLookUp(evName){\r\n        if(this.loopUp.indexOf(evName) == -1){\r\n            this.el.addEventListener(evName, e => this.emit(evName, e), true)\r\n            this.loopUp.push(evName)\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = EventOnEle;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9ldmVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb3JlL2V2ZW50LmpzPzlkMGYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29uc3Qge1xyXG4vLyAgICAgZXZfc3VwTGlzdFxyXG4vLyB9ID0gcmVxdWlyZShcIi4vdXRpbC91dGlsXCIpO1xyXG5cclxuY2xhc3MgRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUgPSB7fVxyXG4gICAgfVxyXG4gICAgb24oY2hhbm5lbCwgZm4pIHtcclxuICAgICAgICBsZXQgb2xkID0gdGhpcy5zdWJzY3JpYmVbY2hhbm5lbF0gPyB0aGlzLnN1YnNjcmliZVtjaGFubmVsXS5mdW5jIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmIChvbGQgPT0gdW5kZWZpbmVkKSB0aGlzLnN1YnNjcmliZVtjaGFubmVsXSA9IHt9XHJcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVbY2hhbm5lbF0uZnVuYyA9IGZ1bmN0aW9uKF9hcmdzKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2xkID09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgb2xkKF9hcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmbihfYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZW1pdChjaGFubmVsLCBfYXJncykge1xyXG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmliZVtjaGFubmVsXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdWJzY3JpYmVbY2hhbm5lbF0uZnVuYyA9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlW2NoYW5uZWxdLmZ1bmMoX2FyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUgPSB7fTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBFdmVudE9uRWxlIGV4dGVuZHMgRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoZWxlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmVsID0gZWxlO1xyXG4gICAgICAgIC8vIHRoaXMuX19pbml0X25hdGl2ZUV2KCk7XHJcbiAgICAgICAgdGhpcy5sb29wVXAgPSBbXVxyXG4gICAgfVxyXG4gICAgLy8gX19pbml0X25hdGl2ZUV2KCkge1xyXG4gICAgLy8gICAgIGV2X3N1cExpc3QuZm9yRWFjaChldk5hbWUgPT4ge1xyXG4gICAgLy8gICAgICAgICBsZXQgZm5fYm9keSA9IGUgPT4gdGhpcy5lbWl0KGV2TmFtZSwgZSlcclxuICAgIC8vICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKGV2TmFtZSwgZm5fYm9keSwgdHJ1ZSlcclxuICAgIC8vICAgICB9KVxyXG4gICAgLy8gfVxyXG4gICAgYWRkRXZlbnRMb29rVXAoZXZOYW1lKXtcclxuICAgICAgICBpZih0aGlzLmxvb3BVcC5pbmRleE9mKGV2TmFtZSkgPT0gLTEpe1xyXG4gICAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoZXZOYW1lLCBlID0+IHRoaXMuZW1pdChldk5hbWUsIGUpLCB0cnVlKVxyXG4gICAgICAgICAgICB0aGlzLmxvb3BVcC5wdXNoKGV2TmFtZSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRPbkVsZTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/event.js\n");

/***/ }),

/***/ "./src/core/jx.js":
/*!************************!*\
  !*** ./src/core/jx.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const re = /{{([\\s\\S]+?)}}/\r\n\r\nfunction loadJx(xx) {\r\n    let stack = [],\r\n        e;\r\n\r\n    function inner(sx) {\r\n        if (sx.length == 0) return void 0;\r\n        if (!(e = re.exec(sx))) stack.push([0, sx])\r\n        else {\r\n            if (e.index != 1) stack.push([0, sx.slice(0, e.index)])\r\n            if (e[0][2] == \"=\") stack.push([2, e[1].slice(1)])\r\n            else if (e[0][2] == \"$\") stack.push([3, e[1].slice(1)])\r\n            else if (e[0][2] == \"*\") stack.push([4, e[1].slice(1)])\r\n            else stack.push([1, e[1]])\r\n            inner(sx.slice(e.index + e[0].length))\r\n        }\r\n    }\r\n    inner(xx)\r\n    return stack\r\n}\r\n\r\nfunction compile(stack) {\r\n    let code = \"\"\r\n    for (const row of stack) {\r\n        let content = row[1].trim()\r\n        switch (row[0]) {\r\n            case 0:\r\n                code += `yield \\`${content}\\`;`\r\n                break;\r\n            case 1: // command\r\n                code += `${content}\\n`\r\n                break;\r\n            case 2: // = get values\r\n                code += `yield ${content};`\r\n                break;\r\n            case 3: // $ tpl called\r\n                code += `yield $${content};`\r\n                break;\r\n            case 4: // * callee\r\n                code += `yield* arguments.callee(${content});`\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    return eval(`(function*(obj){with(obj){\\n${code}\\n}})`)\r\n}\r\n\r\nfunction compileJx(jx_text) {\r\n    return compile(loadJx(jx_text))\r\n}\r\n\r\nfunction tplLoader(tpl, data) {\r\n    return [...tpl(data)].join(\"\")\r\n}\r\n\r\nfunction __Jx(jx_text, data) {\r\n    var tpl = compileJx(jx_text)\r\n    return tplLoader(tpl, data)\r\n}\r\n\r\nclass Jx {\r\n    constructor() {\r\n        this.mods = {}\r\n    }\r\n    mod(name, jx_text) {\r\n        this.mods[name] = d => tplLoader(compileJx(jx_text), d)\r\n    }\r\n    __prx$(o) {\r\n        let that = this\r\n        return new Proxy(o, {\r\n            get(o, prop) {\r\n                if (prop == Symbol.unscopables) return undefined\r\n                if (prop[0] == \"$\" && prop.slice(1) in that.mods)\r\n                    return d => that.mods[prop.slice(1)](that.__prx$(d))\r\n                return o[prop]\r\n            },\r\n            has(o, prop) {\r\n                if (prop.slice(1) in that.mods || prop in o) return true\r\n                return false\r\n            }\r\n        })\r\n    }\r\n    compile(jx_text, data) {\r\n        return __Jx(jx_text, this.__prx$(data))\r\n    }\r\n    dumpTpl(tpl, data) {\r\n        return tplLoader(tpl, this.__prx$(data))\r\n    }\r\n}\r\n\r\nclass JxTpl {\r\n    constructor(jx_text, JxGlobal) {\r\n        this.tpl = compileJx(jx_text)\r\n        this._jx = JxGlobal\r\n    }\r\n    joint(data) {\r\n        return this._jx.dumpTpl(this.tpl, data)\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    Jx,\r\n    JxTpl\r\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9qeC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb3JlL2p4LmpzPzAyZGEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcmUgPSAve3soW1xcc1xcU10rPyl9fS9cclxuXHJcbmZ1bmN0aW9uIGxvYWRKeCh4eCkge1xyXG4gICAgbGV0IHN0YWNrID0gW10sXHJcbiAgICAgICAgZTtcclxuXHJcbiAgICBmdW5jdGlvbiBpbm5lcihzeCkge1xyXG4gICAgICAgIGlmIChzeC5sZW5ndGggPT0gMCkgcmV0dXJuIHZvaWQgMDtcclxuICAgICAgICBpZiAoIShlID0gcmUuZXhlYyhzeCkpKSBzdGFjay5wdXNoKFswLCBzeF0pXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4ICE9IDEpIHN0YWNrLnB1c2goWzAsIHN4LnNsaWNlKDAsIGUuaW5kZXgpXSlcclxuICAgICAgICAgICAgaWYgKGVbMF1bMl0gPT0gXCI9XCIpIHN0YWNrLnB1c2goWzIsIGVbMV0uc2xpY2UoMSldKVxyXG4gICAgICAgICAgICBlbHNlIGlmIChlWzBdWzJdID09IFwiJFwiKSBzdGFjay5wdXNoKFszLCBlWzFdLnNsaWNlKDEpXSlcclxuICAgICAgICAgICAgZWxzZSBpZiAoZVswXVsyXSA9PSBcIipcIikgc3RhY2sucHVzaChbNCwgZVsxXS5zbGljZSgxKV0pXHJcbiAgICAgICAgICAgIGVsc2Ugc3RhY2sucHVzaChbMSwgZVsxXV0pXHJcbiAgICAgICAgICAgIGlubmVyKHN4LnNsaWNlKGUuaW5kZXggKyBlWzBdLmxlbmd0aCkpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaW5uZXIoeHgpXHJcbiAgICByZXR1cm4gc3RhY2tcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcGlsZShzdGFjaykge1xyXG4gICAgbGV0IGNvZGUgPSBcIlwiXHJcbiAgICBmb3IgKGNvbnN0IHJvdyBvZiBzdGFjaykge1xyXG4gICAgICAgIGxldCBjb250ZW50ID0gcm93WzFdLnRyaW0oKVxyXG4gICAgICAgIHN3aXRjaCAocm93WzBdKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIGNvZGUgKz0gYHlpZWxkIFxcYCR7Y29udGVudH1cXGA7YFxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTogLy8gY29tbWFuZFxyXG4gICAgICAgICAgICAgICAgY29kZSArPSBgJHtjb250ZW50fVxcbmBcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6IC8vID0gZ2V0IHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgY29kZSArPSBgeWllbGQgJHtjb250ZW50fTtgXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOiAvLyAkIHRwbCBjYWxsZWRcclxuICAgICAgICAgICAgICAgIGNvZGUgKz0gYHlpZWxkICQke2NvbnRlbnR9O2BcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDQ6IC8vICogY2FsbGVlXHJcbiAgICAgICAgICAgICAgICBjb2RlICs9IGB5aWVsZCogYXJndW1lbnRzLmNhbGxlZSgke2NvbnRlbnR9KTtgXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZhbChgKGZ1bmN0aW9uKihvYmope3dpdGgob2JqKXtcXG4ke2NvZGV9XFxufX0pYClcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcGlsZUp4KGp4X3RleHQpIHtcclxuICAgIHJldHVybiBjb21waWxlKGxvYWRKeChqeF90ZXh0KSlcclxufVxyXG5cclxuZnVuY3Rpb24gdHBsTG9hZGVyKHRwbCwgZGF0YSkge1xyXG4gICAgcmV0dXJuIFsuLi50cGwoZGF0YSldLmpvaW4oXCJcIilcclxufVxyXG5cclxuZnVuY3Rpb24gX19KeChqeF90ZXh0LCBkYXRhKSB7XHJcbiAgICB2YXIgdHBsID0gY29tcGlsZUp4KGp4X3RleHQpXHJcbiAgICByZXR1cm4gdHBsTG9hZGVyKHRwbCwgZGF0YSlcclxufVxyXG5cclxuY2xhc3MgSngge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5tb2RzID0ge31cclxuICAgIH1cclxuICAgIG1vZChuYW1lLCBqeF90ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5tb2RzW25hbWVdID0gZCA9PiB0cGxMb2FkZXIoY29tcGlsZUp4KGp4X3RleHQpLCBkKVxyXG4gICAgfVxyXG4gICAgX19wcngkKG8pIHtcclxuICAgICAgICBsZXQgdGhhdCA9IHRoaXNcclxuICAgICAgICByZXR1cm4gbmV3IFByb3h5KG8sIHtcclxuICAgICAgICAgICAgZ2V0KG8sIHByb3ApIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wID09IFN5bWJvbC51bnNjb3BhYmxlcykgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgaWYgKHByb3BbMF0gPT0gXCIkXCIgJiYgcHJvcC5zbGljZSgxKSBpbiB0aGF0Lm1vZHMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQgPT4gdGhhdC5tb2RzW3Byb3Auc2xpY2UoMSldKHRoYXQuX19wcngkKGQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9bcHJvcF1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGFzKG8sIHByb3ApIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wLnNsaWNlKDEpIGluIHRoYXQubW9kcyB8fCBwcm9wIGluIG8pIHJldHVybiB0cnVlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbiAgICBjb21waWxlKGp4X3RleHQsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gX19KeChqeF90ZXh0LCB0aGlzLl9fcHJ4JChkYXRhKSlcclxuICAgIH1cclxuICAgIGR1bXBUcGwodHBsLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRwbExvYWRlcih0cGwsIHRoaXMuX19wcngkKGRhdGEpKVxyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBKeFRwbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihqeF90ZXh0LCBKeEdsb2JhbCkge1xyXG4gICAgICAgIHRoaXMudHBsID0gY29tcGlsZUp4KGp4X3RleHQpXHJcbiAgICAgICAgdGhpcy5fanggPSBKeEdsb2JhbFxyXG4gICAgfVxyXG4gICAgam9pbnQoZGF0YSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9qeC5kdW1wVHBsKHRoaXMudHBsLCBkYXRhKVxyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEp4LFxyXG4gICAgSnhUcGxcclxufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/jx.js\n");

/***/ }),

/***/ "./src/core/util/JsVm.js":
/*!*******************************!*\
  !*** ./src/core/util/JsVm.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("let extend = (o, n) => {\r\n    for (var p in n) {\r\n        if (n.hasOwnProperty(p) && (!o.hasOwnProperty(p)))\r\n            o[p] = n[p];\r\n    }\r\n};\r\nlet JSvm = (code, sandbox) => {\r\n    let rep_non_print = (text) => {\r\n        return text.replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\").replace(\"\\f\", \"\\\\f\").replace(\"\\v\", \"\\\\v\").replace(\"\\r\", \"\\\\r\")\r\n    }\r\n    sandbox = sandbox || {};\r\n    const fn = new Function('sandbox', `with(sandbox){${rep_non_print(code)}}`);\r\n    const _proxy = new Proxy(sandbox, {\r\n        has(target, key) {\r\n            return true;\r\n        }\r\n    });\r\n    return fn(_proxy);\r\n};\r\nlet multiCode2Tuple = (code) => {\r\n    return code.replace(/(^|;)return /g, \"\").replace(/([\"'])(.+?)(;)(.+?)\\1/g, \"$1$2$3#$4$1\").split(/;(?!#)/g).join(\",\").replace(\";#\", \";\");\r\n};\r\n\r\nclass VmError extends Error {\r\n    constructor(message) {\r\n        super();\r\n        Error.captureStackTrace(this, this.constructor);\r\n        this.message = message || 'Undefined error';\r\n        this.name = 'VmError';\r\n    }\r\n}\r\nlet JSafeVmWithBlackList = (code, sandbox, mixBlack) => {\r\n    let blacklist = [\"eval\", \"Function\"]\r\n    mixBlack = mixBlack ? mixBlack.push.apply(mixBlack, blacklist) : blacklist\r\n    let rep_non_print = (text) => {\r\n        return text.replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\").replace(\"\\f\", \"\\\\f\").replace(\"\\v\", \"\\\\v\").replace(\"\\r\", \"\\\\r\")\r\n    }\r\n    sandbox = sandbox || {};\r\n    const fn = new Function('sandbox', `with(sandbox){${rep_non_print(code)}}`);\r\n    const _proxy = new Proxy(sandbox, {\r\n        has(target, key) {\r\n            if(mixBlack.indexOf(key) != -1){\r\n                return true\r\n            }\r\n            return key in target;\r\n        }\r\n    });\r\n    return fn(_proxy);\r\n};\r\nlet micVm = (code, data) => {\r\n    let result;\r\n    // try {\r\n    result = new Function('obj', \"with(obj){\" + code + \"}\").apply(data, [data])\r\n    // } catch (err) {\r\n    //     console.error(\"'\" + err.message + \"'\", \" in \\n\\nCode:\\n\", code.replace(/;/g, \";\\n\").replace(/({|})/g, \"$1\\n\"));\r\n    // }\r\n    return result;\r\n}\r\n\r\nmodule.exports = {\r\n    safe: JSafeVmWithBlackList,\r\n    vm: JSvm,\r\n    micVm: micVm\r\n};\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS91dGlsL0pzVm0uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29yZS91dGlsL0pzVm0uanM/MDA1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgZXh0ZW5kID0gKG8sIG4pID0+IHtcclxuICAgIGZvciAodmFyIHAgaW4gbikge1xyXG4gICAgICAgIGlmIChuLmhhc093blByb3BlcnR5KHApICYmICghby5oYXNPd25Qcm9wZXJ0eShwKSkpXHJcbiAgICAgICAgICAgIG9bcF0gPSBuW3BdO1xyXG4gICAgfVxyXG59O1xyXG5sZXQgSlN2bSA9IChjb2RlLCBzYW5kYm94KSA9PiB7XHJcbiAgICBsZXQgcmVwX25vbl9wcmludCA9ICh0ZXh0KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShcIlxcblwiLCBcIlxcXFxuXCIpLnJlcGxhY2UoXCJcXHRcIiwgXCJcXFxcdFwiKS5yZXBsYWNlKFwiXFxmXCIsIFwiXFxcXGZcIikucmVwbGFjZShcIlxcdlwiLCBcIlxcXFx2XCIpLnJlcGxhY2UoXCJcXHJcIiwgXCJcXFxcclwiKVxyXG4gICAgfVxyXG4gICAgc2FuZGJveCA9IHNhbmRib3ggfHwge307XHJcbiAgICBjb25zdCBmbiA9IG5ldyBGdW5jdGlvbignc2FuZGJveCcsIGB3aXRoKHNhbmRib3gpeyR7cmVwX25vbl9wcmludChjb2RlKX19YCk7XHJcbiAgICBjb25zdCBfcHJveHkgPSBuZXcgUHJveHkoc2FuZGJveCwge1xyXG4gICAgICAgIGhhcyh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBmbihfcHJveHkpO1xyXG59O1xyXG5sZXQgbXVsdGlDb2RlMlR1cGxlID0gKGNvZGUpID0+IHtcclxuICAgIHJldHVybiBjb2RlLnJlcGxhY2UoLyhefDspcmV0dXJuIC9nLCBcIlwiKS5yZXBsYWNlKC8oW1wiJ10pKC4rPykoOykoLis/KVxcMS9nLCBcIiQxJDIkMyMkNCQxXCIpLnNwbGl0KC87KD8hIykvZykuam9pbihcIixcIikucmVwbGFjZShcIjsjXCIsIFwiO1wiKTtcclxufTtcclxuXHJcbmNsYXNzIFZtRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdVbmRlZmluZWQgZXJyb3InO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdWbUVycm9yJztcclxuICAgIH1cclxufVxyXG5sZXQgSlNhZmVWbVdpdGhCbGFja0xpc3QgPSAoY29kZSwgc2FuZGJveCwgbWl4QmxhY2spID0+IHtcclxuICAgIGxldCBibGFja2xpc3QgPSBbXCJldmFsXCIsIFwiRnVuY3Rpb25cIl1cclxuICAgIG1peEJsYWNrID0gbWl4QmxhY2sgPyBtaXhCbGFjay5wdXNoLmFwcGx5KG1peEJsYWNrLCBibGFja2xpc3QpIDogYmxhY2tsaXN0XHJcbiAgICBsZXQgcmVwX25vbl9wcmludCA9ICh0ZXh0KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShcIlxcblwiLCBcIlxcXFxuXCIpLnJlcGxhY2UoXCJcXHRcIiwgXCJcXFxcdFwiKS5yZXBsYWNlKFwiXFxmXCIsIFwiXFxcXGZcIikucmVwbGFjZShcIlxcdlwiLCBcIlxcXFx2XCIpLnJlcGxhY2UoXCJcXHJcIiwgXCJcXFxcclwiKVxyXG4gICAgfVxyXG4gICAgc2FuZGJveCA9IHNhbmRib3ggfHwge307XHJcbiAgICBjb25zdCBmbiA9IG5ldyBGdW5jdGlvbignc2FuZGJveCcsIGB3aXRoKHNhbmRib3gpeyR7cmVwX25vbl9wcmludChjb2RlKX19YCk7XHJcbiAgICBjb25zdCBfcHJveHkgPSBuZXcgUHJveHkoc2FuZGJveCwge1xyXG4gICAgICAgIGhhcyh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgICAgICBpZihtaXhCbGFjay5pbmRleE9mKGtleSkgIT0gLTEpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ga2V5IGluIHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBmbihfcHJveHkpO1xyXG59O1xyXG5sZXQgbWljVm0gPSAoY29kZSwgZGF0YSkgPT4ge1xyXG4gICAgbGV0IHJlc3VsdDtcclxuICAgIC8vIHRyeSB7XHJcbiAgICByZXN1bHQgPSBuZXcgRnVuY3Rpb24oJ29iaicsIFwid2l0aChvYmope1wiICsgY29kZSArIFwifVwiKS5hcHBseShkYXRhLCBbZGF0YV0pXHJcbiAgICAvLyB9IGNhdGNoIChlcnIpIHtcclxuICAgIC8vICAgICBjb25zb2xlLmVycm9yKFwiJ1wiICsgZXJyLm1lc3NhZ2UgKyBcIidcIiwgXCIgaW4gXFxuXFxuQ29kZTpcXG5cIiwgY29kZS5yZXBsYWNlKC87L2csIFwiO1xcblwiKS5yZXBsYWNlKC8oe3x9KS9nLCBcIiQxXFxuXCIpKTtcclxuICAgIC8vIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgc2FmZTogSlNhZmVWbVdpdGhCbGFja0xpc3QsXHJcbiAgICB2bTogSlN2bSxcclxuICAgIG1pY1ZtOiBtaWNWbVxyXG59O1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/util/JsVm.js\n");

/***/ }),

/***/ "./src/core/util/attrRoster.js":
/*!*************************************!*\
  !*** ./src/core/util/attrRoster.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\r\n// 因为浏览器环境中属性名是大小写不敏感的，\r\n// 如果要绑定带有大写的属性或者事件时，将找不到\r\n// 这里用了最暴力的方法（因为这个问题确实莫名其妙，也从来没人谈论它...）直接用了一个转换表\r\n\r\n// Because DOM-attr-property names in the browser environment are case insensitive,\r\n// If you want to bind an attribute or event with any uppercase, it will not be able to find it\r\n// The most violent method used here (because this problem is really inexplicable, and no one has ever talked about it...) directly used a conversion table\r\n\r\n// 获取浏览器环境里dom中带有大写且非函数的键名\r\n// Get the uppercase and non-function key names in the DOM in the browser environment\r\nfunction Roster() {\r\n    let div = document.createElement(\"div\"),\r\n        text = document.createTextNode(\"\"),\r\n        ret = {};\r\n    for (const prop in div) {\r\n        if (prop != prop.toLowerCase() && typeof div[prop] != \"function\")\r\n            ret[prop.toLowerCase()] = prop\r\n    }\r\n    for (const prop in text) {\r\n        if (prop != prop.toLowerCase() && typeof text[prop] != \"function\")\r\n            ret[prop.toLowerCase()] = prop\r\n    }\r\n    return ret\r\n}\r\n\r\n// Roster (chrome) ==>\r\n// Removed some parameters for internal implementation\r\n// For example, the parameters that are all uppercase are generally invalid.\r\nmodule.exports = {\r\n    accesskey: \"accessKey\",\r\n    assignedslot: \"assignedSlot\",\r\n    // attribute_node: \"ATTRIBUTE_NODE\",\r\n    attributestylemap: \"attributeStyleMap\",\r\n    baseuri: \"baseURI\",\r\n    // cdata_section_node: \"CDATA_SECTION_NODE\",\r\n    childelementcount: \"childElementCount\",\r\n    childnodes: \"childNodes\",\r\n    classlist: \"classList\",\r\n    classname: \"className\",\r\n    clientheight: \"clientHeight\",\r\n    clientleft: \"clientLeft\",\r\n    clienttop: \"clientTop\",\r\n    clientwidth: \"clientWidth\",\r\n    // comment_node: \"COMMENT_NODE\",\r\n    // contenteditable: \"contentEditable\",\r\n    // document_fragment_node: \"DOCUMENT_FRAGMENT_NODE\",\r\n    // document_node: \"DOCUMENT_NODE\",\r\n    // document_position_contained_by: \"DOCUMENT_POSITION_CONTAINED_BY\",\r\n    // document_position_contains: \"DOCUMENT_POSITION_CONTAINS\",\r\n    // document_position_disconnected: \"DOCUMENT_POSITION_DISCONNECTED\",\r\n    // document_position_following: \"DOCUMENT_POSITION_FOLLOWING\",\r\n    // document_position_implementation_specific: \"DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\",\r\n    // document_position_preceding: \"DOCUMENT_POSITION_PRECEDING\",\r\n    // document_type_node: \"DOCUMENT_TYPE_NODE\",\r\n    // element_node: \"ELEMENT_NODE\",\r\n    // entity_node: \"ENTITY_NODE\",\r\n    // entity_reference_node: \"ENTITY_REFERENCE_NODE\",\r\n    firstchild: \"firstChild\",\r\n    firstelementchild: \"firstElementChild\",\r\n    innerhtml: \"innerHTML\",\r\n    innertext: \"innerText\",\r\n    inputmode: \"inputMode\",\r\n    isconnected: \"isConnected\",\r\n    iscontenteditable: \"isContentEditable\",\r\n    lastchild: \"lastChild\",\r\n    lastelementchild: \"lastElementChild\",\r\n    localname: \"localName\",\r\n    namespaceuri: \"namespaceURI\",\r\n    nextelementsibling: \"nextElementSibling\",\r\n    nextsibling: \"nextSibling\",\r\n    nodename: \"nodeName\",\r\n    nodetype: \"nodeType\",\r\n    nodevalue: \"nodeValue\",\r\n    // notation_node: \"NOTATION_NODE\",\r\n    offsetheight: \"offsetHeight\",\r\n    offsetleft: \"offsetLeft\",\r\n    offsetparent: \"offsetParent\",\r\n    offsettop: \"offsetTop\",\r\n    offsetwidth: \"offsetWidth\",\r\n    outerhtml: \"outerHTML\",\r\n    outertext: \"outerText\",\r\n    ownerdocument: \"ownerDocument\",\r\n    parentelement: \"parentElement\",\r\n    parentnode: \"parentNode\",\r\n    previouselementsibling: \"previousElementSibling\",\r\n    previoussibling: \"previousSibling\",\r\n    // processing_instruction_node: \"PROCESSING_INSTRUCTION_NODE\",\r\n    scrollheight: \"scrollHeight\",\r\n    scrollleft: \"scrollLeft\",\r\n    scrolltop: \"scrollTop\",\r\n    scrollwidth: \"scrollWidth\",\r\n    shadowroot: \"shadowRoot\",\r\n    tabindex: \"tabIndex\",\r\n    tagname: \"tagName\",\r\n    // text_node: \"TEXT_NODE\",\r\n    textcontent: \"textContent\",\r\n    wholetext: \"wholeText\"\r\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS91dGlsL2F0dHJSb3N0ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29yZS91dGlsL2F0dHJSb3N0ZXIuanM/ZmQzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuLy8g5Zug5Li65rWP6KeI5Zmo546v5aKD5Lit5bGe5oCn5ZCN5piv5aSn5bCP5YaZ5LiN5pWP5oSf55qE77yMXHJcbi8vIOWmguaenOimgee7keWumuW4puacieWkp+WGmeeahOWxnuaAp+aIluiAheS6i+S7tuaXtu+8jOWwhuaJvuS4jeWIsFxyXG4vLyDov5nph4znlKjkuobmnIDmmrTlipvnmoTmlrnms5XvvIjlm6DkuLrov5nkuKrpl67popjnoa7lrp7ojqvlkI3lhbblppnvvIzkuZ/ku47mnaXmsqHkurrosIjorrrlroMuLi7vvInnm7TmjqXnlKjkuobkuIDkuKrovazmjaLooahcclxuXHJcbi8vIEJlY2F1c2UgRE9NLWF0dHItcHJvcGVydHkgbmFtZXMgaW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnQgYXJlIGNhc2UgaW5zZW5zaXRpdmUsXHJcbi8vIElmIHlvdSB3YW50IHRvIGJpbmQgYW4gYXR0cmlidXRlIG9yIGV2ZW50IHdpdGggYW55IHVwcGVyY2FzZSwgaXQgd2lsbCBub3QgYmUgYWJsZSB0byBmaW5kIGl0XHJcbi8vIFRoZSBtb3N0IHZpb2xlbnQgbWV0aG9kIHVzZWQgaGVyZSAoYmVjYXVzZSB0aGlzIHByb2JsZW0gaXMgcmVhbGx5IGluZXhwbGljYWJsZSwgYW5kIG5vIG9uZSBoYXMgZXZlciB0YWxrZWQgYWJvdXQgaXQuLi4pIGRpcmVjdGx5IHVzZWQgYSBjb252ZXJzaW9uIHRhYmxlXHJcblxyXG4vLyDojrflj5bmtY/op4jlmajnjq/looPph4xkb23kuK3luKbmnInlpKflhpnkuJTpnZ7lh73mlbDnmoTplK7lkI1cclxuLy8gR2V0IHRoZSB1cHBlcmNhc2UgYW5kIG5vbi1mdW5jdGlvbiBrZXkgbmFtZXMgaW4gdGhlIERPTSBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudFxyXG5mdW5jdGlvbiBSb3N0ZXIoKSB7XHJcbiAgICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcclxuICAgICAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIiksXHJcbiAgICAgICAgcmV0ID0ge307XHJcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gZGl2KSB7XHJcbiAgICAgICAgaWYgKHByb3AgIT0gcHJvcC50b0xvd2VyQ2FzZSgpICYmIHR5cGVvZiBkaXZbcHJvcF0gIT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICByZXRbcHJvcC50b0xvd2VyQ2FzZSgpXSA9IHByb3BcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgcHJvcCBpbiB0ZXh0KSB7XHJcbiAgICAgICAgaWYgKHByb3AgIT0gcHJvcC50b0xvd2VyQ2FzZSgpICYmIHR5cGVvZiB0ZXh0W3Byb3BdICE9IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgcmV0W3Byb3AudG9Mb3dlckNhc2UoKV0gPSBwcm9wXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0XHJcbn1cclxuXHJcbi8vIFJvc3RlciAoY2hyb21lKSA9PT5cclxuLy8gUmVtb3ZlZCBzb21lIHBhcmFtZXRlcnMgZm9yIGludGVybmFsIGltcGxlbWVudGF0aW9uXHJcbi8vIEZvciBleGFtcGxlLCB0aGUgcGFyYW1ldGVycyB0aGF0IGFyZSBhbGwgdXBwZXJjYXNlIGFyZSBnZW5lcmFsbHkgaW52YWxpZC5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBhY2Nlc3NrZXk6IFwiYWNjZXNzS2V5XCIsXHJcbiAgICBhc3NpZ25lZHNsb3Q6IFwiYXNzaWduZWRTbG90XCIsXHJcbiAgICAvLyBhdHRyaWJ1dGVfbm9kZTogXCJBVFRSSUJVVEVfTk9ERVwiLFxyXG4gICAgYXR0cmlidXRlc3R5bGVtYXA6IFwiYXR0cmlidXRlU3R5bGVNYXBcIixcclxuICAgIGJhc2V1cmk6IFwiYmFzZVVSSVwiLFxyXG4gICAgLy8gY2RhdGFfc2VjdGlvbl9ub2RlOiBcIkNEQVRBX1NFQ1RJT05fTk9ERVwiLFxyXG4gICAgY2hpbGRlbGVtZW50Y291bnQ6IFwiY2hpbGRFbGVtZW50Q291bnRcIixcclxuICAgIGNoaWxkbm9kZXM6IFwiY2hpbGROb2Rlc1wiLFxyXG4gICAgY2xhc3NsaXN0OiBcImNsYXNzTGlzdFwiLFxyXG4gICAgY2xhc3NuYW1lOiBcImNsYXNzTmFtZVwiLFxyXG4gICAgY2xpZW50aGVpZ2h0OiBcImNsaWVudEhlaWdodFwiLFxyXG4gICAgY2xpZW50bGVmdDogXCJjbGllbnRMZWZ0XCIsXHJcbiAgICBjbGllbnR0b3A6IFwiY2xpZW50VG9wXCIsXHJcbiAgICBjbGllbnR3aWR0aDogXCJjbGllbnRXaWR0aFwiLFxyXG4gICAgLy8gY29tbWVudF9ub2RlOiBcIkNPTU1FTlRfTk9ERVwiLFxyXG4gICAgLy8gY29udGVudGVkaXRhYmxlOiBcImNvbnRlbnRFZGl0YWJsZVwiLFxyXG4gICAgLy8gZG9jdW1lbnRfZnJhZ21lbnRfbm9kZTogXCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFXCIsXHJcbiAgICAvLyBkb2N1bWVudF9ub2RlOiBcIkRPQ1VNRU5UX05PREVcIixcclxuICAgIC8vIGRvY3VtZW50X3Bvc2l0aW9uX2NvbnRhaW5lZF9ieTogXCJET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQllcIixcclxuICAgIC8vIGRvY3VtZW50X3Bvc2l0aW9uX2NvbnRhaW5zOiBcIkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5TXCIsXHJcbiAgICAvLyBkb2N1bWVudF9wb3NpdGlvbl9kaXNjb25uZWN0ZWQ6IFwiRE9DVU1FTlRfUE9TSVRJT05fRElTQ09OTkVDVEVEXCIsXHJcbiAgICAvLyBkb2N1bWVudF9wb3NpdGlvbl9mb2xsb3dpbmc6IFwiRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HXCIsXHJcbiAgICAvLyBkb2N1bWVudF9wb3NpdGlvbl9pbXBsZW1lbnRhdGlvbl9zcGVjaWZpYzogXCJET0NVTUVOVF9QT1NJVElPTl9JTVBMRU1FTlRBVElPTl9TUEVDSUZJQ1wiLFxyXG4gICAgLy8gZG9jdW1lbnRfcG9zaXRpb25fcHJlY2VkaW5nOiBcIkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElOR1wiLFxyXG4gICAgLy8gZG9jdW1lbnRfdHlwZV9ub2RlOiBcIkRPQ1VNRU5UX1RZUEVfTk9ERVwiLFxyXG4gICAgLy8gZWxlbWVudF9ub2RlOiBcIkVMRU1FTlRfTk9ERVwiLFxyXG4gICAgLy8gZW50aXR5X25vZGU6IFwiRU5USVRZX05PREVcIixcclxuICAgIC8vIGVudGl0eV9yZWZlcmVuY2Vfbm9kZTogXCJFTlRJVFlfUkVGRVJFTkNFX05PREVcIixcclxuICAgIGZpcnN0Y2hpbGQ6IFwiZmlyc3RDaGlsZFwiLFxyXG4gICAgZmlyc3RlbGVtZW50Y2hpbGQ6IFwiZmlyc3RFbGVtZW50Q2hpbGRcIixcclxuICAgIGlubmVyaHRtbDogXCJpbm5lckhUTUxcIixcclxuICAgIGlubmVydGV4dDogXCJpbm5lclRleHRcIixcclxuICAgIGlucHV0bW9kZTogXCJpbnB1dE1vZGVcIixcclxuICAgIGlzY29ubmVjdGVkOiBcImlzQ29ubmVjdGVkXCIsXHJcbiAgICBpc2NvbnRlbnRlZGl0YWJsZTogXCJpc0NvbnRlbnRFZGl0YWJsZVwiLFxyXG4gICAgbGFzdGNoaWxkOiBcImxhc3RDaGlsZFwiLFxyXG4gICAgbGFzdGVsZW1lbnRjaGlsZDogXCJsYXN0RWxlbWVudENoaWxkXCIsXHJcbiAgICBsb2NhbG5hbWU6IFwibG9jYWxOYW1lXCIsXHJcbiAgICBuYW1lc3BhY2V1cmk6IFwibmFtZXNwYWNlVVJJXCIsXHJcbiAgICBuZXh0ZWxlbWVudHNpYmxpbmc6IFwibmV4dEVsZW1lbnRTaWJsaW5nXCIsXHJcbiAgICBuZXh0c2libGluZzogXCJuZXh0U2libGluZ1wiLFxyXG4gICAgbm9kZW5hbWU6IFwibm9kZU5hbWVcIixcclxuICAgIG5vZGV0eXBlOiBcIm5vZGVUeXBlXCIsXHJcbiAgICBub2RldmFsdWU6IFwibm9kZVZhbHVlXCIsXHJcbiAgICAvLyBub3RhdGlvbl9ub2RlOiBcIk5PVEFUSU9OX05PREVcIixcclxuICAgIG9mZnNldGhlaWdodDogXCJvZmZzZXRIZWlnaHRcIixcclxuICAgIG9mZnNldGxlZnQ6IFwib2Zmc2V0TGVmdFwiLFxyXG4gICAgb2Zmc2V0cGFyZW50OiBcIm9mZnNldFBhcmVudFwiLFxyXG4gICAgb2Zmc2V0dG9wOiBcIm9mZnNldFRvcFwiLFxyXG4gICAgb2Zmc2V0d2lkdGg6IFwib2Zmc2V0V2lkdGhcIixcclxuICAgIG91dGVyaHRtbDogXCJvdXRlckhUTUxcIixcclxuICAgIG91dGVydGV4dDogXCJvdXRlclRleHRcIixcclxuICAgIG93bmVyZG9jdW1lbnQ6IFwib3duZXJEb2N1bWVudFwiLFxyXG4gICAgcGFyZW50ZWxlbWVudDogXCJwYXJlbnRFbGVtZW50XCIsXHJcbiAgICBwYXJlbnRub2RlOiBcInBhcmVudE5vZGVcIixcclxuICAgIHByZXZpb3VzZWxlbWVudHNpYmxpbmc6IFwicHJldmlvdXNFbGVtZW50U2libGluZ1wiLFxyXG4gICAgcHJldmlvdXNzaWJsaW5nOiBcInByZXZpb3VzU2libGluZ1wiLFxyXG4gICAgLy8gcHJvY2Vzc2luZ19pbnN0cnVjdGlvbl9ub2RlOiBcIlBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERVwiLFxyXG4gICAgc2Nyb2xsaGVpZ2h0OiBcInNjcm9sbEhlaWdodFwiLFxyXG4gICAgc2Nyb2xsbGVmdDogXCJzY3JvbGxMZWZ0XCIsXHJcbiAgICBzY3JvbGx0b3A6IFwic2Nyb2xsVG9wXCIsXHJcbiAgICBzY3JvbGx3aWR0aDogXCJzY3JvbGxXaWR0aFwiLFxyXG4gICAgc2hhZG93cm9vdDogXCJzaGFkb3dSb290XCIsXHJcbiAgICB0YWJpbmRleDogXCJ0YWJJbmRleFwiLFxyXG4gICAgdGFnbmFtZTogXCJ0YWdOYW1lXCIsXHJcbiAgICAvLyB0ZXh0X25vZGU6IFwiVEVYVF9OT0RFXCIsXHJcbiAgICB0ZXh0Y29udGVudDogXCJ0ZXh0Q29udGVudFwiLFxyXG4gICAgd2hvbGV0ZXh0OiBcIndob2xlVGV4dFwiXHJcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/util/attrRoster.js\n");

/***/ }),

/***/ "./src/core/util/frameify.js":
/*!***********************************!*\
  !*** ./src/core/util/frameify.js ***!
  \***********************************/
/*! exports provided: frameify */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frameify\", function() { return frameify; });\n// 很奇怪的做法，主要是为了实现time slice，\r\n// 将主体为生成器的task化为promise，\r\n// 从而支持await和async\r\n// @more: https://www.w3.org/TR/requestidlecallback/\r\n\r\nvar reqFrame = ((window) => {\r\n    // 每帧50ms\r\n    // * 本来按照常识，这里是很适合idlecallback的，\r\n    //   当然，之前也是那么写的，不过现在，如你所见\r\n    //   我将每帧定义在50ms内\r\n    //   不仅减少不必要的调用，也不用关心idle是怎么实现的\r\n    //   比如chrome的idle会因为鼠标闲置而被block...?!?\r\n    //   实在没弄懂为什么是这种行为...\r\n    //   不过现在已经不用担心了~\r\n    //\r\n    const rF = window.requestAnimationFrame ||\r\n        window.webkitRequestAnimationFrame ||\r\n        window.mozRequestAnimationFrame;\r\n    if (rF) {\r\n        return function(cb) {\r\n            var start = Date.now();\r\n            return rF(function(call2now) {\r\n                cb({\r\n                    timeRemaining() {\r\n                        return Math.max(0, 50 - (Date.now() - start));\r\n                    },\r\n                });\r\n            });\r\n        };\r\n    }\r\n    // default\r\n    return function(cb) {\r\n        var start = Date.now();\r\n        return setTimeout(function() {\r\n            cb({\r\n                timeRemainingn() {\r\n                    return Math.max(0, 50 - (Date.now() - start));\r\n                },\r\n            });\r\n        }, 1);\r\n    };\r\n})(window);\r\n\r\nvar cancelFrame = ((window) => {\r\n    return window.cancelAnimationFrame ||\r\n        window.webkitCancelAnimationFrame ||\r\n        window.webkitCancelRequestAnimationFrame ||\r\n        window.mozCancelAnimationFrame ||\r\n        window.mozCancelRequestAnimationFrame || (id => clearTimeout(id));\r\n})(window);\r\n\r\nfunction frameify(gen, _Int_) {\r\n    return new Promise((resolve, reject) => {\r\n        var frameid;\r\n        if (_Int_) _Int_.clear = () => {\r\n            // Interrupt\r\n            cancelFrame(frameid);\r\n            // console.log(\"clear\", frameid)\r\n            resolve(void 0);\r\n            return void 0;\r\n        }\r\n\r\n        function inner() {\r\n            frameid = reqFrame((deadline) => {\r\n                while (deadline.timeRemaining() > 5) {\r\n                    var n = gen.next();\r\n                    if (n.done) {\r\n                        resolve(n.value);\r\n                        return void 0;\r\n                    }\r\n                }\r\n                inner();\r\n            })\r\n        }\r\n        try {\r\n            inner()\r\n        } catch (e) {\r\n            reject(e)\r\n        }\r\n    })\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS91dGlsL2ZyYW1laWZ5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvdXRpbC9mcmFtZWlmeS5qcz9kOTkzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIOW+iOWlh+aAqueahOWBmuazle+8jOS4u+imgeaYr+S4uuS6huWunueOsHRpbWUgc2xpY2XvvIxcclxuLy8g5bCG5Li75L2T5Li655Sf5oiQ5Zmo55qEdGFza+WMluS4unByb21pc2XvvIxcclxuLy8g5LuO6ICM5pSv5oyBYXdhaXTlkoxhc3luY1xyXG4vLyBAbW9yZTogaHR0cHM6Ly93d3cudzMub3JnL1RSL3JlcXVlc3RpZGxlY2FsbGJhY2svXHJcblxyXG52YXIgcmVxRnJhbWUgPSAoKHdpbmRvdykgPT4ge1xyXG4gICAgLy8g5q+P5binNTBtc1xyXG4gICAgLy8gKiDmnKzmnaXmjInnhafluLjor4bvvIzov5nph4zmmK/lvojpgILlkIhpZGxlY2FsbGJhY2vnmoTvvIxcclxuICAgIC8vICAg5b2T54S277yM5LmL5YmN5Lmf5piv6YKj5LmI5YaZ55qE77yM5LiN6L+H546w5Zyo77yM5aaC5L2g5omA6KeBXHJcbiAgICAvLyAgIOaIkeWwhuavj+W4p+WumuS5ieWcqDUwbXPlhoVcclxuICAgIC8vICAg5LiN5LuF5YeP5bCR5LiN5b+F6KaB55qE6LCD55So77yM5Lmf5LiN55So5YWz5b+DaWRsZeaYr+aAjuS5iOWunueOsOeahFxyXG4gICAgLy8gICDmr5TlpoJjaHJvbWXnmoRpZGxl5Lya5Zug5Li66byg5qCH6Zey572u6ICM6KKrYmxvY2suLi4/IT9cclxuICAgIC8vICAg5a6e5Zyo5rKh5byE5oeC5Li65LuA5LmI5piv6L+Z56eN6KGM5Li6Li4uXHJcbiAgICAvLyAgIOS4jei/h+eOsOWcqOW3sue7j+S4jeeUqOaLheW/g+S6hn5cclxuICAgIC8vXHJcbiAgICBjb25zdCByRiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZTtcclxuICAgIGlmIChyRikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihjYikge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICByZXR1cm4gckYoZnVuY3Rpb24oY2FsbDJub3cpIHtcclxuICAgICAgICAgICAgICAgIGNiKHtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lUmVtYWluaW5nKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgNTAgLSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gZGVmYXVsdFxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNiKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgY2Ioe1xyXG4gICAgICAgICAgICAgICAgdGltZVJlbWFpbmluZ24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIDUwIC0gKERhdGUubm93KCkgLSBzdGFydCkpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgMSk7XHJcbiAgICB9O1xyXG59KSh3aW5kb3cpO1xyXG5cclxudmFyIGNhbmNlbEZyYW1lID0gKCh3aW5kb3cpID0+IHtcclxuICAgIHJldHVybiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICB3aW5kb3cud2Via2l0Q2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgICAgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgICAgd2luZG93Lm1vekNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCAoaWQgPT4gY2xlYXJUaW1lb3V0KGlkKSk7XHJcbn0pKHdpbmRvdyk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZnJhbWVpZnkoZ2VuLCBfSW50Xykge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICB2YXIgZnJhbWVpZDtcclxuICAgICAgICBpZiAoX0ludF8pIF9JbnRfLmNsZWFyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBJbnRlcnJ1cHRcclxuICAgICAgICAgICAgY2FuY2VsRnJhbWUoZnJhbWVpZCk7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiY2xlYXJcIiwgZnJhbWVpZClcclxuICAgICAgICAgICAgcmVzb2x2ZSh2b2lkIDApO1xyXG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaW5uZXIoKSB7XHJcbiAgICAgICAgICAgIGZyYW1laWQgPSByZXFGcmFtZSgoZGVhZGxpbmUpID0+IHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChkZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiA1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBnZW4ubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuLmRvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbm5lcigpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpbm5lcigpXHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZWplY3QoZSlcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG59XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/util/frameify.js\n");

/***/ }),

/***/ "./src/core/util/util.js":
/*!*******************************!*\
  !*** ./src/core/util/util.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function getType(obj) {\r\n    if (obj instanceof Element) return 'dom';\r\n    return Object.prototype.toString.call(obj).slice(8).slice(0, -1).toLowerCase();\r\n}\r\n\r\nfunction deepClone(data) {\r\n    var type = getType(data);\r\n    var obj;\r\n    if (type === 'array') {\r\n        obj = [];\r\n    } else if (type === 'object') {\r\n        obj = {};\r\n    } else {\r\n        return data;\r\n    }\r\n    if (type === 'array') {\r\n        for (var i = 0, len = data.length; i < len; i++) {\r\n            obj.push(deepClone(data[i]));\r\n        }\r\n    } else if (type === 'object') {\r\n        for (var key in data) {\r\n            obj[key] = deepClone(data[key]);\r\n        }\r\n    }\r\n    return obj;\r\n}\r\n\r\nlet extend = (o, n) => {\r\n    for (var p in n) {\r\n        if (n.hasOwnProperty(p) && (!o.hasOwnProperty(p)))\r\n            o[p] = n[p];\r\n    }\r\n};\r\n\r\nlet arrMerge = (a, b) => {\r\n    a.push.apply(a, b);\r\n};\r\n\r\n// 已经不用了，现在是根据代码然后绑定内容\r\nlet support_list = [\"resize\", \"load\", \"click\", \"dblclick\", \"change\", \"input\", \"blur\", \"focus\", \"keydown\", \"keyup\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"select\", \"keypress\", \"mousewheel\", \"scroll\"];\r\n\r\nlet GetAttrElement = (attr, val) => {\r\n    let e = document.all;\r\n    let a = new Array();\r\n    for (let i = 0; i < e.length; i++) {\r\n        if (e[i].getAttribute(attr) == val) {\r\n            a.push(e[i])\r\n        }\r\n    }\r\n    return a;\r\n}\r\n\r\nfunction proxy_catch_set(that, cb) {\r\n    if (getType(that) == \"array\") {\r\n        return proxy_arr(that, cb);\r\n    }\r\n    if (getType(that) == \"object\") {\r\n        return new Proxy(that, {\r\n            set(obj, prop, val) {\r\n                if (obj[prop] != val) {\r\n                    obj[prop] = val;\r\n                    cb();\r\n                }\r\n                return true;\r\n            }\r\n        })\r\n    }\r\n    // default\r\n    return that\r\n}\r\n\r\nfunction proxy_arr(arr, cb) {\r\n    if (arr.length != 0) {\r\n        for (var i = 0; i < arr.length; i++) {\r\n            arr[i] = proxy_catch_set(arr[i], () => cb(arr));\r\n        }\r\n    }\r\n    // #u1 double callback.fixed\r\n    return new Proxy(arr, {\r\n        set(obj, prop, val) {\r\n            var calling = false\r\n            if (prop == 'length') {\r\n                if (obj[prop] > val) {\r\n                    // 仅改变长度不会修改特定prop\r\n                    // pop\r\n                    calling = true\r\n                }\r\n                // else {\r\n                //     // push: 分别需要设置新prop的值并设置length,只用calling一次\r\n                //     // push or add \r\n                //     void 0;\r\n                // }\r\n            } else if (obj[prop] != val) {\r\n                calling = true\r\n            }\r\n            if (!isNaN(prop)) obj[prop] = proxy_catch_set(val, () => cb(obj))\r\n            else obj[prop] = val\r\n            // render callback\r\n            if (calling) cb(obj);\r\n            return true;\r\n        }\r\n    })\r\n}\r\n\r\nconst $ = (...args) => document.querySelector.apply(document, args)\r\nconst $$ = (...args) => document.querySelectorAll.apply(document, args)\r\n\r\n// &gt; => >\r\n// &lt; => <\r\n// ...\r\nconst escape2Html = s => s.replace(/&(lt|gt|nbsp|amp|quot);/ig, (all, t) => ({\r\n    'lt': '<',\r\n    'gt': '>',\r\n    'nbsp': ' ',\r\n    'amp': '&',\r\n    'quot': '\"'\r\n})[t]);\r\nconst mergeSpace = s => s.replace(/(?:\\s)\\s/g, ' ');\r\nconst cleanSriptTag = s => s.replace(/<\\s*?script.*?>([\\S\\s]*?)<\\/\\s*?script[^>\\w]*?>/gi, \"\");\r\n\r\nfunction HTMLClean(text) {\r\n    // return escape2Html(mergeSpace(cleanSriptTag(text)))\r\n    return mergeSpace(cleanSriptTag(text))\r\n}\r\n\r\nmodule.exports = {\r\n    deepClone,\r\n    extend,\r\n    arrMerge,\r\n    ev_supList: support_list,\r\n    GetAttrElement,\r\n    proxyArr: proxy_arr,\r\n    $,\r\n    $$,\r\n    HTMLClean\r\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS91dGlsL3V0aWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29yZS91dGlsL3V0aWwuanM/NmRhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBnZXRUeXBlKG9iaikge1xyXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEVsZW1lbnQpIHJldHVybiAnZG9tJztcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKS5zbGljZSg4KS5zbGljZSgwLCAtMSkudG9Mb3dlckNhc2UoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVlcENsb25lKGRhdGEpIHtcclxuICAgIHZhciB0eXBlID0gZ2V0VHlwZShkYXRhKTtcclxuICAgIHZhciBvYmo7XHJcbiAgICBpZiAodHlwZSA9PT0gJ2FycmF5Jykge1xyXG4gICAgICAgIG9iaiA9IFtdO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIG9iaiA9IHt9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlID09PSAnYXJyYXknKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgb2JqLnB1c2goZGVlcENsb25lKGRhdGFbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcclxuICAgICAgICAgICAgb2JqW2tleV0gPSBkZWVwQ2xvbmUoZGF0YVtrZXldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG5sZXQgZXh0ZW5kID0gKG8sIG4pID0+IHtcclxuICAgIGZvciAodmFyIHAgaW4gbikge1xyXG4gICAgICAgIGlmIChuLmhhc093blByb3BlcnR5KHApICYmICghby5oYXNPd25Qcm9wZXJ0eShwKSkpXHJcbiAgICAgICAgICAgIG9bcF0gPSBuW3BdO1xyXG4gICAgfVxyXG59O1xyXG5cclxubGV0IGFyck1lcmdlID0gKGEsIGIpID0+IHtcclxuICAgIGEucHVzaC5hcHBseShhLCBiKTtcclxufTtcclxuXHJcbi8vIOW3sue7j+S4jeeUqOS6hu+8jOeOsOWcqOaYr+agueaNruS7o+eggeeEtuWQjue7keWumuWGheWuuVxyXG5sZXQgc3VwcG9ydF9saXN0ID0gW1wicmVzaXplXCIsIFwibG9hZFwiLCBcImNsaWNrXCIsIFwiZGJsY2xpY2tcIiwgXCJjaGFuZ2VcIiwgXCJpbnB1dFwiLCBcImJsdXJcIiwgXCJmb2N1c1wiLCBcImtleWRvd25cIiwgXCJrZXl1cFwiLCBcIm1vdXNlZG93blwiLCBcIm1vdXNlbW92ZVwiLCBcIm1vdXNlb3V0XCIsIFwibW91c2VvdmVyXCIsIFwibW91c2V1cFwiLCBcInNlbGVjdFwiLCBcImtleXByZXNzXCIsIFwibW91c2V3aGVlbFwiLCBcInNjcm9sbFwiXTtcclxuXHJcbmxldCBHZXRBdHRyRWxlbWVudCA9IChhdHRyLCB2YWwpID0+IHtcclxuICAgIGxldCBlID0gZG9jdW1lbnQuYWxsO1xyXG4gICAgbGV0IGEgPSBuZXcgQXJyYXkoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChlW2ldLmdldEF0dHJpYnV0ZShhdHRyKSA9PSB2YWwpIHtcclxuICAgICAgICAgICAgYS5wdXNoKGVbaV0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb3h5X2NhdGNoX3NldCh0aGF0LCBjYikge1xyXG4gICAgaWYgKGdldFR5cGUodGhhdCkgPT0gXCJhcnJheVwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3h5X2Fycih0aGF0LCBjYik7XHJcbiAgICB9XHJcbiAgICBpZiAoZ2V0VHlwZSh0aGF0KSA9PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh0aGF0LCB7XHJcbiAgICAgICAgICAgIHNldChvYmosIHByb3AsIHZhbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9ialtwcm9wXSAhPSB2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgY2IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuICAgIC8vIGRlZmF1bHRcclxuICAgIHJldHVybiB0aGF0XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb3h5X2FycihhcnIsIGNiKSB7XHJcbiAgICBpZiAoYXJyLmxlbmd0aCAhPSAwKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYXJyW2ldID0gcHJveHlfY2F0Y2hfc2V0KGFycltpXSwgKCkgPT4gY2IoYXJyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gI3UxIGRvdWJsZSBjYWxsYmFjay5maXhlZFxyXG4gICAgcmV0dXJuIG5ldyBQcm94eShhcnIsIHtcclxuICAgICAgICBzZXQob2JqLCBwcm9wLCB2YWwpIHtcclxuICAgICAgICAgICAgdmFyIGNhbGxpbmcgPSBmYWxzZVxyXG4gICAgICAgICAgICBpZiAocHJvcCA9PSAnbGVuZ3RoJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9ialtwcm9wXSA+IHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOS7heaUueWPmOmVv+W6puS4jeS8muS/ruaUueeJueWumnByb3BcclxuICAgICAgICAgICAgICAgICAgICAvLyBwb3BcclxuICAgICAgICAgICAgICAgICAgICBjYWxsaW5nID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gcHVzaDog5YiG5Yir6ZyA6KaB6K6+572u5pawcHJvcOeahOWAvOW5tuiuvue9rmxlbmd0aCzlj6rnlKhjYWxsaW5n5LiA5qyhXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gcHVzaCBvciBhZGQgXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9ialtwcm9wXSAhPSB2YWwpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxpbmcgPSB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc05hTihwcm9wKSkgb2JqW3Byb3BdID0gcHJveHlfY2F0Y2hfc2V0KHZhbCwgKCkgPT4gY2Iob2JqKSlcclxuICAgICAgICAgICAgZWxzZSBvYmpbcHJvcF0gPSB2YWxcclxuICAgICAgICAgICAgLy8gcmVuZGVyIGNhbGxiYWNrXHJcbiAgICAgICAgICAgIGlmIChjYWxsaW5nKSBjYihvYmopO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG59XHJcblxyXG5jb25zdCAkID0gKC4uLmFyZ3MpID0+IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IuYXBwbHkoZG9jdW1lbnQsIGFyZ3MpXHJcbmNvbnN0ICQkID0gKC4uLmFyZ3MpID0+IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwuYXBwbHkoZG9jdW1lbnQsIGFyZ3MpXHJcblxyXG4vLyAmZ3Q7ID0+ID5cclxuLy8gJmx0OyA9PiA8XHJcbi8vIC4uLlxyXG5jb25zdCBlc2NhcGUySHRtbCA9IHMgPT4gcy5yZXBsYWNlKC8mKGx0fGd0fG5ic3B8YW1wfHF1b3QpOy9pZywgKGFsbCwgdCkgPT4gKHtcclxuICAgICdsdCc6ICc8JyxcclxuICAgICdndCc6ICc+JyxcclxuICAgICduYnNwJzogJyAnLFxyXG4gICAgJ2FtcCc6ICcmJyxcclxuICAgICdxdW90JzogJ1wiJ1xyXG59KVt0XSk7XHJcbmNvbnN0IG1lcmdlU3BhY2UgPSBzID0+IHMucmVwbGFjZSgvKD86XFxzKVxccy9nLCAnICcpO1xyXG5jb25zdCBjbGVhblNyaXB0VGFnID0gcyA9PiBzLnJlcGxhY2UoLzxcXHMqP3NjcmlwdC4qPz4oW1xcU1xcc10qPyk8XFwvXFxzKj9zY3JpcHRbXj5cXHddKj8+L2dpLCBcIlwiKTtcclxuXHJcbmZ1bmN0aW9uIEhUTUxDbGVhbih0ZXh0KSB7XHJcbiAgICAvLyByZXR1cm4gZXNjYXBlMkh0bWwobWVyZ2VTcGFjZShjbGVhblNyaXB0VGFnKHRleHQpKSlcclxuICAgIHJldHVybiBtZXJnZVNwYWNlKGNsZWFuU3JpcHRUYWcodGV4dCkpXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgZGVlcENsb25lLFxyXG4gICAgZXh0ZW5kLFxyXG4gICAgYXJyTWVyZ2UsXHJcbiAgICBldl9zdXBMaXN0OiBzdXBwb3J0X2xpc3QsXHJcbiAgICBHZXRBdHRyRWxlbWVudCxcclxuICAgIHByb3h5QXJyOiBwcm94eV9hcnIsXHJcbiAgICAkLFxyXG4gICAgJCQsXHJcbiAgICBIVE1MQ2xlYW5cclxufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/util/util.js\n");

/***/ }),

/***/ "./src/domapi.js":
/*!***********************!*\
  !*** ./src/domapi.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\r\nconst arrDiffer = (a, b) => {\r\n    // if the other array is a falsy value, return\r\n    if (!a || !b)\r\n        return false\r\n    // compare lengths - can save a lot of time\r\n    if (a.length != b.length)\r\n        return false\r\n    let isIn = (arr1, arr2) => {\r\n        for (let i in arr1) {\r\n            let nullInOther = true\r\n            for (let j in arr2) {\r\n                if (arr1[i] == arr2[j]) {\r\n                    nullInOther = false\r\n                }\r\n            }\r\n            if (nullInOther) {\r\n                return false\r\n            }\r\n        }\r\n        return true\r\n    }\r\n    return isIn(a, b) && isIn(b, a)\r\n}\r\n\r\nfunction childIndex(ele){\r\n    if(ele.cellIndex)return ele.cellIndex\r\n    if(ele.rowIndex)return ele.rowIndex\r\n    // if(ele.sourceIndex)return ele.sourceIndex\r\n\r\n    // const toArr = o => Array.prototype.slice.call(o)\r\n    // return toArr(ele.parentNode.children).indexOf(ele)\r\n    \r\n    // LoseIndex => diff.js(patch)\r\n    // index cache\r\n    if(!ele.parentNode.loseIndex){\r\n        if(ele.previousElementSibling && ele.previousElementSibling.childIndex){\r\n            ele.childIndex = ele.previousElementSibling.childIndex + 1\r\n            return ele.childIndex\r\n        }\r\n        if(ele.nextElementSibling && ele.nextElementSibling.childIndex){\r\n            ele.childIndex = ele.nextElementSibling.childIndex - 1\r\n            return ele.childIndex\r\n        }\r\n        if(ele.childIndex)return ele.childIndex\r\n    }\r\n    //*** Performance killer\r\n    let count = 0,\r\n    node = ele.parentNode.children[0],\r\n    ret = 0\r\n    if(node == ele)return count\r\n    while(node = node.nextElementSibling){\r\n        node.childIndex = count\r\n        if(node == ele)ret = count\r\n        count += 1\r\n    }\r\n    ele.parentNode.loseIndex = true\r\n    return ret\r\n}\r\n\r\nconst domApi = {\r\n    $: _selector => {\r\n        let ele = document.querySelector(_selector)\r\n        ele.html = function(_newHtml) {\r\n            if (this.empty) {\r\n                return ''\r\n            }\r\n            if (_newHtml != undefined) {\r\n                this.innerHTML = _newHtml;\r\n                return _newHtml;\r\n            } else {\r\n                return this.innerHTML;\r\n            }\r\n        };\r\n        return ele\r\n    },\r\n    createDom: _html => {\r\n        let tempRoot = document.createElement(\"div\")\r\n        tempRoot.innerHTML = _html\r\n        return tempRoot.children[0]\r\n    },\r\n    createDomTree: _html => {\r\n        let tempRoot = document.createElement(\"div\")\r\n        tempRoot.innerHTML = _html\r\n        return tempRoot.childNodes\r\n    },\r\n    append: (newElement, targetElement) => {\r\n        newElement = typeof newElement == typeof \"\" ? domApi.createDom(newElement) : newElement\r\n        return targetElement.appendChild(newElement)\r\n    },\r\n    insertBefore: (newElement, targetElement) => {\r\n        let parent = targetElement.parentNode\r\n        newElement = typeof newElement == typeof \"\" ? domApi.createDom(newElement) : newElement\r\n        return parent.insertBefore(newElement, targetElement)\r\n    },\r\n    insertAfter: (newElement, targetElement) => {\r\n        var parent = targetElement.parentNode;\r\n        if (parent.lastChild == targetElement) {\r\n            parent.appendChild(newElement);\r\n        } else {\r\n            parent.insertBefore(newElement, targetElement.nextSibling)\r\n        }\r\n    },\r\n    remove: targetElement => {\r\n        if (targetElement == undefined) return\r\n        let parent = targetElement.parentNode\r\n        if (parent == undefined) {\r\n            targetElement = null\r\n            return\r\n        }\r\n        parent.removeChild(targetElement)\r\n    },\r\n    isSame: (ele1, ele2) => {\r\n        if (ele1 == undefined || ele2 == undefined) return false;\r\n        if (ele1.nodeType != ele2.nodeType) return false;\r\n        if (ele1.nodeType == 1) {\r\n            // node\r\n            return (\r\n                ele1.nodeName == ele2.nodeName\r\n                && ele1.id == ele2.id\r\n                && ele1.innerHTML.trim() == ele2.innerHTML.trim()\r\n                && ele1.children.length == ele2.children.length\r\n                // && ele1.className == ele2.className\r\n            )\r\n        }\r\n        if (ele1.nodeType == 3) {\r\n            // text node\r\n            return (\r\n                // domApi.isSame(ele1.parentNode, ele2.parentNode) &&\r\n                ele1.textContent == ele2.textContent\r\n            )\r\n        }\r\n    },\r\n    isSameLayerNode(ele1, ele2){\r\n        return domApi.isSame(ele1, ele2)\r\n                && (ele1.childIndex && ele2.childIndex  && !ele1.parentNode.loseIndex?\r\n                    ele1.childIndex == ele2.childIndex :\r\n                    childIndex(ele1) == childIndex(ele2))\r\n    },\r\n    classListDiff: (ele1, ele2) => {\r\n        if (ele1.classList.length != ele2.classList.length) {\r\n            return false\r\n        }\r\n        let cList2Arr = ele => {\r\n            let res = []\r\n            ele.classList.forEach(val => {\r\n                res.push(val)\r\n            })\r\n            return res\r\n        }\r\n        return arrDiffer(cList2Arr(ele1), cList2Arr(ele2))\r\n    },\r\n    attributesDiff: (ele1, ele2) => {\r\n        // *** bad idea! ***\r\n        // if(ele1.attributes.length!=ele2.attributes.length){\r\n        //     return false\r\n        // }\r\n        let attributes2Arr = ele => {\r\n            let res = []\r\n            let tempCur = 0\r\n            let blacks = [\"class\"]\r\n            while (true) {\r\n                let curNode = ele.attributes[tempCur]\r\n                if (curNode) {\r\n                    if (/(.+?):.+?/g.test(curNode.name)) {\r\n                        blacks.push(/(.+?):(.+)/g.exec(curNode.name)[2])\r\n                        tempCur += 1\r\n                        continue\r\n                    }\r\n                    if (blacks.indexOf(curNode.name) != -1) {\r\n                        tempCur += 1\r\n                        continue\r\n                    }\r\n                    res.push(curNode.nodeValue)\r\n                } else {\r\n                    break\r\n                }\r\n                tempCur += 1\r\n            }\r\n            return res\r\n        }\r\n        return arrDiffer(attributes2Arr(ele1), attributes2Arr(ele2))\r\n    },\r\n    // #901\r\n    // Failed to execute 'setNamedItem' on 'NamedNodeMap':\r\n    // The node provided is an attribute node that is alre-\r\n    // ady an attribute of another Element; attribute node-\r\n    // s must be explicitly cloned.\r\n    //\r\n    attributesClone: (ele, to) => {\r\n        for (let attr of ele.attributes) {\r\n            ele.attributes.removeNamedItem(attr.name)\r\n        }\r\n        for (let attr of to.attributes) {\r\n            ele.attributes.setNamedItem(attr.cloneNode(true))\r\n        }\r\n    },\r\n    Comparable: (ele1, ele2) => {\r\n        if (ele1 == undefined || ele2 == undefined) return false;\r\n        if (ele1.nodeType != ele2.nodeType) return false;\r\n        if (ele1.nodeType == 3) return true;\r\n        return (\r\n            ele1.nodeName == ele2.nodeName &&\r\n            ele1.id == ele2.id &&\r\n            ele1.className == ele2.className\r\n        )\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    domApi\r\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZG9tYXBpLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFwaS5qcz9mYzlmIl0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5jb25zdCBhcnJEaWZmZXIgPSAoYSwgYikgPT4ge1xyXG4gICAgLy8gaWYgdGhlIG90aGVyIGFycmF5IGlzIGEgZmFsc3kgdmFsdWUsIHJldHVyblxyXG4gICAgaWYgKCFhIHx8ICFiKVxyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgLy8gY29tcGFyZSBsZW5ndGhzIC0gY2FuIHNhdmUgYSBsb3Qgb2YgdGltZVxyXG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgbGV0IGlzSW4gPSAoYXJyMSwgYXJyMikgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgaW4gYXJyMSkge1xyXG4gICAgICAgICAgICBsZXQgbnVsbEluT3RoZXIgPSB0cnVlXHJcbiAgICAgICAgICAgIGZvciAobGV0IGogaW4gYXJyMikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFycjFbaV0gPT0gYXJyMltqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG51bGxJbk90aGVyID0gZmFsc2VcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobnVsbEluT3RoZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNJbihhLCBiKSAmJiBpc0luKGIsIGEpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoaWxkSW5kZXgoZWxlKXtcclxuICAgIGlmKGVsZS5jZWxsSW5kZXgpcmV0dXJuIGVsZS5jZWxsSW5kZXhcclxuICAgIGlmKGVsZS5yb3dJbmRleClyZXR1cm4gZWxlLnJvd0luZGV4XHJcbiAgICAvLyBpZihlbGUuc291cmNlSW5kZXgpcmV0dXJuIGVsZS5zb3VyY2VJbmRleFxyXG5cclxuICAgIC8vIGNvbnN0IHRvQXJyID0gbyA9PiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvKVxyXG4gICAgLy8gcmV0dXJuIHRvQXJyKGVsZS5wYXJlbnROb2RlLmNoaWxkcmVuKS5pbmRleE9mKGVsZSlcclxuICAgIFxyXG4gICAgLy8gTG9zZUluZGV4ID0+IGRpZmYuanMocGF0Y2gpXHJcbiAgICAvLyBpbmRleCBjYWNoZVxyXG4gICAgaWYoIWVsZS5wYXJlbnROb2RlLmxvc2VJbmRleCl7XHJcbiAgICAgICAgaWYoZWxlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgZWxlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuY2hpbGRJbmRleCl7XHJcbiAgICAgICAgICAgIGVsZS5jaGlsZEluZGV4ID0gZWxlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuY2hpbGRJbmRleCArIDFcclxuICAgICAgICAgICAgcmV0dXJuIGVsZS5jaGlsZEluZGV4XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGVsZS5uZXh0RWxlbWVudFNpYmxpbmcgJiYgZWxlLm5leHRFbGVtZW50U2libGluZy5jaGlsZEluZGV4KXtcclxuICAgICAgICAgICAgZWxlLmNoaWxkSW5kZXggPSBlbGUubmV4dEVsZW1lbnRTaWJsaW5nLmNoaWxkSW5kZXggLSAxXHJcbiAgICAgICAgICAgIHJldHVybiBlbGUuY2hpbGRJbmRleFxyXG4gICAgICAgIH1cclxuICAgICAgICBpZihlbGUuY2hpbGRJbmRleClyZXR1cm4gZWxlLmNoaWxkSW5kZXhcclxuICAgIH1cclxuICAgIC8vKioqIFBlcmZvcm1hbmNlIGtpbGxlclxyXG4gICAgbGV0IGNvdW50ID0gMCxcclxuICAgIG5vZGUgPSBlbGUucGFyZW50Tm9kZS5jaGlsZHJlblswXSxcclxuICAgIHJldCA9IDBcclxuICAgIGlmKG5vZGUgPT0gZWxlKXJldHVybiBjb3VudFxyXG4gICAgd2hpbGUobm9kZSA9IG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nKXtcclxuICAgICAgICBub2RlLmNoaWxkSW5kZXggPSBjb3VudFxyXG4gICAgICAgIGlmKG5vZGUgPT0gZWxlKXJldCA9IGNvdW50XHJcbiAgICAgICAgY291bnQgKz0gMVxyXG4gICAgfVxyXG4gICAgZWxlLnBhcmVudE5vZGUubG9zZUluZGV4ID0gdHJ1ZVxyXG4gICAgcmV0dXJuIHJldFxyXG59XHJcblxyXG5jb25zdCBkb21BcGkgPSB7XHJcbiAgICAkOiBfc2VsZWN0b3IgPT4ge1xyXG4gICAgICAgIGxldCBlbGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKF9zZWxlY3RvcilcclxuICAgICAgICBlbGUuaHRtbCA9IGZ1bmN0aW9uKF9uZXdIdG1sKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVtcHR5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJydcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoX25ld0h0bWwgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVySFRNTCA9IF9uZXdIdG1sO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9uZXdIdG1sO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5uZXJIVE1MO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gZWxlXHJcbiAgICB9LFxyXG4gICAgY3JlYXRlRG9tOiBfaHRtbCA9PiB7XHJcbiAgICAgICAgbGV0IHRlbXBSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxyXG4gICAgICAgIHRlbXBSb290LmlubmVySFRNTCA9IF9odG1sXHJcbiAgICAgICAgcmV0dXJuIHRlbXBSb290LmNoaWxkcmVuWzBdXHJcbiAgICB9LFxyXG4gICAgY3JlYXRlRG9tVHJlZTogX2h0bWwgPT4ge1xyXG4gICAgICAgIGxldCB0ZW1wUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcclxuICAgICAgICB0ZW1wUm9vdC5pbm5lckhUTUwgPSBfaHRtbFxyXG4gICAgICAgIHJldHVybiB0ZW1wUm9vdC5jaGlsZE5vZGVzXHJcbiAgICB9LFxyXG4gICAgYXBwZW5kOiAobmV3RWxlbWVudCwgdGFyZ2V0RWxlbWVudCkgPT4ge1xyXG4gICAgICAgIG5ld0VsZW1lbnQgPSB0eXBlb2YgbmV3RWxlbWVudCA9PSB0eXBlb2YgXCJcIiA/IGRvbUFwaS5jcmVhdGVEb20obmV3RWxlbWVudCkgOiBuZXdFbGVtZW50XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldEVsZW1lbnQuYXBwZW5kQ2hpbGQobmV3RWxlbWVudClcclxuICAgIH0sXHJcbiAgICBpbnNlcnRCZWZvcmU6IChuZXdFbGVtZW50LCB0YXJnZXRFbGVtZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IHBhcmVudCA9IHRhcmdldEVsZW1lbnQucGFyZW50Tm9kZVxyXG4gICAgICAgIG5ld0VsZW1lbnQgPSB0eXBlb2YgbmV3RWxlbWVudCA9PSB0eXBlb2YgXCJcIiA/IGRvbUFwaS5jcmVhdGVEb20obmV3RWxlbWVudCkgOiBuZXdFbGVtZW50XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudC5pbnNlcnRCZWZvcmUobmV3RWxlbWVudCwgdGFyZ2V0RWxlbWVudClcclxuICAgIH0sXHJcbiAgICBpbnNlcnRBZnRlcjogKG5ld0VsZW1lbnQsIHRhcmdldEVsZW1lbnQpID0+IHtcclxuICAgICAgICB2YXIgcGFyZW50ID0gdGFyZ2V0RWxlbWVudC5wYXJlbnROb2RlO1xyXG4gICAgICAgIGlmIChwYXJlbnQubGFzdENoaWxkID09IHRhcmdldEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKG5ld0VsZW1lbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobmV3RWxlbWVudCwgdGFyZ2V0RWxlbWVudC5uZXh0U2libGluZylcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlOiB0YXJnZXRFbGVtZW50ID0+IHtcclxuICAgICAgICBpZiAodGFyZ2V0RWxlbWVudCA9PSB1bmRlZmluZWQpIHJldHVyblxyXG4gICAgICAgIGxldCBwYXJlbnQgPSB0YXJnZXRFbGVtZW50LnBhcmVudE5vZGVcclxuICAgICAgICBpZiAocGFyZW50ID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50ID0gbnVsbFxyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHRhcmdldEVsZW1lbnQpXHJcbiAgICB9LFxyXG4gICAgaXNTYW1lOiAoZWxlMSwgZWxlMikgPT4ge1xyXG4gICAgICAgIGlmIChlbGUxID09IHVuZGVmaW5lZCB8fCBlbGUyID09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChlbGUxLm5vZGVUeXBlICE9IGVsZTIubm9kZVR5cGUpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoZWxlMS5ub2RlVHlwZSA9PSAxKSB7XHJcbiAgICAgICAgICAgIC8vIG5vZGVcclxuICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgIGVsZTEubm9kZU5hbWUgPT0gZWxlMi5ub2RlTmFtZVxyXG4gICAgICAgICAgICAgICAgJiYgZWxlMS5pZCA9PSBlbGUyLmlkXHJcbiAgICAgICAgICAgICAgICAmJiBlbGUxLmlubmVySFRNTC50cmltKCkgPT0gZWxlMi5pbm5lckhUTUwudHJpbSgpXHJcbiAgICAgICAgICAgICAgICAmJiBlbGUxLmNoaWxkcmVuLmxlbmd0aCA9PSBlbGUyLmNoaWxkcmVuLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgLy8gJiYgZWxlMS5jbGFzc05hbWUgPT0gZWxlMi5jbGFzc05hbWVcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWxlMS5ub2RlVHlwZSA9PSAzKSB7XHJcbiAgICAgICAgICAgIC8vIHRleHQgbm9kZVxyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgLy8gZG9tQXBpLmlzU2FtZShlbGUxLnBhcmVudE5vZGUsIGVsZTIucGFyZW50Tm9kZSkgJiZcclxuICAgICAgICAgICAgICAgIGVsZTEudGV4dENvbnRlbnQgPT0gZWxlMi50ZXh0Q29udGVudFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGlzU2FtZUxheWVyTm9kZShlbGUxLCBlbGUyKXtcclxuICAgICAgICByZXR1cm4gZG9tQXBpLmlzU2FtZShlbGUxLCBlbGUyKVxyXG4gICAgICAgICAgICAgICAgJiYgKGVsZTEuY2hpbGRJbmRleCAmJiBlbGUyLmNoaWxkSW5kZXggICYmICFlbGUxLnBhcmVudE5vZGUubG9zZUluZGV4P1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZTEuY2hpbGRJbmRleCA9PSBlbGUyLmNoaWxkSW5kZXggOlxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkSW5kZXgoZWxlMSkgPT0gY2hpbGRJbmRleChlbGUyKSlcclxuICAgIH0sXHJcbiAgICBjbGFzc0xpc3REaWZmOiAoZWxlMSwgZWxlMikgPT4ge1xyXG4gICAgICAgIGlmIChlbGUxLmNsYXNzTGlzdC5sZW5ndGggIT0gZWxlMi5jbGFzc0xpc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY0xpc3QyQXJyID0gZWxlID0+IHtcclxuICAgICAgICAgICAgbGV0IHJlcyA9IFtdXHJcbiAgICAgICAgICAgIGVsZS5jbGFzc0xpc3QuZm9yRWFjaCh2YWwgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2godmFsKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnJEaWZmZXIoY0xpc3QyQXJyKGVsZTEpLCBjTGlzdDJBcnIoZWxlMikpXHJcbiAgICB9LFxyXG4gICAgYXR0cmlidXRlc0RpZmY6IChlbGUxLCBlbGUyKSA9PiB7XHJcbiAgICAgICAgLy8gKioqIGJhZCBpZGVhISAqKipcclxuICAgICAgICAvLyBpZihlbGUxLmF0dHJpYnV0ZXMubGVuZ3RoIT1lbGUyLmF0dHJpYnV0ZXMubGVuZ3RoKXtcclxuICAgICAgICAvLyAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIGxldCBhdHRyaWJ1dGVzMkFyciA9IGVsZSA9PiB7XHJcbiAgICAgICAgICAgIGxldCByZXMgPSBbXVxyXG4gICAgICAgICAgICBsZXQgdGVtcEN1ciA9IDBcclxuICAgICAgICAgICAgbGV0IGJsYWNrcyA9IFtcImNsYXNzXCJdXHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3VyTm9kZSA9IGVsZS5hdHRyaWJ1dGVzW3RlbXBDdXJdXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VyTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgvKC4rPyk6Lis/L2cudGVzdChjdXJOb2RlLm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsYWNrcy5wdXNoKC8oLis/KTooLispL2cuZXhlYyhjdXJOb2RlLm5hbWUpWzJdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wQ3VyICs9IDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJsYWNrcy5pbmRleE9mKGN1ck5vZGUubmFtZSkgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEN1ciArPSAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGN1ck5vZGUubm9kZVZhbHVlKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGVtcEN1ciArPSAxXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyRGlmZmVyKGF0dHJpYnV0ZXMyQXJyKGVsZTEpLCBhdHRyaWJ1dGVzMkFycihlbGUyKSlcclxuICAgIH0sXHJcbiAgICAvLyAjOTAxXHJcbiAgICAvLyBGYWlsZWQgdG8gZXhlY3V0ZSAnc2V0TmFtZWRJdGVtJyBvbiAnTmFtZWROb2RlTWFwJzpcclxuICAgIC8vIFRoZSBub2RlIHByb3ZpZGVkIGlzIGFuIGF0dHJpYnV0ZSBub2RlIHRoYXQgaXMgYWxyZS1cclxuICAgIC8vIGFkeSBhbiBhdHRyaWJ1dGUgb2YgYW5vdGhlciBFbGVtZW50OyBhdHRyaWJ1dGUgbm9kZS1cclxuICAgIC8vIHMgbXVzdCBiZSBleHBsaWNpdGx5IGNsb25lZC5cclxuICAgIC8vXHJcbiAgICBhdHRyaWJ1dGVzQ2xvbmU6IChlbGUsIHRvKSA9PiB7XHJcbiAgICAgICAgZm9yIChsZXQgYXR0ciBvZiBlbGUuYXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICBlbGUuYXR0cmlidXRlcy5yZW1vdmVOYW1lZEl0ZW0oYXR0ci5uYW1lKVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBhdHRyIG9mIHRvLmF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgZWxlLmF0dHJpYnV0ZXMuc2V0TmFtZWRJdGVtKGF0dHIuY2xvbmVOb2RlKHRydWUpKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBDb21wYXJhYmxlOiAoZWxlMSwgZWxlMikgPT4ge1xyXG4gICAgICAgIGlmIChlbGUxID09IHVuZGVmaW5lZCB8fCBlbGUyID09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChlbGUxLm5vZGVUeXBlICE9IGVsZTIubm9kZVR5cGUpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoZWxlMS5ub2RlVHlwZSA9PSAzKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICBlbGUxLm5vZGVOYW1lID09IGVsZTIubm9kZU5hbWUgJiZcclxuICAgICAgICAgICAgZWxlMS5pZCA9PSBlbGUyLmlkICYmXHJcbiAgICAgICAgICAgIGVsZTEuY2xhc3NOYW1lID09IGVsZTIuY2xhc3NOYW1lXHJcbiAgICAgICAgKVxyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGRvbUFwaVxyXG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/domapi.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime-module.js\");\n/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\nconst req_ele_init = __webpack_require__(/*! ./component/req.comp */ \"./src/component/req.comp.js\")\r\nconst Poi = __webpack_require__(/*! ./Poi */ \"./src/Poi.js\");\r\n\r\nfunction poi_init(){\r\n    if(typeof window != 'undefined')window.Poi = Poi\r\n    try {\r\n        req_ele_init()\r\n    } catch (err) {\r\n        console.warn(err)\r\n    }\r\n    if (console) {\r\n        console.log(`\r\n        poi~\r\n        thx for u using!!!!\r\n        PoiJs is working!have fun.\r\n    \r\n        gitpage: https://zhzluke96.github.io/PoiJs/`);\r\n    }\r\n}\r\n\r\npoi_init()\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXCJyZWdlbmVyYXRvci1ydW50aW1lXCI7XHJcblxyXG5jb25zdCByZXFfZWxlX2luaXQgPSByZXF1aXJlKFwiLi9jb21wb25lbnQvcmVxLmNvbXBcIilcclxuY29uc3QgUG9pID0gcmVxdWlyZShcIi4vUG9pXCIpO1xyXG5cclxuZnVuY3Rpb24gcG9pX2luaXQoKXtcclxuICAgIGlmKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcpd2luZG93LlBvaSA9IFBvaVxyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXFfZWxlX2luaXQoKVxyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGVycilcclxuICAgIH1cclxuICAgIGlmIChjb25zb2xlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFxyXG4gICAgICAgIHBvaX5cclxuICAgICAgICB0aHggZm9yIHUgdXNpbmchISEhXHJcbiAgICAgICAgUG9pSnMgaXMgd29ya2luZyFoYXZlIGZ1bi5cclxuICAgIFxyXG4gICAgICAgIGdpdHBhZ2U6IGh0dHBzOi8vemh6bHVrZTk2LmdpdGh1Yi5pby9Qb2lKcy9gKTtcclxuICAgIH1cclxufVxyXG5cclxucG9pX2luaXQoKSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/stateMachine/fsm.js":
/*!*********************************!*\
  !*** ./src/stateMachine/fsm.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {getEvents} = __webpack_require__(/*! ./util */ \"./src/stateMachine/util.js\")\r\n\r\nclass FSM{\r\n    constructor(conf, data){\r\n        this._config = conf;\r\n        this.data = data\r\n        this.currentState = this._config.initState;\r\n        this._channel= {};\r\n        this.states = this._config.states;\r\n        // this.events = this._config.events;\r\n        if(this._config.events){\r\n            this.defineEvents(this._config.events);\r\n        }else{\r\n            this.defineEvents(getEvents(conf,data));\r\n        }\r\n    }\r\n\r\n    // 表现层\r\n    handleEvents(type, ev) {\r\n        if (!this.currentState) return;\r\n        \r\n        var actionTransitionFunction = this.states[this.currentState][type];\r\n        \r\n        if (!actionTransitionFunction) {\r\n            if (this._config.error) this._config.error.call(this, type, ev)\r\n            return;\r\n        }\r\n        \r\n        var nextState = actionTransitionFunction.call(this, type, ev);\r\n        \r\n        this.currentState = nextState;\r\n    }\r\n    \r\n    // 行为层\r\n    defineEvents(events) {\r\n        for (let k in events) {\r\n            var fn = events[k];\r\n            fn.call(this, e => this.$emit(k, e));\r\n            this.$on(k, this.handleEvents);\r\n        }\r\n    }\r\n\r\n    \r\n    $emit(evName, ev) {\r\n        if (evName in this._channel) {\r\n            this._channel[evName].call(this, evName, ev);\r\n        }\r\n    }\r\n    \r\n    $on(evName, fn) {\r\n        this._channel[evName] = fn;\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    FSM\r\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3RhdGVNYWNoaW5lL2ZzbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zdGF0ZU1hY2hpbmUvZnNtLmpzPzE3M2IiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qge2dldEV2ZW50c30gPSByZXF1aXJlKFwiLi91dGlsXCIpXHJcblxyXG5jbGFzcyBGU017XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25mLCBkYXRhKXtcclxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25mO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGFcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IHRoaXMuX2NvbmZpZy5pbml0U3RhdGU7XHJcbiAgICAgICAgdGhpcy5fY2hhbm5lbD0ge307XHJcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB0aGlzLl9jb25maWcuc3RhdGVzO1xyXG4gICAgICAgIC8vIHRoaXMuZXZlbnRzID0gdGhpcy5fY29uZmlnLmV2ZW50cztcclxuICAgICAgICBpZih0aGlzLl9jb25maWcuZXZlbnRzKXtcclxuICAgICAgICAgICAgdGhpcy5kZWZpbmVFdmVudHModGhpcy5fY29uZmlnLmV2ZW50cyk7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuZGVmaW5lRXZlbnRzKGdldEV2ZW50cyhjb25mLGRhdGEpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g6KGo546w5bGCXHJcbiAgICBoYW5kbGVFdmVudHModHlwZSwgZXYpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY3VycmVudFN0YXRlKSByZXR1cm47XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGFjdGlvblRyYW5zaXRpb25GdW5jdGlvbiA9IHRoaXMuc3RhdGVzW3RoaXMuY3VycmVudFN0YXRlXVt0eXBlXTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoIWFjdGlvblRyYW5zaXRpb25GdW5jdGlvbikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY29uZmlnLmVycm9yKSB0aGlzLl9jb25maWcuZXJyb3IuY2FsbCh0aGlzLCB0eXBlLCBldilcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgbmV4dFN0YXRlID0gYWN0aW9uVHJhbnNpdGlvbkZ1bmN0aW9uLmNhbGwodGhpcywgdHlwZSwgZXYpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gbmV4dFN0YXRlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyDooYzkuLrlsYJcclxuICAgIGRlZmluZUV2ZW50cyhldmVudHMpIHtcclxuICAgICAgICBmb3IgKGxldCBrIGluIGV2ZW50cykge1xyXG4gICAgICAgICAgICB2YXIgZm4gPSBldmVudHNba107XHJcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgZSA9PiB0aGlzLiRlbWl0KGssIGUpKTtcclxuICAgICAgICAgICAgdGhpcy4kb24oaywgdGhpcy5oYW5kbGVFdmVudHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBcclxuICAgICRlbWl0KGV2TmFtZSwgZXYpIHtcclxuICAgICAgICBpZiAoZXZOYW1lIGluIHRoaXMuX2NoYW5uZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2hhbm5lbFtldk5hbWVdLmNhbGwodGhpcywgZXZOYW1lLCBldik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAkb24oZXZOYW1lLCBmbikge1xyXG4gICAgICAgIHRoaXMuX2NoYW5uZWxbZXZOYW1lXSA9IGZuO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEZTTVxyXG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/stateMachine/fsm.js\n");

/***/ }),

/***/ "./src/stateMachine/util.js":
/*!**********************************!*\
  !*** ./src/stateMachine/util.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\r\nfunction getEventKey(states){\r\n    let ret = []\r\n    for(let o of Object.values(states))ret = ret.concat(Object.keys(o))\r\n    return ret\r\n}\r\n\r\nfunction getEvents(conf, data){\r\n    let eventsKey = getEventKey(conf.states)\r\n    let events = {}\r\n    for (const e of eventsKey) {\r\n        events[e] = fn =>data[e] = fn\r\n    }\r\n    return events\r\n}\r\n\r\nmodule.exports = {\r\n    getEvents\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3RhdGVNYWNoaW5lL3V0aWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3RhdGVNYWNoaW5lL3V0aWwuanM/MDg4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuZnVuY3Rpb24gZ2V0RXZlbnRLZXkoc3RhdGVzKXtcclxuICAgIGxldCByZXQgPSBbXVxyXG4gICAgZm9yKGxldCBvIG9mIE9iamVjdC52YWx1ZXMoc3RhdGVzKSlyZXQgPSByZXQuY29uY2F0KE9iamVjdC5rZXlzKG8pKVxyXG4gICAgcmV0dXJuIHJldFxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRFdmVudHMoY29uZiwgZGF0YSl7XHJcbiAgICBsZXQgZXZlbnRzS2V5ID0gZ2V0RXZlbnRLZXkoY29uZi5zdGF0ZXMpXHJcbiAgICBsZXQgZXZlbnRzID0ge31cclxuICAgIGZvciAoY29uc3QgZSBvZiBldmVudHNLZXkpIHtcclxuICAgICAgICBldmVudHNbZV0gPSBmbiA9PmRhdGFbZV0gPSBmblxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV2ZW50c1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGdldEV2ZW50c1xyXG59XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/stateMachine/util.js\n");

/***/ })

/******/ });
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/regenerator-runtime/runtime-module.js":
/*!************************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime-module.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzP2JiZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime-module.js\n");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcz85NmNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXG4gIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKClcbik7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n");

/***/ }),

/***/ "./src/core/Po.js":
/*!************************!*\
  !*** ./src/core/Po.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\r\n    deepClone,\r\n    extend,\r\n    GetAttrElement,\r\n    proxyArr\r\n} = __webpack_require__(/*! ../util/util */ \"./src/util/util.js\");\r\n// const TplEng = require(\"./template\");\r\nconst {\r\n    JxTpl\r\n} = __webpack_require__(/*! ./jx */ \"./src/core/jx.js\")\r\nconst Jsvm = __webpack_require__(/*! ../util/JsVm */ \"./src/util/JsVm.js\");\r\n\r\nlet replaceSubNode = (html, subPos, supper, localPo) => {\r\n    let resloveData = attrs => {\r\n        let res = {}\r\n        if (attrs == undefined || attrs.length == 0) return res\r\n        let arr = attrs.split(\" \")\r\n        let re = new RegExp(`(.+?)=([\"'])(.+?)\\\\2`)\r\n        for (let attr of arr) {\r\n            if (attr.trim() == \"\") continue\r\n            let reg$arr = re.exec(attr)\r\n            res[reg$arr[1]] = reg$arr[3]\r\n        }\r\n        return res\r\n    }\r\n    let reslove = html\r\n    let localCur = 0\r\n    for (let subName in subPos) {\r\n        let sub = subPos[subName]\r\n        let re = new RegExp(\"<(\" + subName + \")(( [^<> ]*)*)>([^<>]*)<\\/\" + subName + \">\", \"gi\")\r\n        let subArr = html.match(re)\r\n        if (!subArr) continue\r\n        for (let _si in subArr) {\r\n            let _s = subArr[_si]\r\n            re = new RegExp(\"<(\" + subName + \")(( [^<> ]*)*)>([^<>]*)<\\/\" + subName + \">\", \"gi\")\r\n            let reg$arr = re.exec(_s)\r\n            let tempData = resloveData(reg$arr[2])\r\n            tempData._content = reg$arr[4]\r\n            if (localPo[localCur] == undefined) {\r\n                localPo.push(sub.Clone(tempData))\r\n            }\r\n            let temp = localPo[localCur].assemble(supper, localCur)\r\n            reslove = reslove.replace(_s, temp)\r\n            localCur += 1\r\n        }\r\n    }\r\n    return reslove\r\n}\r\n\r\nlet _init_DateValueProperty = (data, _ev) => {\r\n    let source = deepClone(data)\r\n    for (let variable in data) {\r\n        let srcVal = data[variable];\r\n        let option = {}\r\n        if (Object.prototype.toString.call(srcVal) == \"[object Array]\") {\r\n            // #101 length problem\r\n            srcVal = proxyArr(srcVal, newVal => {\r\n                _ev.emit(\"SET_\" + variable, newVal);\r\n                _ev.emit(\"_rerender_\");\r\n                if (source[variable].length == newVal.length) return\r\n                source[variable] = newVal;\r\n            })\r\n        }\r\n        if (typeof srcVal === \"function\") {\r\n            if (/_ev.emit/g.test(srcVal.toString()))\r\n                continue\r\n            // function in data\r\n            data[variable] = (...args) => srcVal.apply(data, args)\r\n            continue;\r\n        } else {\r\n            option.get = () => source[variable];\r\n        }\r\n        option.set = newVal => {\r\n            if (source[variable] == newVal) return\r\n            source[variable] = newVal;\r\n            _ev.emit(\"SET_\" + variable, newVal);\r\n            _ev.emit(\"_rerender_\");\r\n        }\r\n        Object.defineProperty(data, variable, option)\r\n        data[variable] = srcVal;\r\n    }\r\n    return data;\r\n}\r\n\r\nlet hitchOnEv = (_evManger, _on, data, localArr) => {\r\n    for (var event_ in _on) {\r\n        if (_on.hasOwnProperty(event_)) {\r\n            let thisOption = _on[event_],\r\n                evName = thisOption.eventName,\r\n                coStr = thisOption.codeStr,\r\n                that_data = data,\r\n                ele = thisOption.ele,\r\n                withData = {};\r\n            if (ele.attributes[\"PoiId\"] != undefined) {\r\n                let _index = ele.attributes[\"PoiId\"].nodeValue\r\n                withData = localArr[_index].data\r\n            }\r\n            _evManger.on(evName, e => {\r\n                if (e.target === ele) {\r\n                    let dataobj = Object.assign(that_data, {\r\n                        e: e,\r\n                        self: e.target\r\n                    }, withData)\r\n                    // require(\"../util/JsVm.js\").micVm(coStr, that_data);\r\n                    Jsvm.safe(coStr, that_data);\r\n                }\r\n            })\r\n        }\r\n    }\r\n    // on_ev end\r\n}\r\nlet hitchBindEv = (_evManger, _bind, data, localArr) => {\r\n    for (var _ev in _bind) {\r\n        if (_bind.hasOwnProperty(_ev)) {\r\n            let thisOption = _bind[_ev],\r\n                evName = thisOption.eventName,\r\n                coStr = thisOption.codeStr,\r\n                that_data = data,\r\n                ele = thisOption.ele,\r\n                withData = {};\r\n            if (ele.attributes[\"PoiId\"] != undefined) {\r\n                let _index = ele.attributes[\"PoiId\"].nodeValue\r\n                withData = localArr[_index].data\r\n            }\r\n            if (evName == \"class\")\r\n                evName = \"className\"\r\n            ele[evName] = Jsvm.safe(\"return(\" + coStr + \")\", Object.assign(deepClone(withData), that_data));\r\n            // init value\r\n            _evManger.on(\"_rerender_\", () => {\r\n                if (ele && ele.parentNode != null) {\r\n                    // require(\"../util/JsVm.js\").micVm(coStr, that_data);\r\n                    ele[evName] = Jsvm.safe(\"return(\" + coStr + \")\", Object.assign(deepClone(withData), that_data))\r\n                }\r\n            })\r\n        }\r\n    }\r\n};\r\n\r\nlet hitchWath = (watch, _ev) => {\r\n    for (let variable in watch) {\r\n        if (typeof watch[variable] === \"function\") {\r\n            _ev.on(\"SET_\" + variable, (newVal) => {\r\n                watch[variable](newVal);\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\nfunction Po(template, data, watch, evManger, subPos, mixwith, Jx) {\r\n    // mixwith\r\n    if (mixwith) extend(data, deepClone(mixwith.$pureData));\r\n\r\n    this.$pureData = deepClone(data)\r\n    // tpl\r\n    this.Clone = _data => {\r\n        return {\r\n            $pureData: Object.assign(deepClone(_data), this.$pureData),\r\n            tpl: this.tpl,\r\n            data: _init_DateValueProperty(deepClone(Object.assign(deepClone(_data), deepClone(this.$pureData))), evManger),\r\n            assemble: function(data, _id) {\r\n                return this.tpl.joint(Object.assign(this.data, data), _id)\r\n            }\r\n        }\r\n    }\r\n    // data\r\n    this.data = _init_DateValueProperty(data, evManger)\r\n    //\r\n    // subPo\r\n    this.tpl = new JxTpl(template, Jx); //new Template(template,subPos);\r\n    if (watch) hitchWath(watch, evManger);\r\n    // error everyday\r\n    //\r\n    this.$localPo = []\r\n    this.assemble = function(data, _id) {\r\n        if (data != undefined) {\r\n            Object.assign(deepClone(data), this.data)\r\n        } else {\r\n            data = deepClone(this.data)\r\n        }\r\n        let res = this.tpl.joint(data, _id)\r\n        if (subPos != undefined) {\r\n            return replaceSubNode(res, subPos, this.data, this.$localPo)\r\n        } else {\r\n            return res\r\n        }\r\n    };\r\n\r\n    this.$bind = patchs => {\r\n        if (patchs.length == 0) return\r\n        let bindArr = [],\r\n            onArr = [];\r\n        let splitEv = ele => {\r\n            if (ele.nodeType == 3) return\r\n            if (ele.children.length != 0) {\r\n                for (let _chi in ele.children) {\r\n                    if (_chi == \"length\") break\r\n                    let _ch = ele.children[_chi]\r\n                    splitEv(_ch)\r\n                }\r\n            }\r\n            let attrs = ele.attributes\r\n            if (attrs.length == 0) return\r\n            const isOn = node => /on:/g.test(node.nodeName);\r\n            const isBind = node => /bind:/g.test(node.nodeName);\r\n\r\n            for (let attri in attrs) {\r\n                let attr = attrs[attri]\r\n                if (isOn(attr)) {\r\n                    onArr.push({\r\n                        ele: ele,\r\n                        eventName: attr.nodeName.split(\":\")[1],\r\n                        codeStr: attr.nodeValue\r\n                    })\r\n                }\r\n                if (isBind(attr)) {\r\n                    bindArr.push({\r\n                        ele: ele,\r\n                        eventName: attr.nodeName.split(\":\")[1],\r\n                        codeStr: attr.nodeValue\r\n                    })\r\n                }\r\n            }\r\n        }\r\n        for (let _patchi in patchs) {\r\n            let _patch = patchs[_patchi]\r\n            if (_patch.option == \"add\" || _patch.option == \"attributesChange\") {\r\n                splitEv(_patch.ele)\r\n            }\r\n        }\r\n        if (onArr.length != 0)\r\n            hitchOnEv(evManger, onArr, this.data, this.$localPo)\r\n        if (bindArr.length != 0)\r\n            hitchBindEv(evManger, bindArr, this.data, this.$localPo);\r\n    };\r\n}\r\n\r\nlet generateSubPo = function(poList, evManger) {\r\n    let res = {}\r\n    for (let poName in poList) {\r\n        let sub = poList[poName],\r\n            tplText\r\n        if (sub.tpl[0] == \"#\") {\r\n            tplText = document.querySelector(sub.tpl).innerHTML;\r\n        } else {\r\n            tplText = sub.tpl\r\n        }\r\n        res[poName] = new Po(tplText, deepClone(sub.data), {}, evManger)\r\n    }\r\n    return res\r\n}\r\n\r\nmodule.exports = {\r\n    Po,\r\n    generateSubPo\r\n};\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9Qby5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb3JlL1BvLmpzPzIyNDQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qge1xyXG4gICAgZGVlcENsb25lLFxyXG4gICAgZXh0ZW5kLFxyXG4gICAgR2V0QXR0ckVsZW1lbnQsXHJcbiAgICBwcm94eUFyclxyXG59ID0gcmVxdWlyZShcIi4uL3V0aWwvdXRpbFwiKTtcclxuLy8gY29uc3QgVHBsRW5nID0gcmVxdWlyZShcIi4vdGVtcGxhdGVcIik7XHJcbmNvbnN0IHtcclxuICAgIEp4VHBsXHJcbn0gPSByZXF1aXJlKFwiLi9qeFwiKVxyXG5jb25zdCBKc3ZtID0gcmVxdWlyZShcIi4uL3V0aWwvSnNWbVwiKTtcclxuXHJcbmxldCByZXBsYWNlU3ViTm9kZSA9IChodG1sLCBzdWJQb3MsIHN1cHBlciwgbG9jYWxQbykgPT4ge1xyXG4gICAgbGV0IHJlc2xvdmVEYXRhID0gYXR0cnMgPT4ge1xyXG4gICAgICAgIGxldCByZXMgPSB7fVxyXG4gICAgICAgIGlmIChhdHRycyA9PSB1bmRlZmluZWQgfHwgYXR0cnMubGVuZ3RoID09IDApIHJldHVybiByZXNcclxuICAgICAgICBsZXQgYXJyID0gYXR0cnMuc3BsaXQoXCIgXCIpXHJcbiAgICAgICAgbGV0IHJlID0gbmV3IFJlZ0V4cChgKC4rPyk9KFtcIiddKSguKz8pXFxcXDJgKVxyXG4gICAgICAgIGZvciAobGV0IGF0dHIgb2YgYXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChhdHRyLnRyaW0oKSA9PSBcIlwiKSBjb250aW51ZVxyXG4gICAgICAgICAgICBsZXQgcmVnJGFyciA9IHJlLmV4ZWMoYXR0cilcclxuICAgICAgICAgICAgcmVzW3JlZyRhcnJbMV1dID0gcmVnJGFyclszXVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzXHJcbiAgICB9XHJcbiAgICBsZXQgcmVzbG92ZSA9IGh0bWxcclxuICAgIGxldCBsb2NhbEN1ciA9IDBcclxuICAgIGZvciAobGV0IHN1Yk5hbWUgaW4gc3ViUG9zKSB7XHJcbiAgICAgICAgbGV0IHN1YiA9IHN1YlBvc1tzdWJOYW1lXVxyXG4gICAgICAgIGxldCByZSA9IG5ldyBSZWdFeHAoXCI8KFwiICsgc3ViTmFtZSArIFwiKSgoIFtePD4gXSopKik+KFtePD5dKik8XFwvXCIgKyBzdWJOYW1lICsgXCI+XCIsIFwiZ2lcIilcclxuICAgICAgICBsZXQgc3ViQXJyID0gaHRtbC5tYXRjaChyZSlcclxuICAgICAgICBpZiAoIXN1YkFycikgY29udGludWVcclxuICAgICAgICBmb3IgKGxldCBfc2kgaW4gc3ViQXJyKSB7XHJcbiAgICAgICAgICAgIGxldCBfcyA9IHN1YkFycltfc2ldXHJcbiAgICAgICAgICAgIHJlID0gbmV3IFJlZ0V4cChcIjwoXCIgKyBzdWJOYW1lICsgXCIpKCggW148PiBdKikqKT4oW148Pl0qKTxcXC9cIiArIHN1Yk5hbWUgKyBcIj5cIiwgXCJnaVwiKVxyXG4gICAgICAgICAgICBsZXQgcmVnJGFyciA9IHJlLmV4ZWMoX3MpXHJcbiAgICAgICAgICAgIGxldCB0ZW1wRGF0YSA9IHJlc2xvdmVEYXRhKHJlZyRhcnJbMl0pXHJcbiAgICAgICAgICAgIHRlbXBEYXRhLl9jb250ZW50ID0gcmVnJGFycls0XVxyXG4gICAgICAgICAgICBpZiAobG9jYWxQb1tsb2NhbEN1cl0gPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbFBvLnB1c2goc3ViLkNsb25lKHRlbXBEYXRhKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgdGVtcCA9IGxvY2FsUG9bbG9jYWxDdXJdLmFzc2VtYmxlKHN1cHBlciwgbG9jYWxDdXIpXHJcbiAgICAgICAgICAgIHJlc2xvdmUgPSByZXNsb3ZlLnJlcGxhY2UoX3MsIHRlbXApXHJcbiAgICAgICAgICAgIGxvY2FsQ3VyICs9IDFcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzbG92ZVxyXG59XHJcblxyXG5sZXQgX2luaXRfRGF0ZVZhbHVlUHJvcGVydHkgPSAoZGF0YSwgX2V2KSA9PiB7XHJcbiAgICBsZXQgc291cmNlID0gZGVlcENsb25lKGRhdGEpXHJcbiAgICBmb3IgKGxldCB2YXJpYWJsZSBpbiBkYXRhKSB7XHJcbiAgICAgICAgbGV0IHNyY1ZhbCA9IGRhdGFbdmFyaWFibGVdO1xyXG4gICAgICAgIGxldCBvcHRpb24gPSB7fVxyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3JjVmFsKSA9PSBcIltvYmplY3QgQXJyYXldXCIpIHtcclxuICAgICAgICAgICAgLy8gIzEwMSBsZW5ndGggcHJvYmxlbVxyXG4gICAgICAgICAgICBzcmNWYWwgPSBwcm94eUFycihzcmNWYWwsIG5ld1ZhbCA9PiB7XHJcbiAgICAgICAgICAgICAgICBfZXYuZW1pdChcIlNFVF9cIiArIHZhcmlhYmxlLCBuZXdWYWwpO1xyXG4gICAgICAgICAgICAgICAgX2V2LmVtaXQoXCJfcmVyZW5kZXJfXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVt2YXJpYWJsZV0ubGVuZ3RoID09IG5ld1ZhbC5sZW5ndGgpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgc291cmNlW3ZhcmlhYmxlXSA9IG5ld1ZhbDtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzcmNWYWwgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICBpZiAoL19ldi5lbWl0L2cudGVzdChzcmNWYWwudG9TdHJpbmcoKSkpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgICAvLyBmdW5jdGlvbiBpbiBkYXRhXHJcbiAgICAgICAgICAgIGRhdGFbdmFyaWFibGVdID0gKC4uLmFyZ3MpID0+IHNyY1ZhbC5hcHBseShkYXRhLCBhcmdzKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRpb24uZ2V0ID0gKCkgPT4gc291cmNlW3ZhcmlhYmxlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3B0aW9uLnNldCA9IG5ld1ZhbCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2VbdmFyaWFibGVdID09IG5ld1ZhbCkgcmV0dXJuXHJcbiAgICAgICAgICAgIHNvdXJjZVt2YXJpYWJsZV0gPSBuZXdWYWw7XHJcbiAgICAgICAgICAgIF9ldi5lbWl0KFwiU0VUX1wiICsgdmFyaWFibGUsIG5ld1ZhbCk7XHJcbiAgICAgICAgICAgIF9ldi5lbWl0KFwiX3JlcmVuZGVyX1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGEsIHZhcmlhYmxlLCBvcHRpb24pXHJcbiAgICAgICAgZGF0YVt2YXJpYWJsZV0gPSBzcmNWYWw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YTtcclxufVxyXG5cclxubGV0IGhpdGNoT25FdiA9IChfZXZNYW5nZXIsIF9vbiwgZGF0YSwgbG9jYWxBcnIpID0+IHtcclxuICAgIGZvciAodmFyIGV2ZW50XyBpbiBfb24pIHtcclxuICAgICAgICBpZiAoX29uLmhhc093blByb3BlcnR5KGV2ZW50XykpIHtcclxuICAgICAgICAgICAgbGV0IHRoaXNPcHRpb24gPSBfb25bZXZlbnRfXSxcclxuICAgICAgICAgICAgICAgIGV2TmFtZSA9IHRoaXNPcHRpb24uZXZlbnROYW1lLFxyXG4gICAgICAgICAgICAgICAgY29TdHIgPSB0aGlzT3B0aW9uLmNvZGVTdHIsXHJcbiAgICAgICAgICAgICAgICB0aGF0X2RhdGEgPSBkYXRhLFxyXG4gICAgICAgICAgICAgICAgZWxlID0gdGhpc09wdGlvbi5lbGUsXHJcbiAgICAgICAgICAgICAgICB3aXRoRGF0YSA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoZWxlLmF0dHJpYnV0ZXNbXCJQb2lJZFwiXSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBfaW5kZXggPSBlbGUuYXR0cmlidXRlc1tcIlBvaUlkXCJdLm5vZGVWYWx1ZVxyXG4gICAgICAgICAgICAgICAgd2l0aERhdGEgPSBsb2NhbEFycltfaW5kZXhdLmRhdGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfZXZNYW5nZXIub24oZXZOYW1lLCBlID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlLnRhcmdldCA9PT0gZWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFvYmogPSBPYmplY3QuYXNzaWduKHRoYXRfZGF0YSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlOiBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmOiBlLnRhcmdldFxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHdpdGhEYXRhKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcXVpcmUoXCIuLi91dGlsL0pzVm0uanNcIikubWljVm0oY29TdHIsIHRoYXRfZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgSnN2bS5zYWZlKGNvU3RyLCB0aGF0X2RhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG9uX2V2IGVuZFxyXG59XHJcbmxldCBoaXRjaEJpbmRFdiA9IChfZXZNYW5nZXIsIF9iaW5kLCBkYXRhLCBsb2NhbEFycikgPT4ge1xyXG4gICAgZm9yICh2YXIgX2V2IGluIF9iaW5kKSB7XHJcbiAgICAgICAgaWYgKF9iaW5kLmhhc093blByb3BlcnR5KF9ldikpIHtcclxuICAgICAgICAgICAgbGV0IHRoaXNPcHRpb24gPSBfYmluZFtfZXZdLFxyXG4gICAgICAgICAgICAgICAgZXZOYW1lID0gdGhpc09wdGlvbi5ldmVudE5hbWUsXHJcbiAgICAgICAgICAgICAgICBjb1N0ciA9IHRoaXNPcHRpb24uY29kZVN0cixcclxuICAgICAgICAgICAgICAgIHRoYXRfZGF0YSA9IGRhdGEsXHJcbiAgICAgICAgICAgICAgICBlbGUgPSB0aGlzT3B0aW9uLmVsZSxcclxuICAgICAgICAgICAgICAgIHdpdGhEYXRhID0ge307XHJcbiAgICAgICAgICAgIGlmIChlbGUuYXR0cmlidXRlc1tcIlBvaUlkXCJdICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IF9pbmRleCA9IGVsZS5hdHRyaWJ1dGVzW1wiUG9pSWRcIl0ubm9kZVZhbHVlXHJcbiAgICAgICAgICAgICAgICB3aXRoRGF0YSA9IGxvY2FsQXJyW19pbmRleF0uZGF0YVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChldk5hbWUgPT0gXCJjbGFzc1wiKVxyXG4gICAgICAgICAgICAgICAgZXZOYW1lID0gXCJjbGFzc05hbWVcIlxyXG4gICAgICAgICAgICBlbGVbZXZOYW1lXSA9IEpzdm0uc2FmZShcInJldHVybihcIiArIGNvU3RyICsgXCIpXCIsIE9iamVjdC5hc3NpZ24oZGVlcENsb25lKHdpdGhEYXRhKSwgdGhhdF9kYXRhKSk7XHJcbiAgICAgICAgICAgIC8vIGluaXQgdmFsdWVcclxuICAgICAgICAgICAgX2V2TWFuZ2VyLm9uKFwiX3JlcmVuZGVyX1wiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlICYmIGVsZS5wYXJlbnROb2RlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1aXJlKFwiLi4vdXRpbC9Kc1ZtLmpzXCIpLm1pY1ZtKGNvU3RyLCB0aGF0X2RhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZVtldk5hbWVdID0gSnN2bS5zYWZlKFwicmV0dXJuKFwiICsgY29TdHIgKyBcIilcIiwgT2JqZWN0LmFzc2lnbihkZWVwQ2xvbmUod2l0aERhdGEpLCB0aGF0X2RhdGEpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbmxldCBoaXRjaFdhdGggPSAod2F0Y2gsIF9ldikgPT4ge1xyXG4gICAgZm9yIChsZXQgdmFyaWFibGUgaW4gd2F0Y2gpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdhdGNoW3ZhcmlhYmxlXSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIF9ldi5vbihcIlNFVF9cIiArIHZhcmlhYmxlLCAobmV3VmFsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB3YXRjaFt2YXJpYWJsZV0obmV3VmFsKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFBvKHRlbXBsYXRlLCBkYXRhLCB3YXRjaCwgZXZNYW5nZXIsIHN1YlBvcywgbWl4d2l0aCwgSngpIHtcclxuICAgIC8vIG1peHdpdGhcclxuICAgIGlmIChtaXh3aXRoKSBleHRlbmQoZGF0YSwgZGVlcENsb25lKG1peHdpdGguJHB1cmVEYXRhKSk7XHJcblxyXG4gICAgdGhpcy4kcHVyZURhdGEgPSBkZWVwQ2xvbmUoZGF0YSlcclxuICAgIC8vIHRwbFxyXG4gICAgdGhpcy5DbG9uZSA9IF9kYXRhID0+IHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAkcHVyZURhdGE6IE9iamVjdC5hc3NpZ24oZGVlcENsb25lKF9kYXRhKSwgdGhpcy4kcHVyZURhdGEpLFxyXG4gICAgICAgICAgICB0cGw6IHRoaXMudHBsLFxyXG4gICAgICAgICAgICBkYXRhOiBfaW5pdF9EYXRlVmFsdWVQcm9wZXJ0eShkZWVwQ2xvbmUoT2JqZWN0LmFzc2lnbihkZWVwQ2xvbmUoX2RhdGEpLCBkZWVwQ2xvbmUodGhpcy4kcHVyZURhdGEpKSksIGV2TWFuZ2VyKSxcclxuICAgICAgICAgICAgYXNzZW1ibGU6IGZ1bmN0aW9uKGRhdGEsIF9pZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHBsLmpvaW50KE9iamVjdC5hc3NpZ24odGhpcy5kYXRhLCBkYXRhKSwgX2lkKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZGF0YVxyXG4gICAgdGhpcy5kYXRhID0gX2luaXRfRGF0ZVZhbHVlUHJvcGVydHkoZGF0YSwgZXZNYW5nZXIpXHJcbiAgICAvL1xyXG4gICAgLy8gc3ViUG9cclxuICAgIHRoaXMudHBsID0gbmV3IEp4VHBsKHRlbXBsYXRlLCBKeCk7IC8vbmV3IFRlbXBsYXRlKHRlbXBsYXRlLHN1YlBvcyk7XHJcbiAgICBpZiAod2F0Y2gpIGhpdGNoV2F0aCh3YXRjaCwgZXZNYW5nZXIpO1xyXG4gICAgLy8gZXJyb3IgZXZlcnlkYXlcclxuICAgIC8vXHJcbiAgICB0aGlzLiRsb2NhbFBvID0gW11cclxuICAgIHRoaXMuYXNzZW1ibGUgPSBmdW5jdGlvbihkYXRhLCBfaWQpIHtcclxuICAgICAgICBpZiAoZGF0YSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihkZWVwQ2xvbmUoZGF0YSksIHRoaXMuZGF0YSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkYXRhID0gZGVlcENsb25lKHRoaXMuZGF0YSlcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlcyA9IHRoaXMudHBsLmpvaW50KGRhdGEsIF9pZClcclxuICAgICAgICBpZiAoc3ViUG9zICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZVN1Yk5vZGUocmVzLCBzdWJQb3MsIHRoaXMuZGF0YSwgdGhpcy4kbG9jYWxQbylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLiRiaW5kID0gcGF0Y2hzID0+IHtcclxuICAgICAgICBpZiAocGF0Y2hzLmxlbmd0aCA9PSAwKSByZXR1cm5cclxuICAgICAgICBsZXQgYmluZEFyciA9IFtdLFxyXG4gICAgICAgICAgICBvbkFyciA9IFtdO1xyXG4gICAgICAgIGxldCBzcGxpdEV2ID0gZWxlID0+IHtcclxuICAgICAgICAgICAgaWYgKGVsZS5ub2RlVHlwZSA9PSAzKSByZXR1cm5cclxuICAgICAgICAgICAgaWYgKGVsZS5jaGlsZHJlbi5sZW5ndGggIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgX2NoaSBpbiBlbGUuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2NoaSA9PSBcImxlbmd0aFwiKSBicmVha1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBfY2ggPSBlbGUuY2hpbGRyZW5bX2NoaV1cclxuICAgICAgICAgICAgICAgICAgICBzcGxpdEV2KF9jaClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgYXR0cnMgPSBlbGUuYXR0cmlidXRlc1xyXG4gICAgICAgICAgICBpZiAoYXR0cnMubGVuZ3RoID09IDApIHJldHVyblxyXG4gICAgICAgICAgICBjb25zdCBpc09uID0gbm9kZSA9PiAvb246L2cudGVzdChub2RlLm5vZGVOYW1lKTtcclxuICAgICAgICAgICAgY29uc3QgaXNCaW5kID0gbm9kZSA9PiAvYmluZDovZy50ZXN0KG5vZGUubm9kZU5hbWUpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgYXR0cmkgaW4gYXR0cnMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBhdHRyID0gYXR0cnNbYXR0cmldXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPbihhdHRyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uQXJyLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGU6IGVsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lOiBhdHRyLm5vZGVOYW1lLnNwbGl0KFwiOlwiKVsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZVN0cjogYXR0ci5ub2RlVmFsdWVcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzQmluZChhdHRyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJpbmRBcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZTogZWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudE5hbWU6IGF0dHIubm9kZU5hbWUuc3BsaXQoXCI6XCIpWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlU3RyOiBhdHRyLm5vZGVWYWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgX3BhdGNoaSBpbiBwYXRjaHMpIHtcclxuICAgICAgICAgICAgbGV0IF9wYXRjaCA9IHBhdGNoc1tfcGF0Y2hpXVxyXG4gICAgICAgICAgICBpZiAoX3BhdGNoLm9wdGlvbiA9PSBcImFkZFwiIHx8IF9wYXRjaC5vcHRpb24gPT0gXCJhdHRyaWJ1dGVzQ2hhbmdlXCIpIHtcclxuICAgICAgICAgICAgICAgIHNwbGl0RXYoX3BhdGNoLmVsZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob25BcnIubGVuZ3RoICE9IDApXHJcbiAgICAgICAgICAgIGhpdGNoT25Fdihldk1hbmdlciwgb25BcnIsIHRoaXMuZGF0YSwgdGhpcy4kbG9jYWxQbylcclxuICAgICAgICBpZiAoYmluZEFyci5sZW5ndGggIT0gMClcclxuICAgICAgICAgICAgaGl0Y2hCaW5kRXYoZXZNYW5nZXIsIGJpbmRBcnIsIHRoaXMuZGF0YSwgdGhpcy4kbG9jYWxQbyk7XHJcbiAgICB9O1xyXG59XHJcblxyXG5sZXQgZ2VuZXJhdGVTdWJQbyA9IGZ1bmN0aW9uKHBvTGlzdCwgZXZNYW5nZXIpIHtcclxuICAgIGxldCByZXMgPSB7fVxyXG4gICAgZm9yIChsZXQgcG9OYW1lIGluIHBvTGlzdCkge1xyXG4gICAgICAgIGxldCBzdWIgPSBwb0xpc3RbcG9OYW1lXSxcclxuICAgICAgICAgICAgdHBsVGV4dFxyXG4gICAgICAgIGlmIChzdWIudHBsWzBdID09IFwiI1wiKSB7XHJcbiAgICAgICAgICAgIHRwbFRleHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHN1Yi50cGwpLmlubmVySFRNTDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0cGxUZXh0ID0gc3ViLnRwbFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXNbcG9OYW1lXSA9IG5ldyBQbyh0cGxUZXh0LCBkZWVwQ2xvbmUoc3ViLmRhdGEpLCB7fSwgZXZNYW5nZXIpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgUG8sXHJcbiAgICBnZW5lcmF0ZVN1YlBvXHJcbn07XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/Po.js\n");

/***/ }),

/***/ "./src/core/Poi.js":
/*!*************************!*\
  !*** ./src/core/Poi.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const EventObj = __webpack_require__(/*! ./event */ \"./src/core/event.js\");\r\nconst diff = __webpack_require__(/*! ./diff */ \"./src/core/diff.js\");\r\nconst {\r\n    Po,\r\n    generateSubPo\r\n} = __webpack_require__(/*! ./Po */ \"./src/core/Po.js\");\r\nconst{\r\n    $,\r\n    HTMLClean\r\n} = __webpack_require__(/*! ../util/util */ \"./src/util/util.js\")\r\nconst {\r\n    Jx\r\n} = __webpack_require__(/*! ./jx */ \"./src/core/jx.js\")\r\nconst GlobalJxEnviron = new Jx()\r\n\r\nfunction new_INT_OBJ(){\r\n    return {\r\n        wtever: false, // async Interrupt flag\r\n        clear: null // Interrupt call\r\n    }\r\n}\r\n\r\nfunction async_diff(ctx) {\r\n    if (ctx.current_render_INT_OBJ) {\r\n        // Interrupt check\r\n        ctx.current_render_INT_OBJ.wtever = true;\r\n        if (ctx.current_render_INT_OBJ.clear)\r\n            ctx.current_render_INT_OBJ.clear()\r\n        // unblock async render task\r\n        ctx.current_render_INT_OBJ = new_INT_OBJ();\r\n    }\r\n    (async () => {\r\n        // render mount before\r\n        if(ctx.mounts && ctx.mounts.renderBefore)\r\n            ctx.mounts.renderBefore.call(ctx.Po.data, ctx.el)\r\n\r\n        // dirty checking maybe\r\n        let patchArr = await diff(ctx.el, ctx.Po.assemble(), ctx.current_render_INT_OBJ);\r\n        ctx.Po.$bind(patchArr)\r\n\r\n        // render mount after\r\n        if(ctx.mounts && ctx.mounts.renderAfter && patchArr.length != 0)\r\n            ctx.mounts.renderAfter.call(ctx.Po.data, ctx.el)\r\n    })();\r\n}\r\n\r\nfunction polyOptions(options){\r\n    // poly old ver\r\n    let {\r\n        el:_ele,\r\n        ele,\r\n        tpl,\r\n        template,\r\n        data,\r\n        watch,\r\n        subPos:components,\r\n        mixwith,\r\n        mount:mounts,\r\n        mounted:_mounts\r\n    } = options;\r\n    return {\r\n        el: ele || _ele,\r\n        tpl: template || tpl,\r\n        data,\r\n        watch,\r\n        components,\r\n        mixwith,\r\n        mount: mounts || _mounts\r\n    }\r\n}\r\n\r\nfunction _Poi(options) {\r\n    // options\r\n    let {\r\n        el:ele,\r\n        tpl:template,\r\n        data,\r\n        watch,\r\n        components:subPos,\r\n        mixwith,\r\n        mount:mounts\r\n    } = polyOptions(options);\r\n    this.el = ele;\r\n    // on,emit\r\n    // bind evlisenter\r\n    this.Event = new EventObj(this.el);\r\n\r\n    // #401 babel es5 leads to mistakes\r\n    \r\n    // async diff render\r\n    this.current_render_INT_OBJ = new_INT_OBJ();\r\n    this.render = () => async_diff(this);\r\n    \r\n    // sub components ====\\\\\r\n    let subPoi = subPos ? generateSubPo(subPos, this.Event) : undefined\r\n    // #402 mounted init function\r\n    if (mixwith && mixwith.mounts){\r\n        for (let key in mixwith.mounts) {\r\n            if (key in mounts)\r\n            mounts[key] = () => {\r\n                mixwith.mounts[key].apply(this)\r\n                mounts[key].apply(this)\r\n            };\r\n            else mounts[key] = mixwith.mounts[key];\r\n        }\r\n    }\r\n    this.mounts = mounts\r\n    // sub components ====\\\\\r\n    // instance\r\n    this.Po = new Po(template, data, watch, this.Event, subPoi, mixwith, GlobalJxEnviron);\r\n    \r\n    // init hook\r\n    if (mounts && mounts.init) mounts.init.apply(this.Po.data);\r\n\r\n    // event on rerender\r\n    this.Event.on(\"_rerender_\", () => this.render())\r\n    // first render\r\n    this.el.innerHTML = \"\";\r\n    this.render();\r\n    \r\n    const that = this;\r\n    // public api\r\n    return {\r\n        $ele: ele,\r\n        $data: that.Po.data,\r\n        $on(...args){\r\n            that.Event.on.apply(that.Event, args)\r\n        },\r\n        $emit(...args){\r\n            that.Event.emit.apply(that.Event, arguments)\r\n        }\r\n    };\r\n}\r\n\r\nfunction optionsWapper(options){\r\n    // ele option\r\n    if(!(options.el instanceof Element)){\r\n        let s = options.el[0];\r\n        if(s == \"#\")options.el = $(options.el)\r\n        else options.el = $(\"#\" + options.el)\r\n    }\r\n    // tpl option\r\n    if(options.tpl){\r\n        let s = options.tpl[0];\r\n        if(s == \"#\"){\r\n            // tpl selector\r\n            options.tpl = HTMLClean($(options.tpl).innerHTML);\r\n        }\r\n    }else{\r\n        options.tpl = HTMLClean(options.el.innerHTML)\r\n    }\r\n\r\n    // other ...\r\n    return options\r\n}\r\n\r\nfunction Poi_constructor(options) {\r\n    options = optionsWapper(options)\r\n    let that = Object.create(null);\r\n    that = _Poi.call(that, options);\r\n    return that;\r\n}\r\nPoi_constructor.prototype.mod = (...args) => GlobalJxEnviron.mod.apply(GlobalJxEnviron,args)\r\n\r\nmodule.exports = Poi_constructor\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9Qb2kuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9Qb2kuanM/OGI3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFdmVudE9iaiA9IHJlcXVpcmUoXCIuL2V2ZW50XCIpO1xyXG5jb25zdCBkaWZmID0gcmVxdWlyZShcIi4vZGlmZlwiKTtcclxuY29uc3Qge1xyXG4gICAgUG8sXHJcbiAgICBnZW5lcmF0ZVN1YlBvXHJcbn0gPSByZXF1aXJlKFwiLi9Qb1wiKTtcclxuY29uc3R7XHJcbiAgICAkLFxyXG4gICAgSFRNTENsZWFuXHJcbn0gPSByZXF1aXJlKFwiLi4vdXRpbC91dGlsXCIpXHJcbmNvbnN0IHtcclxuICAgIEp4XHJcbn0gPSByZXF1aXJlKFwiLi9qeFwiKVxyXG5jb25zdCBHbG9iYWxKeEVudmlyb24gPSBuZXcgSngoKVxyXG5cclxuZnVuY3Rpb24gbmV3X0lOVF9PQkooKXtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgd3RldmVyOiBmYWxzZSwgLy8gYXN5bmMgSW50ZXJydXB0IGZsYWdcclxuICAgICAgICBjbGVhcjogbnVsbCAvLyBJbnRlcnJ1cHQgY2FsbFxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhc3luY19kaWZmKGN0eCkge1xyXG4gICAgaWYgKGN0eC5jdXJyZW50X3JlbmRlcl9JTlRfT0JKKSB7XHJcbiAgICAgICAgLy8gSW50ZXJydXB0IGNoZWNrXHJcbiAgICAgICAgY3R4LmN1cnJlbnRfcmVuZGVyX0lOVF9PQkoud3RldmVyID0gdHJ1ZTtcclxuICAgICAgICBpZiAoY3R4LmN1cnJlbnRfcmVuZGVyX0lOVF9PQkouY2xlYXIpXHJcbiAgICAgICAgICAgIGN0eC5jdXJyZW50X3JlbmRlcl9JTlRfT0JKLmNsZWFyKClcclxuICAgICAgICAvLyB1bmJsb2NrIGFzeW5jIHJlbmRlciB0YXNrXHJcbiAgICAgICAgY3R4LmN1cnJlbnRfcmVuZGVyX0lOVF9PQkogPSBuZXdfSU5UX09CSigpO1xyXG4gICAgfVxyXG4gICAgKGFzeW5jICgpID0+IHtcclxuICAgICAgICAvLyByZW5kZXIgbW91bnQgYmVmb3JlXHJcbiAgICAgICAgaWYoY3R4Lm1vdW50cyAmJiBjdHgubW91bnRzLnJlbmRlckJlZm9yZSlcclxuICAgICAgICAgICAgY3R4Lm1vdW50cy5yZW5kZXJCZWZvcmUuY2FsbChjdHguUG8uZGF0YSwgY3R4LmVsKVxyXG5cclxuICAgICAgICAvLyBkaXJ0eSBjaGVja2luZyBtYXliZVxyXG4gICAgICAgIGxldCBwYXRjaEFyciA9IGF3YWl0IGRpZmYoY3R4LmVsLCBjdHguUG8uYXNzZW1ibGUoKSwgY3R4LmN1cnJlbnRfcmVuZGVyX0lOVF9PQkopO1xyXG4gICAgICAgIGN0eC5Qby4kYmluZChwYXRjaEFycilcclxuXHJcbiAgICAgICAgLy8gcmVuZGVyIG1vdW50IGFmdGVyXHJcbiAgICAgICAgaWYoY3R4Lm1vdW50cyAmJiBjdHgubW91bnRzLnJlbmRlckFmdGVyICYmIHBhdGNoQXJyLmxlbmd0aCAhPSAwKVxyXG4gICAgICAgICAgICBjdHgubW91bnRzLnJlbmRlckFmdGVyLmNhbGwoY3R4LlBvLmRhdGEsIGN0eC5lbClcclxuICAgIH0pKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBvbHlPcHRpb25zKG9wdGlvbnMpe1xyXG4gICAgLy8gcG9seSBvbGQgdmVyXHJcbiAgICBsZXQge1xyXG4gICAgICAgIGVsOl9lbGUsXHJcbiAgICAgICAgZWxlLFxyXG4gICAgICAgIHRwbCxcclxuICAgICAgICB0ZW1wbGF0ZSxcclxuICAgICAgICBkYXRhLFxyXG4gICAgICAgIHdhdGNoLFxyXG4gICAgICAgIHN1YlBvczpjb21wb25lbnRzLFxyXG4gICAgICAgIG1peHdpdGgsXHJcbiAgICAgICAgbW91bnQ6bW91bnRzLFxyXG4gICAgICAgIG1vdW50ZWQ6X21vdW50c1xyXG4gICAgfSA9IG9wdGlvbnM7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGVsOiBlbGUgfHwgX2VsZSxcclxuICAgICAgICB0cGw6IHRlbXBsYXRlIHx8IHRwbCxcclxuICAgICAgICBkYXRhLFxyXG4gICAgICAgIHdhdGNoLFxyXG4gICAgICAgIGNvbXBvbmVudHMsXHJcbiAgICAgICAgbWl4d2l0aCxcclxuICAgICAgICBtb3VudDogbW91bnRzIHx8IF9tb3VudHNcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gX1BvaShvcHRpb25zKSB7XHJcbiAgICAvLyBvcHRpb25zXHJcbiAgICBsZXQge1xyXG4gICAgICAgIGVsOmVsZSxcclxuICAgICAgICB0cGw6dGVtcGxhdGUsXHJcbiAgICAgICAgZGF0YSxcclxuICAgICAgICB3YXRjaCxcclxuICAgICAgICBjb21wb25lbnRzOnN1YlBvcyxcclxuICAgICAgICBtaXh3aXRoLFxyXG4gICAgICAgIG1vdW50Om1vdW50c1xyXG4gICAgfSA9IHBvbHlPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgdGhpcy5lbCA9IGVsZTtcclxuICAgIC8vIG9uLGVtaXRcclxuICAgIC8vIGJpbmQgZXZsaXNlbnRlclxyXG4gICAgdGhpcy5FdmVudCA9IG5ldyBFdmVudE9iaih0aGlzLmVsKTtcclxuXHJcbiAgICAvLyAjNDAxIGJhYmVsIGVzNSBsZWFkcyB0byBtaXN0YWtlc1xyXG4gICAgXHJcbiAgICAvLyBhc3luYyBkaWZmIHJlbmRlclxyXG4gICAgdGhpcy5jdXJyZW50X3JlbmRlcl9JTlRfT0JKID0gbmV3X0lOVF9PQkooKTtcclxuICAgIHRoaXMucmVuZGVyID0gKCkgPT4gYXN5bmNfZGlmZih0aGlzKTtcclxuICAgIFxyXG4gICAgLy8gc3ViIGNvbXBvbmVudHMgPT09PVxcXFxcclxuICAgIGxldCBzdWJQb2kgPSBzdWJQb3MgPyBnZW5lcmF0ZVN1YlBvKHN1YlBvcywgdGhpcy5FdmVudCkgOiB1bmRlZmluZWRcclxuICAgIC8vICM0MDIgbW91bnRlZCBpbml0IGZ1bmN0aW9uXHJcbiAgICBpZiAobWl4d2l0aCAmJiBtaXh3aXRoLm1vdW50cyl7XHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIG1peHdpdGgubW91bnRzKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgaW4gbW91bnRzKVxyXG4gICAgICAgICAgICBtb3VudHNba2V5XSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIG1peHdpdGgubW91bnRzW2tleV0uYXBwbHkodGhpcylcclxuICAgICAgICAgICAgICAgIG1vdW50c1trZXldLmFwcGx5KHRoaXMpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGVsc2UgbW91bnRzW2tleV0gPSBtaXh3aXRoLm1vdW50c1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMubW91bnRzID0gbW91bnRzXHJcbiAgICAvLyBzdWIgY29tcG9uZW50cyA9PT09XFxcXFxyXG4gICAgLy8gaW5zdGFuY2VcclxuICAgIHRoaXMuUG8gPSBuZXcgUG8odGVtcGxhdGUsIGRhdGEsIHdhdGNoLCB0aGlzLkV2ZW50LCBzdWJQb2ksIG1peHdpdGgsIEdsb2JhbEp4RW52aXJvbik7XHJcbiAgICBcclxuICAgIC8vIGluaXQgaG9va1xyXG4gICAgaWYgKG1vdW50cyAmJiBtb3VudHMuaW5pdCkgbW91bnRzLmluaXQuYXBwbHkodGhpcy5Qby5kYXRhKTtcclxuXHJcbiAgICAvLyBldmVudCBvbiByZXJlbmRlclxyXG4gICAgdGhpcy5FdmVudC5vbihcIl9yZXJlbmRlcl9cIiwgKCkgPT4gdGhpcy5yZW5kZXIoKSlcclxuICAgIC8vIGZpcnN0IHJlbmRlclxyXG4gICAgdGhpcy5lbC5pbm5lckhUTUwgPSBcIlwiO1xyXG4gICAgdGhpcy5yZW5kZXIoKTtcclxuICAgIFxyXG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XHJcbiAgICAvLyBwdWJsaWMgYXBpXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgICRlbGU6IGVsZSxcclxuICAgICAgICAkZGF0YTogdGhhdC5Qby5kYXRhLFxyXG4gICAgICAgICRvbiguLi5hcmdzKXtcclxuICAgICAgICAgICAgdGhhdC5FdmVudC5vbi5hcHBseSh0aGF0LkV2ZW50LCBhcmdzKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJGVtaXQoLi4uYXJncyl7XHJcbiAgICAgICAgICAgIHRoYXQuRXZlbnQuZW1pdC5hcHBseSh0aGF0LkV2ZW50LCBhcmd1bWVudHMpXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gb3B0aW9uc1dhcHBlcihvcHRpb25zKXtcclxuICAgIC8vIGVsZSBvcHRpb25cclxuICAgIGlmKCEob3B0aW9ucy5lbCBpbnN0YW5jZW9mIEVsZW1lbnQpKXtcclxuICAgICAgICBsZXQgcyA9IG9wdGlvbnMuZWxbMF07XHJcbiAgICAgICAgaWYocyA9PSBcIiNcIilvcHRpb25zLmVsID0gJChvcHRpb25zLmVsKVxyXG4gICAgICAgIGVsc2Ugb3B0aW9ucy5lbCA9ICQoXCIjXCIgKyBvcHRpb25zLmVsKVxyXG4gICAgfVxyXG4gICAgLy8gdHBsIG9wdGlvblxyXG4gICAgaWYob3B0aW9ucy50cGwpe1xyXG4gICAgICAgIGxldCBzID0gb3B0aW9ucy50cGxbMF07XHJcbiAgICAgICAgaWYocyA9PSBcIiNcIil7XHJcbiAgICAgICAgICAgIC8vIHRwbCBzZWxlY3RvclxyXG4gICAgICAgICAgICBvcHRpb25zLnRwbCA9IEhUTUxDbGVhbigkKG9wdGlvbnMudHBsKS5pbm5lckhUTUwpO1xyXG4gICAgICAgIH1cclxuICAgIH1lbHNle1xyXG4gICAgICAgIG9wdGlvbnMudHBsID0gSFRNTENsZWFuKG9wdGlvbnMuZWwuaW5uZXJIVE1MKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIG90aGVyIC4uLlxyXG4gICAgcmV0dXJuIG9wdGlvbnNcclxufVxyXG5cclxuZnVuY3Rpb24gUG9pX2NvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zV2FwcGVyKG9wdGlvbnMpXHJcbiAgICBsZXQgdGhhdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICB0aGF0ID0gX1BvaS5jYWxsKHRoYXQsIG9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIHRoYXQ7XHJcbn1cclxuUG9pX2NvbnN0cnVjdG9yLnByb3RvdHlwZS5tb2QgPSAoLi4uYXJncykgPT4gR2xvYmFsSnhFbnZpcm9uLm1vZC5hcHBseShHbG9iYWxKeEVudmlyb24sYXJncylcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9pX2NvbnN0cnVjdG9yXHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/Poi.js\n");

/***/ }),

/***/ "./src/core/diff.js":
/*!**************************!*\
  !*** ./src/core/diff.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\r\n    domApi\r\n} = __webpack_require__(/*! ../util/domApi.js */ \"./src/util/domApi.js\");\r\n\r\nconst {\r\n    frameify\r\n} = __webpack_require__(/*! ../util/frameify.js */ \"./src/util/frameify.js\");\r\n\r\n// const debugObj = require(\"../util/debug\")\r\nlet _lcsDomArr = async (newDomEle, oldDomEle, targetDom, INT_OBJ) => {\r\n    let planArr = [];\r\n    if (oldDomEle.length == 0) {\r\n        for (let nEli in newDomEle) {\r\n            planArr.push({\r\n                option: \"add\",\r\n                ele: newDomEle[nEli],\r\n                upper: targetDom\r\n            })\r\n        }\r\n        return planArr\r\n    }\r\n    if (newDomEle.length == 0) {\r\n        for (let oEli in oldDomEle) {\r\n            planArr.push({\r\n                option: \"delete\",\r\n                ele: oldDomEle[oEli]\r\n            })\r\n        }\r\n        return planArr\r\n    }\r\n    let lcs_arr = await frameify(lcsOnArr(newDomEle, oldDomEle, domApi.isSame), INT_OBJ),\r\n        curA = 0,\r\n        curB = 0;\r\n    // Interrupt Request\r\n    // react的做法是通过throw一个非error对象，然后在最顶层捕获\r\n    // 这里我没搞这么麻烦(机智)，就回复空return就行\r\n    // 毕竟只是针对单一用例(只有rerender需要协程支持)\r\n    if (lcs_arr === undefined) return planArr\r\n\r\n    while (true) {\r\n        if (curA >= lcs_arr.length && curB >= lcs_arr[0].length) {\r\n            break;\r\n        }\r\n        let nr = lcs_arr[curA + 1] ? lcs_arr[curA + 1] : [],\r\n            cr = lcs_arr[curA] ? lcs_arr[curA] : [];\r\n        let rv = cr[curB + 1] ? cr[curB + 1] : 0,\r\n            bv = nr[curB] ? nr[curB] : 0,\r\n            rbv = nr[curB + 1] ? nr[curB + 1] : 0,\r\n            val = cr[curB];\r\n        if (domApi.isSame(newDomEle[curA], oldDomEle[curB])) {\r\n            // same char\r\n            if (newDomEle[curA].classList != undefined) {\r\n                if (!domApi.classListDiff(newDomEle[curA], oldDomEle[curB]))\r\n                    planArr.push({\r\n                        option: \"classChange\",\r\n                        ele: oldDomEle[curB],\r\n                        list: newDomEle[curA].classList\r\n                    })\r\n            }\r\n            // attributesDiff\r\n            if (newDomEle[curA].attributes != undefined) {\r\n                if (!domApi.attributesDiff(newDomEle[curA], oldDomEle[curB]))\r\n                    planArr.push({\r\n                        option: \"attributesChange\",\r\n                        ele: oldDomEle[curB],\r\n                        to: newDomEle[curA]\r\n                    })\r\n            }\r\n            curA += 1;\r\n            curB += 1;\r\n            continue;\r\n        } else if (val == 0 && rbv != 1) {\r\n            planArr.push({\r\n                option: \"add\",\r\n                before: oldDomEle[curB],\r\n                after: oldDomEle[curB + 1],\r\n                ele: newDomEle[curA],\r\n                upper: targetDom\r\n            })\r\n            curA += 1;\r\n            continue;\r\n        } else if (rv == bv) {\r\n            // ta+1\"_\" tb+1cahr\r\n\r\n            // done  对于按相同tag的元素可以不用删了又加，添加一个新的动作patch\r\n            //       用来改变原元素的属性，而不用重绘\r\n            if (oldDomEle[curB] && newDomEle[curA] && oldDomEle[curB].nodeName == newDomEle[curA].nodeName) {\r\n                planArr.push({\r\n                    option: \"patch\",\r\n                    old: oldDomEle[curB],\r\n                    new: newDomEle[curA]\r\n                })\r\n                curA += 1;\r\n                curB += 1;\r\n                continue;\r\n            }\r\n            // 下面的是比如向末尾添加\r\n\r\n            // #201 Matrix boundary\r\n            if (newDomEle[curA] != undefined)\r\n                planArr.push({\r\n                    option: \"add\",\r\n                    before: oldDomEle[curB],\r\n                    after: oldDomEle[curB + 1],\r\n                    ele: newDomEle[curA],\r\n                    upper: targetDom\r\n                })\r\n            // *前后操作不能调换，对于末尾元素需要olddom来定位所以必须先add\r\n            // 一些特殊的情况，大部分ele是没有的\r\n            planArr.push({\r\n                option: \"delete\",\r\n                ele: oldDomEle[curB]\r\n            })\r\n            curA += 1;\r\n            curB += 1;\r\n            continue;\r\n        } else if (rv > bv) {\r\n            planArr.push({\r\n                option: \"delete\",\r\n                ele: oldDomEle[curB]\r\n            })\r\n            curB += 1;\r\n            continue;\r\n        } else {\r\n            // tb+1\"_\" ta+1char\r\n            planArr.push({\r\n                option: \"add\",\r\n                before: oldDomEle[curB],\r\n                after: oldDomEle[curB + 1],\r\n                ele: newDomEle[curA],\r\n                upper: targetDom\r\n            })\r\n            curA += 1;\r\n        }\r\n    }\r\n    return planArr\r\n}\r\n// #101 Time complexity: O(arr1.length * arr2.length)\r\nlet lcsOnArr = function* (arr1, arr2, compareFn) {\r\n    let lcsArr = [];\r\n    for (let indexA in arr1) {\r\n        let rowArr = [],\r\n            itemA = arr1[indexA];\r\n        for (let indexB in arr2) {\r\n            yield void 0;\r\n            let itemB = arr2[indexB],\r\n                lv = indexB == 0 ? 0 : rowArr[indexB - 1],\r\n                tv = indexA == 0 ? 0 : lcsArr[indexA - 1][indexB],\r\n                ltv = indexB != 0 && indexA != 0 ? lcsArr[indexA - 1][indexB - 1] : 0;\r\n            if (compareFn(itemA, itemB)) {\r\n                rowArr.push(ltv + 1);\r\n            } else {\r\n                rowArr.push(lv > tv ? lv : tv);\r\n            }\r\n        }\r\n        lcsArr.push(rowArr);\r\n    }\r\n    return lcsArr;\r\n}\r\nlet lcsDomtree = async (newChildren, oldTree, INT_OBJ) => {\r\n    const toarr = o => Array.prototype.slice.call(o)\r\n    const layer_num = ele => ele.parentNode?toarr(ele.parentNode.children).indexOf(ele):0\r\n    let isSameTree = (ele1, ele2, is_super) => {\r\n        // console.log(ele1, ele2, is_super)\r\n        if (is_super && (!ele1 || !ele2)) return true;\r\n        if(ele1.parentNode.parentNode == null && ele1.children.length > 0)return true;\r\n        return (\r\n            ele1.nodeName == ele2.nodeName\r\n            && ele1.nodeType == ele2.nodeType\r\n            && layer_num(ele1) == layer_num(ele2)\r\n            // && (is_super ? true : ele1.id == ele2.id)\r\n            // && (ele1.parentNode && ele2.parentNode ? isSameTree(ele1.parentNode, ele2.parentNode, true) : true)\r\n            // && ele1.children.length == ele2.children.length\r\n            // class并不作为对比关键\r\n            // *改这里真的要给我改吐了，必须拥抱typescript!!!\r\n            // && ele1.className == ele2.className\r\n        )\r\n    }\r\n    let Nchi = [],\r\n        Ochi = [],\r\n        planArr = [],\r\n        NsubTree = [],\r\n        OsubTree = []\r\n    for (let index in newChildren) {\r\n        if (index == \"length\") break;\r\n        let child = newChildren[index]\r\n        if (child.nodeType == 3 && child.textContent.trim().replace(/\\n/g, \"\") == \"\") continue;\r\n        // if (child.childNodes.length == 0) {\r\n        if (child.nodeType == 3 || child.children.length == 0) {\r\n            Nchi.push(child)\r\n        } else {\r\n            NsubTree.push({\r\n                ele: child\r\n            })\r\n        }\r\n    }\r\n    for (let index in oldTree.childNodes) {\r\n        if (index == \"length\") break;\r\n        let child = oldTree.childNodes[index]\r\n        if (child.nodeType == 3 && child.textContent.trim().replace(/\\n/g, \"\") == \"\") continue;\r\n        // if (child.childNodes.length == 0) {\r\n        if (child.nodeType == 3 || child.children.length == 0) {\r\n            let isgoto = false\r\n            if (child.nodeType != 3) {\r\n                for (let _c of NsubTree) {\r\n                    if (domApi.isSame(_c.ele, child)) {\r\n                        OsubTree.push(child)\r\n                        isgoto = true\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (isgoto) continue\r\n            Ochi.push(child)\r\n        } else {\r\n            OsubTree.push(child)\r\n        }\r\n    }\r\n    if (Ochi.length == 0 && OsubTree.length == 0) {\r\n        Nchi = []\r\n        NsubTree = []\r\n        for (let index in newChildren) {\r\n            if (index == \"length\") break;\r\n            let child = newChildren[index]\r\n            if (child.nodeType == 3 && child.textContent.trim().replace(/\\n/g, \"\") == \"\") continue;\r\n            Nchi.push(child)\r\n        }\r\n    }\r\n    // let plan = lcsDomArr(Nchi, Ochi, oldTree)\r\n    let plan = await _lcsDomArr(Nchi, Ochi, oldTree, INT_OBJ)\r\n\r\n    if (plan.length != 0) {\r\n        planArr.push.apply(planArr, plan)\r\n    }\r\n    for (let ni in NsubTree) {\r\n        let ntree = NsubTree[ni].ele\r\n        for (let oi in OsubTree) {\r\n            let otree = OsubTree[oi]\r\n            if (isSameTree(ntree, otree)) {\r\n                // compare\r\n                if (ntree.classList != undefined) {\r\n                    if (!domApi.classListDiff(ntree, otree))\r\n                        planArr.push({\r\n                            option: \"classChange\",\r\n                            ele: otree,\r\n                            list: ntree.classList\r\n                        })\r\n                }\r\n                // attributesDiff\r\n                if (ntree.attributes != undefined) {\r\n                    if (!domApi.attributesDiff(ntree, otree))\r\n                        planArr.push({\r\n                            option: \"attributesChange\",\r\n                            ele: otree,\r\n                            to: ntree\r\n                        })\r\n                }\r\n                // diff ending\r\n                if (planArr.length != 0) {\r\n                    planArr.push.apply(planArr, await lcsDomtree(ntree.childNodes, otree, INT_OBJ))\r\n                } else {\r\n                    planArr = await lcsDomtree(ntree.childNodes, otree, INT_OBJ)\r\n                }\r\n                delete NsubTree[ni]\r\n                delete OsubTree[oi]\r\n                // NsubTree.splice(ni, 1)\r\n                // OsubTree.splice(oi, 1)\r\n                break\r\n            }\r\n        }\r\n    }\r\n    for (let ni in NsubTree) {\r\n        if (NsubTree[ni]) {\r\n            if (NsubTree[ni].ele.nodeType == 3 && NsubTree[ni].ele.textContent.trim().replace(/\\n/g, \"\") == \"\") continue;\r\n            planArr.push({\r\n                option: \"add\",\r\n                before: NsubTree[ni].before,\r\n                after: NsubTree[ni].after,\r\n                ele: NsubTree[ni].ele,\r\n                upper: oldTree\r\n            })\r\n        }\r\n    }\r\n    for (let ni in OsubTree) {\r\n        if (OsubTree[ni]) {\r\n            planArr.push({\r\n                option: \"delete\",\r\n                ele: OsubTree[ni]\r\n            })\r\n        }\r\n    }\r\n\r\n    return planArr\r\n}\r\n\r\nlet patch = function* (plan) {\r\n    function patch_on(oldDOM, newDOM) {\r\n        if(oldDOM.nodeType == 3){\r\n            if(oldDOM.textContent != newDOM.textContent)oldDOM.textContent = newDOM.textContent\r\n        }else{\r\n            oldDOM.classList = newDOM.classList;\r\n            domApi.attributesClone(oldDOM, newDOM);\r\n            if (oldDOM.innerHTML.trim() != newDOM.innerHTML.trim()) oldDOM.innerHTML = newDOM.innerHTML;\r\n        }\r\n    }\r\n    for (let ch of plan) {\r\n        yield void 0;\r\n        switch (ch.option) {\r\n            case \"add\":\r\n                if (ch.after != undefined) {\r\n                    domApi.insertBefore(ch.ele, ch.after)\r\n                } else if (ch.before != undefined) {\r\n                    domApi.insertAfter(ch.ele, ch.before)\r\n                } else {\r\n                    domApi.append(ch.ele, ch.upper)\r\n                }\r\n                break;\r\n            case \"classChange\":\r\n                ch.ele.classList = ch.list\r\n                break;\r\n            case \"delete\":\r\n                domApi.remove(ch.ele)\r\n                break;\r\n            case \"attributesChange\":\r\n                domApi.attributesClone(ch.ele, ch.to)\r\n                break;\r\n            case \"patch\":\r\n                patch_on(ch.old, ch.new)\r\n                break;\r\n            default:\r\n                void 0;\r\n        }\r\n    }\r\n}\r\n\r\nlet diff = async (targetDom, newHtml, INT_OBJ) => {\r\n    let newTreeChilds = domApi.createDomTree(newHtml)\r\n    let patchArr = await lcsDomtree(newTreeChilds, targetDom, INT_OBJ)\r\n    // dont int patch func\r\n    if (INT_OBJ && INT_OBJ.wtever) return []\r\n    await frameify(patch(patchArr), INT_OBJ)\r\n    // patch(patchArr)\r\n    return patchArr\r\n}\r\n\r\nmodule.exports = diff\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9kaWZmLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvZGlmZi5qcz9lYzZiIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHtcclxuICAgIGRvbUFwaVxyXG59ID0gcmVxdWlyZShcIi4uL3V0aWwvZG9tQXBpLmpzXCIpO1xyXG5cclxuY29uc3Qge1xyXG4gICAgZnJhbWVpZnlcclxufSA9IHJlcXVpcmUoJy4uL3V0aWwvZnJhbWVpZnkuanMnKTtcclxuXHJcbi8vIGNvbnN0IGRlYnVnT2JqID0gcmVxdWlyZShcIi4uL3V0aWwvZGVidWdcIilcclxubGV0IF9sY3NEb21BcnIgPSBhc3luYyAobmV3RG9tRWxlLCBvbGREb21FbGUsIHRhcmdldERvbSwgSU5UX09CSikgPT4ge1xyXG4gICAgbGV0IHBsYW5BcnIgPSBbXTtcclxuICAgIGlmIChvbGREb21FbGUubGVuZ3RoID09IDApIHtcclxuICAgICAgICBmb3IgKGxldCBuRWxpIGluIG5ld0RvbUVsZSkge1xyXG4gICAgICAgICAgICBwbGFuQXJyLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uOiBcImFkZFwiLFxyXG4gICAgICAgICAgICAgICAgZWxlOiBuZXdEb21FbGVbbkVsaV0sXHJcbiAgICAgICAgICAgICAgICB1cHBlcjogdGFyZ2V0RG9tXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwbGFuQXJyXHJcbiAgICB9XHJcbiAgICBpZiAobmV3RG9tRWxlLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgZm9yIChsZXQgb0VsaSBpbiBvbGREb21FbGUpIHtcclxuICAgICAgICAgICAgcGxhbkFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbjogXCJkZWxldGVcIixcclxuICAgICAgICAgICAgICAgIGVsZTogb2xkRG9tRWxlW29FbGldXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwbGFuQXJyXHJcbiAgICB9XHJcbiAgICBsZXQgbGNzX2FyciA9IGF3YWl0IGZyYW1laWZ5KGxjc09uQXJyKG5ld0RvbUVsZSwgb2xkRG9tRWxlLCBkb21BcGkuaXNTYW1lKSwgSU5UX09CSiksXHJcbiAgICAgICAgY3VyQSA9IDAsXHJcbiAgICAgICAgY3VyQiA9IDA7XHJcbiAgICAvLyBJbnRlcnJ1cHQgUmVxdWVzdFxyXG4gICAgLy8gcmVhY3TnmoTlgZrms5XmmK/pgJrov4d0aHJvd+S4gOS4qumdnmVycm9y5a+56LGh77yM54S25ZCO5Zyo5pyA6aG25bGC5o2V6I63XHJcbiAgICAvLyDov5nph4zmiJHmsqHmkJ7ov5nkuYjpurvng6Yo5py65pm6Ke+8jOWwseWbnuWkjeepunJldHVybuWwseihjFxyXG4gICAgLy8g5q+V56uf5Y+q5piv6ZKI5a+55Y2V5LiA55So5L6LKOWPquaciXJlcmVuZGVy6ZyA6KaB5Y2P56iL5pSv5oyBKVxyXG4gICAgaWYgKGxjc19hcnIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHBsYW5BcnJcclxuXHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGlmIChjdXJBID49IGxjc19hcnIubGVuZ3RoICYmIGN1ckIgPj0gbGNzX2FyclswXS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuciA9IGxjc19hcnJbY3VyQSArIDFdID8gbGNzX2FycltjdXJBICsgMV0gOiBbXSxcclxuICAgICAgICAgICAgY3IgPSBsY3NfYXJyW2N1ckFdID8gbGNzX2FycltjdXJBXSA6IFtdO1xyXG4gICAgICAgIGxldCBydiA9IGNyW2N1ckIgKyAxXSA/IGNyW2N1ckIgKyAxXSA6IDAsXHJcbiAgICAgICAgICAgIGJ2ID0gbnJbY3VyQl0gPyBucltjdXJCXSA6IDAsXHJcbiAgICAgICAgICAgIHJidiA9IG5yW2N1ckIgKyAxXSA/IG5yW2N1ckIgKyAxXSA6IDAsXHJcbiAgICAgICAgICAgIHZhbCA9IGNyW2N1ckJdO1xyXG4gICAgICAgIGlmIChkb21BcGkuaXNTYW1lKG5ld0RvbUVsZVtjdXJBXSwgb2xkRG9tRWxlW2N1ckJdKSkge1xyXG4gICAgICAgICAgICAvLyBzYW1lIGNoYXJcclxuICAgICAgICAgICAgaWYgKG5ld0RvbUVsZVtjdXJBXS5jbGFzc0xpc3QgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRvbUFwaS5jbGFzc0xpc3REaWZmKG5ld0RvbUVsZVtjdXJBXSwgb2xkRG9tRWxlW2N1ckJdKSlcclxuICAgICAgICAgICAgICAgICAgICBwbGFuQXJyLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb246IFwiY2xhc3NDaGFuZ2VcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlOiBvbGREb21FbGVbY3VyQl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3Q6IG5ld0RvbUVsZVtjdXJBXS5jbGFzc0xpc3RcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGF0dHJpYnV0ZXNEaWZmXHJcbiAgICAgICAgICAgIGlmIChuZXdEb21FbGVbY3VyQV0uYXR0cmlidXRlcyAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZG9tQXBpLmF0dHJpYnV0ZXNEaWZmKG5ld0RvbUVsZVtjdXJBXSwgb2xkRG9tRWxlW2N1ckJdKSlcclxuICAgICAgICAgICAgICAgICAgICBwbGFuQXJyLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb246IFwiYXR0cmlidXRlc0NoYW5nZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGU6IG9sZERvbUVsZVtjdXJCXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IG5ld0RvbUVsZVtjdXJBXVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VyQSArPSAxO1xyXG4gICAgICAgICAgICBjdXJCICs9IDE7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodmFsID09IDAgJiYgcmJ2ICE9IDEpIHtcclxuICAgICAgICAgICAgcGxhbkFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbjogXCJhZGRcIixcclxuICAgICAgICAgICAgICAgIGJlZm9yZTogb2xkRG9tRWxlW2N1ckJdLFxyXG4gICAgICAgICAgICAgICAgYWZ0ZXI6IG9sZERvbUVsZVtjdXJCICsgMV0sXHJcbiAgICAgICAgICAgICAgICBlbGU6IG5ld0RvbUVsZVtjdXJBXSxcclxuICAgICAgICAgICAgICAgIHVwcGVyOiB0YXJnZXREb21cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgY3VyQSArPSAxO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKHJ2ID09IGJ2KSB7XHJcbiAgICAgICAgICAgIC8vIHRhKzFcIl9cIiB0YisxY2FoclxyXG5cclxuICAgICAgICAgICAgLy8gZG9uZSAg5a+55LqO5oyJ55u45ZCMdGFn55qE5YWD57Sg5Y+v5Lul5LiN55So5Yig5LqG5Y+I5Yqg77yM5re75Yqg5LiA5Liq5paw55qE5Yqo5L2ccGF0Y2hcclxuICAgICAgICAgICAgLy8gICAgICAg55So5p2l5pS55Y+Y5Y6f5YWD57Sg55qE5bGe5oCn77yM6ICM5LiN55So6YeN57uYXHJcbiAgICAgICAgICAgIGlmIChvbGREb21FbGVbY3VyQl0gJiYgbmV3RG9tRWxlW2N1ckFdICYmIG9sZERvbUVsZVtjdXJCXS5ub2RlTmFtZSA9PSBuZXdEb21FbGVbY3VyQV0ubm9kZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHBsYW5BcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uOiBcInBhdGNoXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkOiBvbGREb21FbGVbY3VyQl0sXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3OiBuZXdEb21FbGVbY3VyQV1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICBjdXJBICs9IDE7XHJcbiAgICAgICAgICAgICAgICBjdXJCICs9IDE7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDkuIvpnaLnmoTmmK/mr5TlpoLlkJHmnKvlsL7mt7vliqBcclxuXHJcbiAgICAgICAgICAgIC8vICMyMDEgTWF0cml4IGJvdW5kYXJ5XHJcbiAgICAgICAgICAgIGlmIChuZXdEb21FbGVbY3VyQV0gIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgcGxhbkFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb246IFwiYWRkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlOiBvbGREb21FbGVbY3VyQl0sXHJcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXI6IG9sZERvbUVsZVtjdXJCICsgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlOiBuZXdEb21FbGVbY3VyQV0sXHJcbiAgICAgICAgICAgICAgICAgICAgdXBwZXI6IHRhcmdldERvbVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLy8gKuWJjeWQjuaTjeS9nOS4jeiDveiwg+aNou+8jOWvueS6juacq+WwvuWFg+e0oOmcgOimgW9sZGRvbeadpeWumuS9jeaJgOS7peW/hemhu+WFiGFkZFxyXG4gICAgICAgICAgICAvLyDkuIDkupvnibnmrornmoTmg4XlhrXvvIzlpKfpg6jliIZlbGXmmK/msqHmnInnmoRcclxuICAgICAgICAgICAgcGxhbkFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbjogXCJkZWxldGVcIixcclxuICAgICAgICAgICAgICAgIGVsZTogb2xkRG9tRWxlW2N1ckJdXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGN1ckEgKz0gMTtcclxuICAgICAgICAgICAgY3VyQiArPSAxO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKHJ2ID4gYnYpIHtcclxuICAgICAgICAgICAgcGxhbkFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbjogXCJkZWxldGVcIixcclxuICAgICAgICAgICAgICAgIGVsZTogb2xkRG9tRWxlW2N1ckJdXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGN1ckIgKz0gMTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdGIrMVwiX1wiIHRhKzFjaGFyXHJcbiAgICAgICAgICAgIHBsYW5BcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBvcHRpb246IFwiYWRkXCIsXHJcbiAgICAgICAgICAgICAgICBiZWZvcmU6IG9sZERvbUVsZVtjdXJCXSxcclxuICAgICAgICAgICAgICAgIGFmdGVyOiBvbGREb21FbGVbY3VyQiArIDFdLFxyXG4gICAgICAgICAgICAgICAgZWxlOiBuZXdEb21FbGVbY3VyQV0sXHJcbiAgICAgICAgICAgICAgICB1cHBlcjogdGFyZ2V0RG9tXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGN1ckEgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGxhbkFyclxyXG59XHJcbi8vICMxMDEgVGltZSBjb21wbGV4aXR5OiBPKGFycjEubGVuZ3RoICogYXJyMi5sZW5ndGgpXHJcbmxldCBsY3NPbkFyciA9IGZ1bmN0aW9uKiAoYXJyMSwgYXJyMiwgY29tcGFyZUZuKSB7XHJcbiAgICBsZXQgbGNzQXJyID0gW107XHJcbiAgICBmb3IgKGxldCBpbmRleEEgaW4gYXJyMSkge1xyXG4gICAgICAgIGxldCByb3dBcnIgPSBbXSxcclxuICAgICAgICAgICAgaXRlbUEgPSBhcnIxW2luZGV4QV07XHJcbiAgICAgICAgZm9yIChsZXQgaW5kZXhCIGluIGFycjIpIHtcclxuICAgICAgICAgICAgeWllbGQgdm9pZCAwO1xyXG4gICAgICAgICAgICBsZXQgaXRlbUIgPSBhcnIyW2luZGV4Ql0sXHJcbiAgICAgICAgICAgICAgICBsdiA9IGluZGV4QiA9PSAwID8gMCA6IHJvd0FycltpbmRleEIgLSAxXSxcclxuICAgICAgICAgICAgICAgIHR2ID0gaW5kZXhBID09IDAgPyAwIDogbGNzQXJyW2luZGV4QSAtIDFdW2luZGV4Ql0sXHJcbiAgICAgICAgICAgICAgICBsdHYgPSBpbmRleEIgIT0gMCAmJiBpbmRleEEgIT0gMCA/IGxjc0FycltpbmRleEEgLSAxXVtpbmRleEIgLSAxXSA6IDA7XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJlRm4oaXRlbUEsIGl0ZW1CKSkge1xyXG4gICAgICAgICAgICAgICAgcm93QXJyLnB1c2gobHR2ICsgMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByb3dBcnIucHVzaChsdiA+IHR2ID8gbHYgOiB0dik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGNzQXJyLnB1c2gocm93QXJyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsY3NBcnI7XHJcbn1cclxubGV0IGxjc0RvbXRyZWUgPSBhc3luYyAobmV3Q2hpbGRyZW4sIG9sZFRyZWUsIElOVF9PQkopID0+IHtcclxuICAgIGNvbnN0IHRvYXJyID0gbyA9PiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvKVxyXG4gICAgY29uc3QgbGF5ZXJfbnVtID0gZWxlID0+IGVsZS5wYXJlbnROb2RlP3RvYXJyKGVsZS5wYXJlbnROb2RlLmNoaWxkcmVuKS5pbmRleE9mKGVsZSk6MFxyXG4gICAgbGV0IGlzU2FtZVRyZWUgPSAoZWxlMSwgZWxlMiwgaXNfc3VwZXIpID0+IHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhlbGUxLCBlbGUyLCBpc19zdXBlcilcclxuICAgICAgICBpZiAoaXNfc3VwZXIgJiYgKCFlbGUxIHx8ICFlbGUyKSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgaWYoZWxlMS5wYXJlbnROb2RlLnBhcmVudE5vZGUgPT0gbnVsbCAmJiBlbGUxLmNoaWxkcmVuLmxlbmd0aCA+IDApcmV0dXJuIHRydWU7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgZWxlMS5ub2RlTmFtZSA9PSBlbGUyLm5vZGVOYW1lXHJcbiAgICAgICAgICAgICYmIGVsZTEubm9kZVR5cGUgPT0gZWxlMi5ub2RlVHlwZVxyXG4gICAgICAgICAgICAmJiBsYXllcl9udW0oZWxlMSkgPT0gbGF5ZXJfbnVtKGVsZTIpXHJcbiAgICAgICAgICAgIC8vICYmIChpc19zdXBlciA/IHRydWUgOiBlbGUxLmlkID09IGVsZTIuaWQpXHJcbiAgICAgICAgICAgIC8vICYmIChlbGUxLnBhcmVudE5vZGUgJiYgZWxlMi5wYXJlbnROb2RlID8gaXNTYW1lVHJlZShlbGUxLnBhcmVudE5vZGUsIGVsZTIucGFyZW50Tm9kZSwgdHJ1ZSkgOiB0cnVlKVxyXG4gICAgICAgICAgICAvLyAmJiBlbGUxLmNoaWxkcmVuLmxlbmd0aCA9PSBlbGUyLmNoaWxkcmVuLmxlbmd0aFxyXG4gICAgICAgICAgICAvLyBjbGFzc+W5tuS4jeS9nOS4uuWvueavlOWFs+mUrlxyXG4gICAgICAgICAgICAvLyAq5pS56L+Z6YeM55yf55qE6KaB57uZ5oiR5pS55ZCQ5LqG77yM5b+F6aG75oul5oqxdHlwZXNjcmlwdCEhIVxyXG4gICAgICAgICAgICAvLyAmJiBlbGUxLmNsYXNzTmFtZSA9PSBlbGUyLmNsYXNzTmFtZVxyXG4gICAgICAgIClcclxuICAgIH1cclxuICAgIGxldCBOY2hpID0gW10sXHJcbiAgICAgICAgT2NoaSA9IFtdLFxyXG4gICAgICAgIHBsYW5BcnIgPSBbXSxcclxuICAgICAgICBOc3ViVHJlZSA9IFtdLFxyXG4gICAgICAgIE9zdWJUcmVlID0gW11cclxuICAgIGZvciAobGV0IGluZGV4IGluIG5ld0NoaWxkcmVuKSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IFwibGVuZ3RoXCIpIGJyZWFrO1xyXG4gICAgICAgIGxldCBjaGlsZCA9IG5ld0NoaWxkcmVuW2luZGV4XVxyXG4gICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzICYmIGNoaWxkLnRleHRDb250ZW50LnRyaW0oKS5yZXBsYWNlKC9cXG4vZywgXCJcIikgPT0gXCJcIikgY29udGludWU7XHJcbiAgICAgICAgLy8gaWYgKGNoaWxkLmNoaWxkTm9kZXMubGVuZ3RoID09IDApIHtcclxuICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMyB8fCBjaGlsZC5jaGlsZHJlbi5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICBOY2hpLnB1c2goY2hpbGQpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgTnN1YlRyZWUucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBlbGU6IGNoaWxkXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaW5kZXggaW4gb2xkVHJlZS5jaGlsZE5vZGVzKSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID09IFwibGVuZ3RoXCIpIGJyZWFrO1xyXG4gICAgICAgIGxldCBjaGlsZCA9IG9sZFRyZWUuY2hpbGROb2Rlc1tpbmRleF1cclxuICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMyAmJiBjaGlsZC50ZXh0Q29udGVudC50cmltKCkucmVwbGFjZSgvXFxuL2csIFwiXCIpID09IFwiXCIpIGNvbnRpbnVlO1xyXG4gICAgICAgIC8vIGlmIChjaGlsZC5jaGlsZE5vZGVzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMgfHwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgbGV0IGlzZ290byA9IGZhbHNlXHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSAhPSAzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBfYyBvZiBOc3ViVHJlZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21BcGkuaXNTYW1lKF9jLmVsZSwgY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE9zdWJUcmVlLnB1c2goY2hpbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzZ290byA9IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc2dvdG8pIGNvbnRpbnVlXHJcbiAgICAgICAgICAgIE9jaGkucHVzaChjaGlsZClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBPc3ViVHJlZS5wdXNoKGNoaWxkKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChPY2hpLmxlbmd0aCA9PSAwICYmIE9zdWJUcmVlLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgTmNoaSA9IFtdXHJcbiAgICAgICAgTnN1YlRyZWUgPSBbXVxyXG4gICAgICAgIGZvciAobGV0IGluZGV4IGluIG5ld0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSBcImxlbmd0aFwiKSBicmVhaztcclxuICAgICAgICAgICAgbGV0IGNoaWxkID0gbmV3Q2hpbGRyZW5baW5kZXhdXHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzICYmIGNoaWxkLnRleHRDb250ZW50LnRyaW0oKS5yZXBsYWNlKC9cXG4vZywgXCJcIikgPT0gXCJcIikgY29udGludWU7XHJcbiAgICAgICAgICAgIE5jaGkucHVzaChjaGlsZClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBsZXQgcGxhbiA9IGxjc0RvbUFycihOY2hpLCBPY2hpLCBvbGRUcmVlKVxyXG4gICAgbGV0IHBsYW4gPSBhd2FpdCBfbGNzRG9tQXJyKE5jaGksIE9jaGksIG9sZFRyZWUsIElOVF9PQkopXHJcblxyXG4gICAgaWYgKHBsYW4ubGVuZ3RoICE9IDApIHtcclxuICAgICAgICBwbGFuQXJyLnB1c2guYXBwbHkocGxhbkFyciwgcGxhbilcclxuICAgIH1cclxuICAgIGZvciAobGV0IG5pIGluIE5zdWJUcmVlKSB7XHJcbiAgICAgICAgbGV0IG50cmVlID0gTnN1YlRyZWVbbmldLmVsZVxyXG4gICAgICAgIGZvciAobGV0IG9pIGluIE9zdWJUcmVlKSB7XHJcbiAgICAgICAgICAgIGxldCBvdHJlZSA9IE9zdWJUcmVlW29pXVxyXG4gICAgICAgICAgICBpZiAoaXNTYW1lVHJlZShudHJlZSwgb3RyZWUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb21wYXJlXHJcbiAgICAgICAgICAgICAgICBpZiAobnRyZWUuY2xhc3NMaXN0ICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9tQXBpLmNsYXNzTGlzdERpZmYobnRyZWUsIG90cmVlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhbkFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbjogXCJjbGFzc0NoYW5nZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlOiBvdHJlZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3Q6IG50cmVlLmNsYXNzTGlzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gYXR0cmlidXRlc0RpZmZcclxuICAgICAgICAgICAgICAgIGlmIChudHJlZS5hdHRyaWJ1dGVzICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9tQXBpLmF0dHJpYnV0ZXNEaWZmKG50cmVlLCBvdHJlZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYW5BcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb246IFwiYXR0cmlidXRlc0NoYW5nZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlOiBvdHJlZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBudHJlZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZGlmZiBlbmRpbmdcclxuICAgICAgICAgICAgICAgIGlmIChwbGFuQXJyLmxlbmd0aCAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGxhbkFyci5wdXNoLmFwcGx5KHBsYW5BcnIsIGF3YWl0IGxjc0RvbXRyZWUobnRyZWUuY2hpbGROb2Rlcywgb3RyZWUsIElOVF9PQkopKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwbGFuQXJyID0gYXdhaXQgbGNzRG9tdHJlZShudHJlZS5jaGlsZE5vZGVzLCBvdHJlZSwgSU5UX09CSilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBOc3ViVHJlZVtuaV1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBPc3ViVHJlZVtvaV1cclxuICAgICAgICAgICAgICAgIC8vIE5zdWJUcmVlLnNwbGljZShuaSwgMSlcclxuICAgICAgICAgICAgICAgIC8vIE9zdWJUcmVlLnNwbGljZShvaSwgMSlcclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBuaSBpbiBOc3ViVHJlZSkge1xyXG4gICAgICAgIGlmIChOc3ViVHJlZVtuaV0pIHtcclxuICAgICAgICAgICAgaWYgKE5zdWJUcmVlW25pXS5lbGUubm9kZVR5cGUgPT0gMyAmJiBOc3ViVHJlZVtuaV0uZWxlLnRleHRDb250ZW50LnRyaW0oKS5yZXBsYWNlKC9cXG4vZywgXCJcIikgPT0gXCJcIikgY29udGludWU7XHJcbiAgICAgICAgICAgIHBsYW5BcnIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBvcHRpb246IFwiYWRkXCIsXHJcbiAgICAgICAgICAgICAgICBiZWZvcmU6IE5zdWJUcmVlW25pXS5iZWZvcmUsXHJcbiAgICAgICAgICAgICAgICBhZnRlcjogTnN1YlRyZWVbbmldLmFmdGVyLFxyXG4gICAgICAgICAgICAgICAgZWxlOiBOc3ViVHJlZVtuaV0uZWxlLFxyXG4gICAgICAgICAgICAgICAgdXBwZXI6IG9sZFRyZWVcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBuaSBpbiBPc3ViVHJlZSkge1xyXG4gICAgICAgIGlmIChPc3ViVHJlZVtuaV0pIHtcclxuICAgICAgICAgICAgcGxhbkFyci5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbjogXCJkZWxldGVcIixcclxuICAgICAgICAgICAgICAgIGVsZTogT3N1YlRyZWVbbmldXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwbGFuQXJyXHJcbn1cclxuXHJcbmxldCBwYXRjaCA9IGZ1bmN0aW9uKiAocGxhbikge1xyXG4gICAgZnVuY3Rpb24gcGF0Y2hfb24ob2xkRE9NLCBuZXdET00pIHtcclxuICAgICAgICBpZihvbGRET00ubm9kZVR5cGUgPT0gMyl7XHJcbiAgICAgICAgICAgIGlmKG9sZERPTS50ZXh0Q29udGVudCAhPSBuZXdET00udGV4dENvbnRlbnQpb2xkRE9NLnRleHRDb250ZW50ID0gbmV3RE9NLnRleHRDb250ZW50XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIG9sZERPTS5jbGFzc0xpc3QgPSBuZXdET00uY2xhc3NMaXN0O1xyXG4gICAgICAgICAgICBkb21BcGkuYXR0cmlidXRlc0Nsb25lKG9sZERPTSwgbmV3RE9NKTtcclxuICAgICAgICAgICAgaWYgKG9sZERPTS5pbm5lckhUTUwudHJpbSgpICE9IG5ld0RPTS5pbm5lckhUTUwudHJpbSgpKSBvbGRET00uaW5uZXJIVE1MID0gbmV3RE9NLmlubmVySFRNTDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBjaCBvZiBwbGFuKSB7XHJcbiAgICAgICAgeWllbGQgdm9pZCAwO1xyXG4gICAgICAgIHN3aXRjaCAoY2gub3B0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJhZGRcIjpcclxuICAgICAgICAgICAgICAgIGlmIChjaC5hZnRlciAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb21BcGkuaW5zZXJ0QmVmb3JlKGNoLmVsZSwgY2guYWZ0ZXIpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoLmJlZm9yZSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb21BcGkuaW5zZXJ0QWZ0ZXIoY2guZWxlLCBjaC5iZWZvcmUpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbUFwaS5hcHBlbmQoY2guZWxlLCBjaC51cHBlcilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiY2xhc3NDaGFuZ2VcIjpcclxuICAgICAgICAgICAgICAgIGNoLmVsZS5jbGFzc0xpc3QgPSBjaC5saXN0XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVwiOlxyXG4gICAgICAgICAgICAgICAgZG9tQXBpLnJlbW92ZShjaC5lbGUpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImF0dHJpYnV0ZXNDaGFuZ2VcIjpcclxuICAgICAgICAgICAgICAgIGRvbUFwaS5hdHRyaWJ1dGVzQ2xvbmUoY2guZWxlLCBjaC50bylcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwicGF0Y2hcIjpcclxuICAgICAgICAgICAgICAgIHBhdGNoX29uKGNoLm9sZCwgY2gubmV3KVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB2b2lkIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5sZXQgZGlmZiA9IGFzeW5jICh0YXJnZXREb20sIG5ld0h0bWwsIElOVF9PQkopID0+IHtcclxuICAgIGxldCBuZXdUcmVlQ2hpbGRzID0gZG9tQXBpLmNyZWF0ZURvbVRyZWUobmV3SHRtbClcclxuICAgIGxldCBwYXRjaEFyciA9IGF3YWl0IGxjc0RvbXRyZWUobmV3VHJlZUNoaWxkcywgdGFyZ2V0RG9tLCBJTlRfT0JKKVxyXG4gICAgLy8gZG9udCBpbnQgcGF0Y2ggZnVuY1xyXG4gICAgaWYgKElOVF9PQkogJiYgSU5UX09CSi53dGV2ZXIpIHJldHVybiBbXVxyXG4gICAgYXdhaXQgZnJhbWVpZnkocGF0Y2gocGF0Y2hBcnIpLCBJTlRfT0JKKVxyXG4gICAgLy8gcGF0Y2gocGF0Y2hBcnIpXHJcbiAgICByZXR1cm4gcGF0Y2hBcnJcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBkaWZmXHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/diff.js\n");

/***/ }),

/***/ "./src/core/event.js":
/*!***************************!*\
  !*** ./src/core/event.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\r\n    ev_supList\r\n} = __webpack_require__(/*! ../util/util */ \"./src/util/util.js\");\r\n\r\n\r\nclass EventObj {\r\n    constructor() {\r\n        this.subscribe = {}\r\n    }\r\n    on(channel, fn) {\r\n        let old = this.subscribe[channel] ? this.subscribe[channel].func : undefined;\r\n        if (old == undefined) this.subscribe[channel] = {}\r\n        this.subscribe[channel].func = function(_args) {\r\n            if (typeof old == \"function\") {\r\n                old(_args);\r\n            }\r\n            fn(_args);\r\n        }\r\n    }\r\n    emit(channel, _args) {\r\n        if (this.subscribe[channel] !== undefined) {\r\n            if (typeof this.subscribe[channel].func == \"function\") {\r\n                this.subscribe[channel].func(_args);\r\n            }\r\n        }\r\n    }\r\n    clear() {\r\n        this.subscribe = {};\r\n    }\r\n}\r\nclass EventObjForEle extends EventObj {\r\n    constructor(ele) {\r\n        super();\r\n        this.el = ele;\r\n        this.__init_nativeEv();\r\n    }\r\n    __init_nativeEv() {\r\n        ev_supList.forEach(evName => {\r\n            this.el.addEventListener(evName, e => {\r\n                // window.requestIdleCallback(() => this.emit(evName, e))\r\n                // setTimeout(() => this.emit(evName, e), 1);\r\n                this.emit(evName, e)\r\n            })\r\n        })\r\n    }\r\n}\r\n\r\nmodule.exports = EventObjForEle;\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9ldmVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb3JlL2V2ZW50LmpzPzlkMGYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qge1xyXG4gICAgZXZfc3VwTGlzdFxyXG59ID0gcmVxdWlyZShcIi4uL3V0aWwvdXRpbFwiKTtcclxuXHJcblxyXG5jbGFzcyBFdmVudE9iaiB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnN1YnNjcmliZSA9IHt9XHJcbiAgICB9XHJcbiAgICBvbihjaGFubmVsLCBmbikge1xyXG4gICAgICAgIGxldCBvbGQgPSB0aGlzLnN1YnNjcmliZVtjaGFubmVsXSA/IHRoaXMuc3Vic2NyaWJlW2NoYW5uZWxdLmZ1bmMgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKG9sZCA9PSB1bmRlZmluZWQpIHRoaXMuc3Vic2NyaWJlW2NoYW5uZWxdID0ge31cclxuICAgICAgICB0aGlzLnN1YnNjcmliZVtjaGFubmVsXS5mdW5jID0gZnVuY3Rpb24oX2FyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbGQgPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBvbGQoX2FyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZuKF9hcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbWl0KGNoYW5uZWwsIF9hcmdzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaWJlW2NoYW5uZWxdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnN1YnNjcmliZVtjaGFubmVsXS5mdW5jID09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVbY2hhbm5lbF0uZnVuYyhfYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLnN1YnNjcmliZSA9IHt9O1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEV2ZW50T2JqRm9yRWxlIGV4dGVuZHMgRXZlbnRPYmoge1xyXG4gICAgY29uc3RydWN0b3IoZWxlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmVsID0gZWxlO1xyXG4gICAgICAgIHRoaXMuX19pbml0X25hdGl2ZUV2KCk7XHJcbiAgICB9XHJcbiAgICBfX2luaXRfbmF0aXZlRXYoKSB7XHJcbiAgICAgICAgZXZfc3VwTGlzdC5mb3JFYWNoKGV2TmFtZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcihldk5hbWUsIGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4gdGhpcy5lbWl0KGV2TmFtZSwgZSkpXHJcbiAgICAgICAgICAgICAgICAvLyBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZW1pdChldk5hbWUsIGUpLCAxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldk5hbWUsIGUpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudE9iakZvckVsZTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/event.js\n");

/***/ }),

/***/ "./src/core/jx.js":
/*!************************!*\
  !*** ./src/core/jx.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const re = /{{([\\s\\S]+?)}}/\r\n\r\nfunction loadJx(xx) {\r\n    let stack = [],\r\n        e;\r\n\r\n    function inner(sx) {\r\n        if (sx.length == 0) return void 0;\r\n        if (!(e = re.exec(sx))) stack.push([0, sx])\r\n        else {\r\n            if (e.index != 1) stack.push([0, sx.slice(0, e.index)])\r\n            if (e[0][2] == \"=\") stack.push([2, e[1].slice(1)])\r\n            else if (e[0][2] == \"$\") stack.push([3, e[1].slice(1)])\r\n            else if (e[0][2] == \"*\") stack.push([4, e[1].slice(1)])\r\n            else stack.push([1, e[1]])\r\n            inner(sx.slice(e.index + e[0].length))\r\n        }\r\n    }\r\n    inner(xx)\r\n    return stack\r\n}\r\n\r\nfunction compile(stack) {\r\n    let code = \"\"\r\n    for (const row of stack) {\r\n        let content = row[1].trim()\r\n        switch (row[0]) {\r\n            case 0:\r\n                code += `yield \\`${content}\\`;`\r\n                break;\r\n            case 1: // command\r\n                code += `${content}\\n`\r\n                break;\r\n            case 2: // = get values\r\n                code += `yield ${content};`\r\n                break;\r\n            case 3: // $ tpl called\r\n                code += `yield $${content};`\r\n                break;\r\n            case 4: // * callee\r\n                code += `yield* arguments.callee(${content});`\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    return eval(`(function*(obj){with(obj){\\n${code}\\n}})`)\r\n}\r\n\r\nfunction compileJx(jx_text){\r\n    return compile(loadJx(jx_text))\r\n}\r\n\r\nfunction tplLoader(tpl,data){\r\n    return [...tpl(data)].join(\"\")\r\n}\r\n\r\nfunction __Jx(jx_text, data) {\r\n    var tpl = compileJx(jx_text)\r\n    return tplLoader(tpl, data)\r\n}\r\n\r\nclass Jx{\r\n    constructor(){\r\n        this.mods = {}\r\n    }\r\n    mod(name,jx_text){\r\n        this.mods[name] = d => tplLoader(compileJx(jx_text),d)\r\n    }\r\n    __prx$(o){\r\n        let that = this\r\n        return new Proxy(o,{\r\n            get(o,prop){\r\n                if(prop == Symbol.unscopables)return undefined\r\n                if(prop[0] == \"$\" && prop.slice(1) in that.mods)\r\n                    return d => that.mods[prop.slice(1)](that.__prx$(d))\r\n                return  o[prop]\r\n            },\r\n            has(o,prop){\r\n                if(prop.slice(1) in that.mods || prop in o)return true\r\n                return false\r\n            }\r\n        })\r\n    }\r\n    compile(jx_text,data){\r\n        return __Jx(jx_text, this.__prx$(data))\r\n    }\r\n    dumpTpl(tpl,data){\r\n        return tplLoader(tpl, this.__prx$(data))\r\n    }\r\n}\r\n\r\nclass JxTpl{\r\n    constructor(jx_text, JxGlobal){\r\n        this.tpl = compileJx(jx_text)\r\n        this._jx = JxGlobal\r\n    }\r\n    joint(data){\r\n        return this._jx.dumpTpl(this.tpl,data)\r\n    }\r\n}\r\n\r\nmodule.exports =  {\r\n    Jx,\r\n    JxTpl\r\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9qeC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb3JlL2p4LmpzPzAyZGEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcmUgPSAve3soW1xcc1xcU10rPyl9fS9cclxuXHJcbmZ1bmN0aW9uIGxvYWRKeCh4eCkge1xyXG4gICAgbGV0IHN0YWNrID0gW10sXHJcbiAgICAgICAgZTtcclxuXHJcbiAgICBmdW5jdGlvbiBpbm5lcihzeCkge1xyXG4gICAgICAgIGlmIChzeC5sZW5ndGggPT0gMCkgcmV0dXJuIHZvaWQgMDtcclxuICAgICAgICBpZiAoIShlID0gcmUuZXhlYyhzeCkpKSBzdGFjay5wdXNoKFswLCBzeF0pXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4ICE9IDEpIHN0YWNrLnB1c2goWzAsIHN4LnNsaWNlKDAsIGUuaW5kZXgpXSlcclxuICAgICAgICAgICAgaWYgKGVbMF1bMl0gPT0gXCI9XCIpIHN0YWNrLnB1c2goWzIsIGVbMV0uc2xpY2UoMSldKVxyXG4gICAgICAgICAgICBlbHNlIGlmIChlWzBdWzJdID09IFwiJFwiKSBzdGFjay5wdXNoKFszLCBlWzFdLnNsaWNlKDEpXSlcclxuICAgICAgICAgICAgZWxzZSBpZiAoZVswXVsyXSA9PSBcIipcIikgc3RhY2sucHVzaChbNCwgZVsxXS5zbGljZSgxKV0pXHJcbiAgICAgICAgICAgIGVsc2Ugc3RhY2sucHVzaChbMSwgZVsxXV0pXHJcbiAgICAgICAgICAgIGlubmVyKHN4LnNsaWNlKGUuaW5kZXggKyBlWzBdLmxlbmd0aCkpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaW5uZXIoeHgpXHJcbiAgICByZXR1cm4gc3RhY2tcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcGlsZShzdGFjaykge1xyXG4gICAgbGV0IGNvZGUgPSBcIlwiXHJcbiAgICBmb3IgKGNvbnN0IHJvdyBvZiBzdGFjaykge1xyXG4gICAgICAgIGxldCBjb250ZW50ID0gcm93WzFdLnRyaW0oKVxyXG4gICAgICAgIHN3aXRjaCAocm93WzBdKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIGNvZGUgKz0gYHlpZWxkIFxcYCR7Y29udGVudH1cXGA7YFxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTogLy8gY29tbWFuZFxyXG4gICAgICAgICAgICAgICAgY29kZSArPSBgJHtjb250ZW50fVxcbmBcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6IC8vID0gZ2V0IHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgY29kZSArPSBgeWllbGQgJHtjb250ZW50fTtgXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOiAvLyAkIHRwbCBjYWxsZWRcclxuICAgICAgICAgICAgICAgIGNvZGUgKz0gYHlpZWxkICQke2NvbnRlbnR9O2BcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDQ6IC8vICogY2FsbGVlXHJcbiAgICAgICAgICAgICAgICBjb2RlICs9IGB5aWVsZCogYXJndW1lbnRzLmNhbGxlZSgke2NvbnRlbnR9KTtgXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZhbChgKGZ1bmN0aW9uKihvYmope3dpdGgob2JqKXtcXG4ke2NvZGV9XFxufX0pYClcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcGlsZUp4KGp4X3RleHQpe1xyXG4gICAgcmV0dXJuIGNvbXBpbGUobG9hZEp4KGp4X3RleHQpKVxyXG59XHJcblxyXG5mdW5jdGlvbiB0cGxMb2FkZXIodHBsLGRhdGEpe1xyXG4gICAgcmV0dXJuIFsuLi50cGwoZGF0YSldLmpvaW4oXCJcIilcclxufVxyXG5cclxuZnVuY3Rpb24gX19KeChqeF90ZXh0LCBkYXRhKSB7XHJcbiAgICB2YXIgdHBsID0gY29tcGlsZUp4KGp4X3RleHQpXHJcbiAgICByZXR1cm4gdHBsTG9hZGVyKHRwbCwgZGF0YSlcclxufVxyXG5cclxuY2xhc3MgSnh7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHRoaXMubW9kcyA9IHt9XHJcbiAgICB9XHJcbiAgICBtb2QobmFtZSxqeF90ZXh0KXtcclxuICAgICAgICB0aGlzLm1vZHNbbmFtZV0gPSBkID0+IHRwbExvYWRlcihjb21waWxlSngoanhfdGV4dCksZClcclxuICAgIH1cclxuICAgIF9fcHJ4JChvKXtcclxuICAgICAgICBsZXQgdGhhdCA9IHRoaXNcclxuICAgICAgICByZXR1cm4gbmV3IFByb3h5KG8se1xyXG4gICAgICAgICAgICBnZXQobyxwcm9wKXtcclxuICAgICAgICAgICAgICAgIGlmKHByb3AgPT0gU3ltYm9sLnVuc2NvcGFibGVzKXJldHVybiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIGlmKHByb3BbMF0gPT0gXCIkXCIgJiYgcHJvcC5zbGljZSgxKSBpbiB0aGF0Lm1vZHMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQgPT4gdGhhdC5tb2RzW3Byb3Auc2xpY2UoMSldKHRoYXQuX19wcngkKGQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICBvW3Byb3BdXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhhcyhvLHByb3Ape1xyXG4gICAgICAgICAgICAgICAgaWYocHJvcC5zbGljZSgxKSBpbiB0aGF0Lm1vZHMgfHwgcHJvcCBpbiBvKXJldHVybiB0cnVlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbiAgICBjb21waWxlKGp4X3RleHQsZGF0YSl7XHJcbiAgICAgICAgcmV0dXJuIF9fSngoanhfdGV4dCwgdGhpcy5fX3ByeCQoZGF0YSkpXHJcbiAgICB9XHJcbiAgICBkdW1wVHBsKHRwbCxkYXRhKXtcclxuICAgICAgICByZXR1cm4gdHBsTG9hZGVyKHRwbCwgdGhpcy5fX3ByeCQoZGF0YSkpXHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIEp4VHBse1xyXG4gICAgY29uc3RydWN0b3IoanhfdGV4dCwgSnhHbG9iYWwpe1xyXG4gICAgICAgIHRoaXMudHBsID0gY29tcGlsZUp4KGp4X3RleHQpXHJcbiAgICAgICAgdGhpcy5fanggPSBKeEdsb2JhbFxyXG4gICAgfVxyXG4gICAgam9pbnQoZGF0YSl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2p4LmR1bXBUcGwodGhpcy50cGwsZGF0YSlcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAge1xyXG4gICAgSngsXHJcbiAgICBKeFRwbFxyXG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/jx.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime-module.js\");\n/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\nconst Poi = __webpack_require__(/*! ./core/Poi */ \"./src/core/Poi.js\");\r\n// const EventObj = require(\"./core/event\");\r\n// const TplEng = require(\"./core/template\");\r\n// const Jsvm = require(\"./util/JsVm\");\r\n\r\n// Poi.__TEST__ = {\r\n//     ev: (() => {\r\n//         let evobj = new EventObj(document);\r\n//         evobj.on(\"__TEST__\", () => {\r\n//             console.log(\"event manger is working!\")\r\n//         })\r\n//         return evobj;\r\n//     })(),\r\n//     tpl: (_t, _d) => {\r\n//         return new TplEng(_t).joint(_d || {});\r\n//     },\r\n//     vm: Jsvm\r\n// };\r\nif(typeof window != 'undefined')window.Poi = Poi\r\n\r\nlet usage = () => {\r\n    if (console) {\r\n        let msg = `\r\n        thx for u using!!!!poi~\r\n\r\n        now,poi is working!have fun.\r\n        `;\r\n        console.log(msg);\r\n    }\r\n}\r\nusage();\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXCJyZWdlbmVyYXRvci1ydW50aW1lXCI7XHJcblxyXG5jb25zdCBQb2kgPSByZXF1aXJlKFwiLi9jb3JlL1BvaVwiKTtcclxuLy8gY29uc3QgRXZlbnRPYmogPSByZXF1aXJlKFwiLi9jb3JlL2V2ZW50XCIpO1xyXG4vLyBjb25zdCBUcGxFbmcgPSByZXF1aXJlKFwiLi9jb3JlL3RlbXBsYXRlXCIpO1xyXG4vLyBjb25zdCBKc3ZtID0gcmVxdWlyZShcIi4vdXRpbC9Kc1ZtXCIpO1xyXG5cclxuLy8gUG9pLl9fVEVTVF9fID0ge1xyXG4vLyAgICAgZXY6ICgoKSA9PiB7XHJcbi8vICAgICAgICAgbGV0IGV2b2JqID0gbmV3IEV2ZW50T2JqKGRvY3VtZW50KTtcclxuLy8gICAgICAgICBldm9iai5vbihcIl9fVEVTVF9fXCIsICgpID0+IHtcclxuLy8gICAgICAgICAgICAgY29uc29sZS5sb2coXCJldmVudCBtYW5nZXIgaXMgd29ya2luZyFcIilcclxuLy8gICAgICAgICB9KVxyXG4vLyAgICAgICAgIHJldHVybiBldm9iajtcclxuLy8gICAgIH0pKCksXHJcbi8vICAgICB0cGw6IChfdCwgX2QpID0+IHtcclxuLy8gICAgICAgICByZXR1cm4gbmV3IFRwbEVuZyhfdCkuam9pbnQoX2QgfHwge30pO1xyXG4vLyAgICAgfSxcclxuLy8gICAgIHZtOiBKc3ZtXHJcbi8vIH07XHJcbmlmKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcpd2luZG93LlBvaSA9IFBvaVxyXG5cclxubGV0IHVzYWdlID0gKCkgPT4ge1xyXG4gICAgaWYgKGNvbnNvbGUpIHtcclxuICAgICAgICBsZXQgbXNnID0gYFxyXG4gICAgICAgIHRoeCBmb3IgdSB1c2luZyEhISFwb2l+XHJcblxyXG4gICAgICAgIG5vdyxwb2kgaXMgd29ya2luZyFoYXZlIGZ1bi5cclxuICAgICAgICBgO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XHJcbiAgICB9XHJcbn1cclxudXNhZ2UoKTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/util/JsVm.js":
/*!**************************!*\
  !*** ./src/util/JsVm.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("let extend = (o, n) => {\r\n    for (var p in n) {\r\n        if (n.hasOwnProperty(p) && (!o.hasOwnProperty(p)))\r\n            o[p] = n[p];\r\n    }\r\n};\r\nlet JSvm = (code, sandbox) => {\r\n    let rep_non_print = (text) => {\r\n        return text.replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\").replace(\"\\f\", \"\\\\f\").replace(\"\\v\", \"\\\\v\").replace(\"\\r\", \"\\\\r\")\r\n    }\r\n    sandbox = sandbox || {};\r\n    const fn = new Function('sandbox', `with(sandbox){${rep_non_print(code)}}`);\r\n    const _proxy = new Proxy(sandbox, {\r\n        has(target, key) {\r\n            return true;\r\n        }\r\n    });\r\n    return fn(_proxy);\r\n};\r\nlet multiCode2Tuple = (code) => {\r\n    return code.replace(/(^|;)return /g, \"\").replace(/([\"'])(.+?)(;)(.+?)\\1/g, \"$1$2$3#$4$1\").split(/;(?!#)/g).join(\",\").replace(\";#\", \";\");\r\n};\r\n\r\nclass VmError extends Error {\r\n    constructor(message) {\r\n        super();\r\n        Error.captureStackTrace(this, this.constructor);\r\n        this.message = message || 'Undefined error';\r\n        this.name = 'VmError';\r\n    }\r\n}\r\nlet JSafeVmWithBlackList = (code, sandbox, mixBlack) => {\r\n    let blacklist = [\"eval\", \"Function\"]\r\n    mixBlack = mixBlack ? mixBlack.push.apply(mixBlack, blacklist) : blacklist\r\n    let rep_non_print = (text) => {\r\n        return text.replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\").replace(\"\\f\", \"\\\\f\").replace(\"\\v\", \"\\\\v\").replace(\"\\r\", \"\\\\r\")\r\n    }\r\n    sandbox = sandbox || {};\r\n    const fn = new Function('sandbox', `with(sandbox){${rep_non_print(code)}}`);\r\n    const _proxy = new Proxy(sandbox, {\r\n        has(target, key) {\r\n            if(mixBlack.indexOf(key) != -1){\r\n                return true\r\n            }\r\n            return key in target;\r\n        }\r\n    });\r\n    return fn(_proxy);\r\n};\r\nlet micVm = (code, data) => {\r\n    let result;\r\n    // try {\r\n    result = new Function('obj', \"with(obj){\" + code + \"}\").apply(data, [data])\r\n    // } catch (err) {\r\n    //     console.error(\"'\" + err.message + \"'\", \" in \\n\\nCode:\\n\", code.replace(/;/g, \";\\n\").replace(/({|})/g, \"$1\\n\"));\r\n    // }\r\n    return result;\r\n}\r\n\r\nmodule.exports = {\r\n    safe: JSafeVmWithBlackList,\r\n    vm: JSvm,\r\n    micVm: micVm\r\n};\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbC9Kc1ZtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvSnNWbS5qcz84MmExIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBleHRlbmQgPSAobywgbikgPT4ge1xyXG4gICAgZm9yICh2YXIgcCBpbiBuKSB7XHJcbiAgICAgICAgaWYgKG4uaGFzT3duUHJvcGVydHkocCkgJiYgKCFvLmhhc093blByb3BlcnR5KHApKSlcclxuICAgICAgICAgICAgb1twXSA9IG5bcF07XHJcbiAgICB9XHJcbn07XHJcbmxldCBKU3ZtID0gKGNvZGUsIHNhbmRib3gpID0+IHtcclxuICAgIGxldCByZXBfbm9uX3ByaW50ID0gKHRleHQpID0+IHtcclxuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKFwiXFxuXCIsIFwiXFxcXG5cIikucmVwbGFjZShcIlxcdFwiLCBcIlxcXFx0XCIpLnJlcGxhY2UoXCJcXGZcIiwgXCJcXFxcZlwiKS5yZXBsYWNlKFwiXFx2XCIsIFwiXFxcXHZcIikucmVwbGFjZShcIlxcclwiLCBcIlxcXFxyXCIpXHJcbiAgICB9XHJcbiAgICBzYW5kYm94ID0gc2FuZGJveCB8fCB7fTtcclxuICAgIGNvbnN0IGZuID0gbmV3IEZ1bmN0aW9uKCdzYW5kYm94JywgYHdpdGgoc2FuZGJveCl7JHtyZXBfbm9uX3ByaW50KGNvZGUpfX1gKTtcclxuICAgIGNvbnN0IF9wcm94eSA9IG5ldyBQcm94eShzYW5kYm94LCB7XHJcbiAgICAgICAgaGFzKHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGZuKF9wcm94eSk7XHJcbn07XHJcbmxldCBtdWx0aUNvZGUyVHVwbGUgPSAoY29kZSkgPT4ge1xyXG4gICAgcmV0dXJuIGNvZGUucmVwbGFjZSgvKF58OylyZXR1cm4gL2csIFwiXCIpLnJlcGxhY2UoLyhbXCInXSkoLis/KSg7KSguKz8pXFwxL2csIFwiJDEkMiQzIyQ0JDFcIikuc3BsaXQoLzsoPyEjKS9nKS5qb2luKFwiLFwiKS5yZXBsYWNlKFwiOyNcIiwgXCI7XCIpO1xyXG59O1xyXG5cclxuY2xhc3MgVm1FcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1VuZGVmaW5lZCBlcnJvcic7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ1ZtRXJyb3InO1xyXG4gICAgfVxyXG59XHJcbmxldCBKU2FmZVZtV2l0aEJsYWNrTGlzdCA9IChjb2RlLCBzYW5kYm94LCBtaXhCbGFjaykgPT4ge1xyXG4gICAgbGV0IGJsYWNrbGlzdCA9IFtcImV2YWxcIiwgXCJGdW5jdGlvblwiXVxyXG4gICAgbWl4QmxhY2sgPSBtaXhCbGFjayA/IG1peEJsYWNrLnB1c2guYXBwbHkobWl4QmxhY2ssIGJsYWNrbGlzdCkgOiBibGFja2xpc3RcclxuICAgIGxldCByZXBfbm9uX3ByaW50ID0gKHRleHQpID0+IHtcclxuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKFwiXFxuXCIsIFwiXFxcXG5cIikucmVwbGFjZShcIlxcdFwiLCBcIlxcXFx0XCIpLnJlcGxhY2UoXCJcXGZcIiwgXCJcXFxcZlwiKS5yZXBsYWNlKFwiXFx2XCIsIFwiXFxcXHZcIikucmVwbGFjZShcIlxcclwiLCBcIlxcXFxyXCIpXHJcbiAgICB9XHJcbiAgICBzYW5kYm94ID0gc2FuZGJveCB8fCB7fTtcclxuICAgIGNvbnN0IGZuID0gbmV3IEZ1bmN0aW9uKCdzYW5kYm94JywgYHdpdGgoc2FuZGJveCl7JHtyZXBfbm9uX3ByaW50KGNvZGUpfX1gKTtcclxuICAgIGNvbnN0IF9wcm94eSA9IG5ldyBQcm94eShzYW5kYm94LCB7XHJcbiAgICAgICAgaGFzKHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgICAgIGlmKG1peEJsYWNrLmluZGV4T2Yoa2V5KSAhPSAtMSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBrZXkgaW4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGZuKF9wcm94eSk7XHJcbn07XHJcbmxldCBtaWNWbSA9IChjb2RlLCBkYXRhKSA9PiB7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgLy8gdHJ5IHtcclxuICAgIHJlc3VsdCA9IG5ldyBGdW5jdGlvbignb2JqJywgXCJ3aXRoKG9iail7XCIgKyBjb2RlICsgXCJ9XCIpLmFwcGx5KGRhdGEsIFtkYXRhXSlcclxuICAgIC8vIH0gY2F0Y2ggKGVycikge1xyXG4gICAgLy8gICAgIGNvbnNvbGUuZXJyb3IoXCInXCIgKyBlcnIubWVzc2FnZSArIFwiJ1wiLCBcIiBpbiBcXG5cXG5Db2RlOlxcblwiLCBjb2RlLnJlcGxhY2UoLzsvZywgXCI7XFxuXCIpLnJlcGxhY2UoLyh7fH0pL2csIFwiJDFcXG5cIikpO1xyXG4gICAgLy8gfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBzYWZlOiBKU2FmZVZtV2l0aEJsYWNrTGlzdCxcclxuICAgIHZtOiBKU3ZtLFxyXG4gICAgbWljVm06IG1pY1ZtXHJcbn07XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/util/JsVm.js\n");

/***/ }),

/***/ "./src/util/domApi.js":
/*!****************************!*\
  !*** ./src/util/domApi.js ***!
  \****************************/
/*! exports provided: domApi */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"domApi\", function() { return domApi; });\n\r\nconst arrDiffer = (a, b) => {\r\n    // if the other array is a falsy value, return\r\n    if (!a || !b)\r\n        return false\r\n    // compare lengths - can save a lot of time\r\n    if (a.length != b.length)\r\n        return false\r\n    let isIn = (arr1, arr2) => {\r\n        for (let i in arr1) {\r\n            let nullInOther = true\r\n            for (let j in arr2) {\r\n                if (arr1[i] == arr2[j]) {\r\n                    nullInOther = false\r\n                }\r\n            }\r\n            if (nullInOther) {\r\n                return false\r\n            }\r\n        }\r\n        return true\r\n    }\r\n    return isIn(a, b) && isIn(b, a)\r\n}\r\n\r\nconst domApi = {\r\n    $: _selector => {\r\n        let ele = document.querySelector(_selector)\r\n        ele.html = function(_newHtml) {\r\n            if (this.empty) {\r\n                return ''\r\n            }\r\n            if (_newHtml != undefined) {\r\n                this.innerHTML = _newHtml;\r\n                return _newHtml;\r\n            } else {\r\n                return this.innerHTML;\r\n            }\r\n        };\r\n        return ele\r\n    },\r\n    createDom: _html => {\r\n        let tempRoot = document.createElement(\"div\")\r\n        tempRoot.innerHTML = _html\r\n        return tempRoot.children[0]\r\n    },\r\n    createDomTree: _html => {\r\n        let tempRoot = document.createElement(\"div\")\r\n        tempRoot.innerHTML = _html\r\n        return tempRoot.childNodes\r\n    },\r\n    append: (newElement, targetElement) => {\r\n        newElement = typeof newElement == typeof \"\" ? domApi.createDom(newElement) : newElement\r\n        return targetElement.appendChild(newElement)\r\n    },\r\n    insertBefore: (newElement, targetElement) => {\r\n        let parent = targetElement.parentNode\r\n        newElement = typeof newElement == typeof \"\" ? domApi.createDom(newElement) : newElement\r\n        return parent.insertBefore(newElement, targetElement)\r\n    },\r\n    insertAfter: (newElement, targetElement) => {\r\n        var parent = targetElement.parentNode;\r\n        if (parent.lastChild == targetElement) {\r\n            parent.appendChild(newElement);\r\n        } else {\r\n            parent.insertBefore(newElement, targetElement.nextSibling)\r\n        }\r\n    },\r\n    remove: targetElement => {\r\n        if (targetElement == undefined) return\r\n        let parent = targetElement.parentNode\r\n        if (parent == undefined) {\r\n            targetElement = null\r\n            return\r\n        }\r\n        parent.removeChild(targetElement)\r\n    },\r\n    isSame: (ele1, ele2) => {\r\n        if (ele1 == undefined || ele2 == undefined) return false;\r\n        if (ele1.nodeType != ele2.nodeType) return false;\r\n        if (ele1.nodeType == 1) {\r\n            // node\r\n            return (\r\n                ele1.nodeName == ele2.nodeName &&\r\n                ele1.id == ele2.id &&\r\n                ele1.innerText.trim() == ele2.innerText.trim()\r\n                // && ele1.className == ele2.className\r\n            )\r\n        }\r\n        if (ele1.nodeType == 3) {\r\n            // text node\r\n            return (\r\n                // domApi.isSame(ele1.parentNode, ele2.parentNode) &&\r\n                ele1.textContent == ele2.textContent\r\n            )\r\n        }\r\n    },\r\n    classListDiff: (ele1, ele2) => {\r\n        if (ele1.classList.length != ele2.classList.length) {\r\n            return false\r\n        }\r\n        let cList2Arr = ele => {\r\n            let res = []\r\n            ele.classList.forEach(val => {\r\n                res.push(val)\r\n            })\r\n            return res\r\n        }\r\n        return arrDiffer(cList2Arr(ele1), cList2Arr(ele2))\r\n    },\r\n    attributesDiff: (ele1, ele2) => {\r\n        // *** bad idea! ***\r\n        // if(ele1.attributes.length!=ele2.attributes.length){\r\n        //     return false\r\n        // }\r\n        let attributes2Arr = ele => {\r\n            let res = []\r\n            let tempCur = 0\r\n            let blacks = [\"class\"]\r\n            while (true) {\r\n                let curNode = ele.attributes[tempCur]\r\n                if (curNode) {\r\n                    if (/(.+?):.+?/g.test(curNode.name)) {\r\n                        blacks.push(/(.+?):(.+)/g.exec(curNode.name)[2])\r\n                        tempCur += 1\r\n                        continue\r\n                    }\r\n                    if (blacks.indexOf(curNode.name) != -1) {\r\n                        tempCur += 1\r\n                        continue\r\n                    }\r\n                    res.push(curNode.nodeValue)\r\n                } else {\r\n                    break\r\n                }\r\n                tempCur += 1\r\n            }\r\n            return res\r\n        }\r\n        return arrDiffer(attributes2Arr(ele1), attributes2Arr(ele2))\r\n    },\r\n    // #901\r\n    // Failed to execute 'setNamedItem' on 'NamedNodeMap':\r\n    // The node provided is an attribute node that is alre-\r\n    // ady an attribute of another Element; attribute node-\r\n    // s must be explicitly cloned.\r\n    //\r\n    attributesClone: (ele, to) => {\r\n        for (let attr of ele.attributes) {\r\n            ele.attributes.removeNamedItem(attr.name)\r\n        }\r\n        for (let attr of to.attributes) {\r\n            ele.attributes.setNamedItem(attr.cloneNode(true))\r\n        }\r\n    },\r\n    Comparable: (ele1, ele2) => {\r\n        if (ele1 == undefined || ele2 == undefined) return false;\r\n        if (ele1.nodeType != ele2.nodeType) return false;\r\n        if (ele1.nodeType == 3) return true;\r\n        return (\r\n            ele1.nodeName == ele2.nodeName &&\r\n            ele1.id == ele2.id &&\r\n            ele1.className == ele2.className\r\n        )\r\n    }\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbC9kb21BcGkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC9kb21BcGkuanM/Mjc2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuY29uc3QgYXJyRGlmZmVyID0gKGEsIGIpID0+IHtcclxuICAgIC8vIGlmIHRoZSBvdGhlciBhcnJheSBpcyBhIGZhbHN5IHZhbHVlLCByZXR1cm5cclxuICAgIGlmICghYSB8fCAhYilcclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgIC8vIGNvbXBhcmUgbGVuZ3RocyAtIGNhbiBzYXZlIGEgbG90IG9mIHRpbWVcclxuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgIGxldCBpc0luID0gKGFycjEsIGFycjIpID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpIGluIGFycjEpIHtcclxuICAgICAgICAgICAgbGV0IG51bGxJbk90aGVyID0gdHJ1ZVxyXG4gICAgICAgICAgICBmb3IgKGxldCBqIGluIGFycjIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhcnIxW2ldID09IGFycjJbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICBudWxsSW5PdGhlciA9IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG51bGxJbk90aGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzSW4oYSwgYikgJiYgaXNJbihiLCBhKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZG9tQXBpID0ge1xyXG4gICAgJDogX3NlbGVjdG9yID0+IHtcclxuICAgICAgICBsZXQgZWxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihfc2VsZWN0b3IpXHJcbiAgICAgICAgZWxlLmh0bWwgPSBmdW5jdGlvbihfbmV3SHRtbCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5lbXB0eSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKF9uZXdIdG1sICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lckhUTUwgPSBfbmV3SHRtbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfbmV3SHRtbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlubmVySFRNTDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGVsZVxyXG4gICAgfSxcclxuICAgIGNyZWF0ZURvbTogX2h0bWwgPT4ge1xyXG4gICAgICAgIGxldCB0ZW1wUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcclxuICAgICAgICB0ZW1wUm9vdC5pbm5lckhUTUwgPSBfaHRtbFxyXG4gICAgICAgIHJldHVybiB0ZW1wUm9vdC5jaGlsZHJlblswXVxyXG4gICAgfSxcclxuICAgIGNyZWF0ZURvbVRyZWU6IF9odG1sID0+IHtcclxuICAgICAgICBsZXQgdGVtcFJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXHJcbiAgICAgICAgdGVtcFJvb3QuaW5uZXJIVE1MID0gX2h0bWxcclxuICAgICAgICByZXR1cm4gdGVtcFJvb3QuY2hpbGROb2Rlc1xyXG4gICAgfSxcclxuICAgIGFwcGVuZDogKG5ld0VsZW1lbnQsIHRhcmdldEVsZW1lbnQpID0+IHtcclxuICAgICAgICBuZXdFbGVtZW50ID0gdHlwZW9mIG5ld0VsZW1lbnQgPT0gdHlwZW9mIFwiXCIgPyBkb21BcGkuY3JlYXRlRG9tKG5ld0VsZW1lbnQpIDogbmV3RWxlbWVudFxyXG4gICAgICAgIHJldHVybiB0YXJnZXRFbGVtZW50LmFwcGVuZENoaWxkKG5ld0VsZW1lbnQpXHJcbiAgICB9LFxyXG4gICAgaW5zZXJ0QmVmb3JlOiAobmV3RWxlbWVudCwgdGFyZ2V0RWxlbWVudCkgPT4ge1xyXG4gICAgICAgIGxldCBwYXJlbnQgPSB0YXJnZXRFbGVtZW50LnBhcmVudE5vZGVcclxuICAgICAgICBuZXdFbGVtZW50ID0gdHlwZW9mIG5ld0VsZW1lbnQgPT0gdHlwZW9mIFwiXCIgPyBkb21BcGkuY3JlYXRlRG9tKG5ld0VsZW1lbnQpIDogbmV3RWxlbWVudFxyXG4gICAgICAgIHJldHVybiBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5ld0VsZW1lbnQsIHRhcmdldEVsZW1lbnQpXHJcbiAgICB9LFxyXG4gICAgaW5zZXJ0QWZ0ZXI6IChuZXdFbGVtZW50LCB0YXJnZXRFbGVtZW50KSA9PiB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRhcmdldEVsZW1lbnQucGFyZW50Tm9kZTtcclxuICAgICAgICBpZiAocGFyZW50Lmxhc3RDaGlsZCA9PSB0YXJnZXRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChuZXdFbGVtZW50KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5ld0VsZW1lbnQsIHRhcmdldEVsZW1lbnQubmV4dFNpYmxpbmcpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlbW92ZTogdGFyZ2V0RWxlbWVudCA9PiB7XHJcbiAgICAgICAgaWYgKHRhcmdldEVsZW1lbnQgPT0gdW5kZWZpbmVkKSByZXR1cm5cclxuICAgICAgICBsZXQgcGFyZW50ID0gdGFyZ2V0RWxlbWVudC5wYXJlbnROb2RlXHJcbiAgICAgICAgaWYgKHBhcmVudCA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudCA9IG51bGxcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0YXJnZXRFbGVtZW50KVxyXG4gICAgfSxcclxuICAgIGlzU2FtZTogKGVsZTEsIGVsZTIpID0+IHtcclxuICAgICAgICBpZiAoZWxlMSA9PSB1bmRlZmluZWQgfHwgZWxlMiA9PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoZWxlMS5ub2RlVHlwZSAhPSBlbGUyLm5vZGVUeXBlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKGVsZTEubm9kZVR5cGUgPT0gMSkge1xyXG4gICAgICAgICAgICAvLyBub2RlXHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICBlbGUxLm5vZGVOYW1lID09IGVsZTIubm9kZU5hbWUgJiZcclxuICAgICAgICAgICAgICAgIGVsZTEuaWQgPT0gZWxlMi5pZCAmJlxyXG4gICAgICAgICAgICAgICAgZWxlMS5pbm5lclRleHQudHJpbSgpID09IGVsZTIuaW5uZXJUZXh0LnRyaW0oKVxyXG4gICAgICAgICAgICAgICAgLy8gJiYgZWxlMS5jbGFzc05hbWUgPT0gZWxlMi5jbGFzc05hbWVcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWxlMS5ub2RlVHlwZSA9PSAzKSB7XHJcbiAgICAgICAgICAgIC8vIHRleHQgbm9kZVxyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgLy8gZG9tQXBpLmlzU2FtZShlbGUxLnBhcmVudE5vZGUsIGVsZTIucGFyZW50Tm9kZSkgJiZcclxuICAgICAgICAgICAgICAgIGVsZTEudGV4dENvbnRlbnQgPT0gZWxlMi50ZXh0Q29udGVudFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNsYXNzTGlzdERpZmY6IChlbGUxLCBlbGUyKSA9PiB7XHJcbiAgICAgICAgaWYgKGVsZTEuY2xhc3NMaXN0Lmxlbmd0aCAhPSBlbGUyLmNsYXNzTGlzdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjTGlzdDJBcnIgPSBlbGUgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcmVzID0gW11cclxuICAgICAgICAgICAgZWxlLmNsYXNzTGlzdC5mb3JFYWNoKHZhbCA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXMucHVzaCh2YWwpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIHJldHVybiByZXNcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFyckRpZmZlcihjTGlzdDJBcnIoZWxlMSksIGNMaXN0MkFycihlbGUyKSlcclxuICAgIH0sXHJcbiAgICBhdHRyaWJ1dGVzRGlmZjogKGVsZTEsIGVsZTIpID0+IHtcclxuICAgICAgICAvLyAqKiogYmFkIGlkZWEhICoqKlxyXG4gICAgICAgIC8vIGlmKGVsZTEuYXR0cmlidXRlcy5sZW5ndGghPWVsZTIuYXR0cmlidXRlcy5sZW5ndGgpe1xyXG4gICAgICAgIC8vICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgbGV0IGF0dHJpYnV0ZXMyQXJyID0gZWxlID0+IHtcclxuICAgICAgICAgICAgbGV0IHJlcyA9IFtdXHJcbiAgICAgICAgICAgIGxldCB0ZW1wQ3VyID0gMFxyXG4gICAgICAgICAgICBsZXQgYmxhY2tzID0gW1wiY2xhc3NcIl1cclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjdXJOb2RlID0gZWxlLmF0dHJpYnV0ZXNbdGVtcEN1cl1cclxuICAgICAgICAgICAgICAgIGlmIChjdXJOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKC8oLis/KTouKz8vZy50ZXN0KGN1ck5vZGUubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmxhY2tzLnB1c2goLyguKz8pOiguKykvZy5leGVjKGN1ck5vZGUubmFtZSlbMl0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBDdXIgKz0gMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmxhY2tzLmluZGV4T2YoY3VyTm9kZS5uYW1lKSAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wQ3VyICs9IDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goY3VyTm9kZS5ub2RlVmFsdWUpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0ZW1wQ3VyICs9IDFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnJEaWZmZXIoYXR0cmlidXRlczJBcnIoZWxlMSksIGF0dHJpYnV0ZXMyQXJyKGVsZTIpKVxyXG4gICAgfSxcclxuICAgIC8vICM5MDFcclxuICAgIC8vIEZhaWxlZCB0byBleGVjdXRlICdzZXROYW1lZEl0ZW0nIG9uICdOYW1lZE5vZGVNYXAnOlxyXG4gICAgLy8gVGhlIG5vZGUgcHJvdmlkZWQgaXMgYW4gYXR0cmlidXRlIG5vZGUgdGhhdCBpcyBhbHJlLVxyXG4gICAgLy8gYWR5IGFuIGF0dHJpYnV0ZSBvZiBhbm90aGVyIEVsZW1lbnQ7IGF0dHJpYnV0ZSBub2RlLVxyXG4gICAgLy8gcyBtdXN0IGJlIGV4cGxpY2l0bHkgY2xvbmVkLlxyXG4gICAgLy9cclxuICAgIGF0dHJpYnV0ZXNDbG9uZTogKGVsZSwgdG8pID0+IHtcclxuICAgICAgICBmb3IgKGxldCBhdHRyIG9mIGVsZS5hdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgIGVsZS5hdHRyaWJ1dGVzLnJlbW92ZU5hbWVkSXRlbShhdHRyLm5hbWUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGF0dHIgb2YgdG8uYXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICBlbGUuYXR0cmlidXRlcy5zZXROYW1lZEl0ZW0oYXR0ci5jbG9uZU5vZGUodHJ1ZSkpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIENvbXBhcmFibGU6IChlbGUxLCBlbGUyKSA9PiB7XHJcbiAgICAgICAgaWYgKGVsZTEgPT0gdW5kZWZpbmVkIHx8IGVsZTIgPT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKGVsZTEubm9kZVR5cGUgIT0gZWxlMi5ub2RlVHlwZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChlbGUxLm5vZGVUeXBlID09IDMpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIGVsZTEubm9kZU5hbWUgPT0gZWxlMi5ub2RlTmFtZSAmJlxyXG4gICAgICAgICAgICBlbGUxLmlkID09IGVsZTIuaWQgJiZcclxuICAgICAgICAgICAgZWxlMS5jbGFzc05hbWUgPT0gZWxlMi5jbGFzc05hbWVcclxuICAgICAgICApXHJcbiAgICB9XHJcbn1cclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/util/domApi.js\n");

/***/ }),

/***/ "./src/util/frameify.js":
/*!******************************!*\
  !*** ./src/util/frameify.js ***!
  \******************************/
/*! exports provided: frameify */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frameify\", function() { return frameify; });\n// 很奇怪的做法，主要是为了实现time slice，\r\n// 将主体为生成器的task化为promise，\r\n// 从而支持await和async\r\n// @more: https://www.w3.org/TR/requestidlecallback/\r\n\r\nvar reqFrame = ((window) => {\r\n    // 每帧50ms\r\n    // * 本来按照常识，这里是很适合idlecallback的，\r\n    //   当然，之前也是那么写的，不过现在，如你所见\r\n    //   我将每帧定义在50ms内\r\n    //   不仅减少不必要的调用，也不用关心idle是怎么实现的\r\n    //   比如chrome的idle会因为鼠标闲置而被block...?!?\r\n    //   实在没弄懂为什么是这种行为...\r\n    //   不过现在已经不用担心了~\r\n    //\r\n    const rF = window.requestAnimationFrame ||\r\n        window.webkitRequestAnimationFrame ||\r\n        window.mozRequestAnimationFrame;\r\n    if (rF) {\r\n        return function(cb) {\r\n            var start = Date.now();\r\n            return rF(function(call2now) {\r\n                cb({\r\n                    timeRemaining() {\r\n                        return Math.max(0, 50 - (Date.now() - start));\r\n                    },\r\n                });\r\n            });\r\n        };\r\n    }\r\n    // default\r\n    return function(cb) {\r\n        var start = Date.now();\r\n        return setTimeout(function() {\r\n            cb({\r\n                timeRemainingn() {\r\n                    return Math.max(0, 50 - (Date.now() - start));\r\n                },\r\n            });\r\n        }, 1);\r\n    };\r\n})(window);\r\n\r\nvar cancelFrame = ((window) => {\r\n    return window.cancelAnimationFrame ||\r\n        window.webkitCancelAnimationFrame ||\r\n        window.webkitCancelRequestAnimationFrame ||\r\n        window.mozCancelAnimationFrame ||\r\n        window.mozCancelRequestAnimationFrame || (id => clearTimeout(id));\r\n})(window);\r\n\r\nfunction frameify(gen, _Int_) {\r\n    return new Promise((resolve, reject) => {\r\n        var frameid;\r\n        if (_Int_) _Int_.clear = () => {\r\n            // Interrupt\r\n            cancelFrame(frameid);\r\n            // console.log(\"clear\", frameid)\r\n            resolve(void 0);\r\n            return void 0;\r\n        }\r\n\r\n        function inner() {\r\n            frameid = reqFrame((deadline) => {\r\n                while (deadline.timeRemaining() > 5) {\r\n                    var n = gen.next();\r\n                    if (n.done) {\r\n                        resolve(n.value);\r\n                        return void 0;\r\n                    }\r\n                }\r\n                inner();\r\n            })\r\n        }\r\n        try {\r\n            inner()\r\n        } catch (e) {\r\n            reject(e)\r\n        }\r\n    })\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbC9mcmFtZWlmeS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy91dGlsL2ZyYW1laWZ5LmpzPzllMDQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8g5b6I5aWH5oCq55qE5YGa5rOV77yM5Li76KaB5piv5Li65LqG5a6e546wdGltZSBzbGljZe+8jFxyXG4vLyDlsIbkuLvkvZPkuLrnlJ/miJDlmajnmoR0YXNr5YyW5Li6cHJvbWlzZe+8jFxyXG4vLyDku47ogIzmlK/mjIFhd2FpdOWSjGFzeW5jXHJcbi8vIEBtb3JlOiBodHRwczovL3d3dy53My5vcmcvVFIvcmVxdWVzdGlkbGVjYWxsYmFjay9cclxuXHJcbnZhciByZXFGcmFtZSA9ICgod2luZG93KSA9PiB7XHJcbiAgICAvLyDmr4/luKc1MG1zXHJcbiAgICAvLyAqIOacrOadpeaMieeFp+W4uOivhu+8jOi/memHjOaYr+W+iOmAguWQiGlkbGVjYWxsYmFja+eahO+8jFxyXG4gICAgLy8gICDlvZPnhLbvvIzkuYvliY3kuZ/mmK/pgqPkuYjlhpnnmoTvvIzkuI3ov4fnjrDlnKjvvIzlpoLkvaDmiYDop4FcclxuICAgIC8vICAg5oiR5bCG5q+P5bin5a6a5LmJ5ZyoNTBtc+WGhVxyXG4gICAgLy8gICDkuI3ku4Xlh4/lsJHkuI3lv4XopoHnmoTosIPnlKjvvIzkuZ/kuI3nlKjlhbPlv4NpZGxl5piv5oCO5LmI5a6e546w55qEXHJcbiAgICAvLyAgIOavlOWmgmNocm9tZeeahGlkbGXkvJrlm6DkuLrpvKDmoIfpl7Lnva7ogIzooqtibG9jay4uLj8hP1xyXG4gICAgLy8gICDlrp7lnKjmsqHlvITmh4LkuLrku4DkuYjmmK/ov5nnp43ooYzkuLouLi5cclxuICAgIC8vICAg5LiN6L+H546w5Zyo5bey57uP5LiN55So5ouF5b+D5LqGflxyXG4gICAgLy9cclxuICAgIGNvbnN0IHJGID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xyXG4gICAgaWYgKHJGKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNiKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHJldHVybiByRihmdW5jdGlvbihjYWxsMm5vdykge1xyXG4gICAgICAgICAgICAgICAgY2Ioe1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVSZW1haW5pbmcoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCA1MCAtIChEYXRlLm5vdygpIC0gc3RhcnQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBkZWZhdWx0XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oY2IpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBjYih7XHJcbiAgICAgICAgICAgICAgICB0aW1lUmVtYWluaW5nbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgNTAgLSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCAxKTtcclxuICAgIH07XHJcbn0pKHdpbmRvdyk7XHJcblxyXG52YXIgY2FuY2VsRnJhbWUgPSAoKHdpbmRvdykgPT4ge1xyXG4gICAgcmV0dXJuIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgIHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgIHdpbmRvdy53ZWJraXRDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICB3aW5kb3cubW96Q2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IChpZCA9PiBjbGVhclRpbWVvdXQoaWQpKTtcclxufSkod2luZG93KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmcmFtZWlmeShnZW4sIF9JbnRfKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHZhciBmcmFtZWlkO1xyXG4gICAgICAgIGlmIChfSW50XykgX0ludF8uY2xlYXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEludGVycnVwdFxyXG4gICAgICAgICAgICBjYW5jZWxGcmFtZShmcmFtZWlkKTtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJjbGVhclwiLCBmcmFtZWlkKVxyXG4gICAgICAgICAgICByZXNvbHZlKHZvaWQgMCk7XHJcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBpbm5lcigpIHtcclxuICAgICAgICAgICAgZnJhbWVpZCA9IHJlcUZyYW1lKChkZWFkbGluZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGRlYWRsaW5lLnRpbWVSZW1haW5pbmcoKSA+IDUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGdlbi5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4uZG9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG4udmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlubmVyKCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlubmVyKClcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJlamVjdChlKVxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbn1cclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/util/frameify.js\n");

/***/ }),

/***/ "./src/util/util.js":
/*!**************************!*\
  !*** ./src/util/util.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function getType(obj) {\r\n    if (obj instanceof Element) return 'dom';\r\n    return Object.prototype.toString.call(obj).slice(8).slice(0, -1).toLowerCase();\r\n}\r\n\r\nfunction deepClone(data) {\r\n    var type = getType(data);\r\n    var obj;\r\n    if (type === 'array') {\r\n        obj = [];\r\n    } else if (type === 'object') {\r\n        obj = {};\r\n    } else {\r\n        return data;\r\n    }\r\n    if (type === 'array') {\r\n        for (var i = 0, len = data.length; i < len; i++) {\r\n            obj.push(deepClone(data[i]));\r\n        }\r\n    } else if (type === 'object') {\r\n        for (var key in data) {\r\n            obj[key] = deepClone(data[key]);\r\n        }\r\n    }\r\n    return obj;\r\n}\r\n\r\nlet extend = (o, n) => {\r\n    for (var p in n) {\r\n        if (n.hasOwnProperty(p) && (!o.hasOwnProperty(p)))\r\n            o[p] = n[p];\r\n    }\r\n};\r\n\r\nlet arrMerge = (a, b) => {\r\n    a.push.apply(a, b);\r\n};\r\n\r\nlet support_list = [\"resize\", \"load\", \"click\", \"dblclick\", \"change\", \"blur\", \"focus\", \"keydown\", \"keyup\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"select\", \"keypress\"];\r\n\r\nlet GetAttrElement = (attr, val) => {\r\n    let e = document.all;\r\n    let a = new Array();\r\n    for (let i = 0; i < e.length; i++) {\r\n        if (e[i].getAttribute(attr) == val) {\r\n            a.push(e[i])\r\n        }\r\n    }\r\n    return a;\r\n}\r\n\r\nfunction proxy_catch_set(that, cb) {\r\n    if ( getType(that) == \"array\" ) {\r\n        return proxy_arr(that, cb);\r\n    }\r\n    if ( getType(that) == \"object\"){\r\n        return new Proxy(that, {\r\n            set(obj, prop, val) {\r\n                if (obj[prop] != val) {\r\n                    obj[prop] = val;\r\n                    cb();\r\n                }\r\n                return true;\r\n            }\r\n        })\r\n    }\r\n    // default\r\n    return that\r\n}\r\n\r\nfunction proxy_arr(arr, cb) {\r\n    if (arr.length != 0) {\r\n        for (var i = 0; i < arr.length; i++) {\r\n            arr[i] = proxy_catch_set(arr[i], () => cb(arr));\r\n        }\r\n    }\r\n    // #u1 double callback.fixed\r\n    return new Proxy(arr, {\r\n        set(obj, prop, val) {\r\n            var calling = false\r\n            if (prop == 'length'){\r\n                if(obj[prop] > val){\r\n                    // 仅改变长度不会修改特定prop\r\n                    // pop\r\n                    calling = true\r\n                }\r\n                // else {\r\n                //     // push: 分别需要设置新prop的值并设置length,只用calling一次\r\n                //     // push or add \r\n                //     void 0;\r\n                // }\r\n            }\r\n            else if (obj[prop] != val){\r\n                calling = true\r\n            }\r\n            if(!isNaN(prop))obj[prop] = proxy_catch_set(val, () => cb(obj))\r\n            else obj[prop] = val\r\n            // render callback\r\n            if(calling)cb(obj);\r\n            return true;\r\n        }\r\n    })\r\n}\r\n\r\nconst $ = (...args) => document.querySelector.apply(document,args)\r\nconst $$ = (...args) => document.querySelectorAll.apply(document,args)\r\n\r\n// &gt; => >\r\n// &lt; => <\r\n// ...\r\nconst escape2Html = s => s.replace(/&(lt|gt|nbsp|amp|quot);/ig,(all,t)=>({'lt':'<','gt':'>','nbsp':' ','amp':'&','quot':'\"'})[t]);\r\n// trim and merge \\r\\n\r\nconst trimBr = s => s.replace(/((\\s| )*\\r?\\n){3,}/g,\"\\r\\n\\r\\n\").replace(/^((\\s| )*\\r?\\n)+/g,'').replace(/((\\s| )*\\r?\\n)+$/g,'');\r\nconst mergeSpace = s => s.replace(/(\\s| )+/g,' ');\r\nfunction HTMLClean(text){\r\n    return escape2Html(mergeSpace(trimBr(text)))\r\n}\r\n\r\nmodule.exports = {\r\n    deepClone,\r\n    extend,\r\n    arrMerge,\r\n    ev_supList: support_list,\r\n    GetAttrElement,\r\n    proxyArr: proxy_arr,\r\n    $,$$,\r\n    HTMLClean\r\n};\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbC91dGlsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWwvdXRpbC5qcz8wZTBiIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGdldFR5cGUob2JqKSB7XHJcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgRWxlbWVudCkgcmV0dXJuICdkb20nO1xyXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopLnNsaWNlKDgpLnNsaWNlKDAsIC0xKS50b0xvd2VyQ2FzZSgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWVwQ2xvbmUoZGF0YSkge1xyXG4gICAgdmFyIHR5cGUgPSBnZXRUeXBlKGRhdGEpO1xyXG4gICAgdmFyIG9iajtcclxuICAgIGlmICh0eXBlID09PSAnYXJyYXknKSB7XHJcbiAgICAgICAgb2JqID0gW107XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgb2JqID0ge307XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGUgPT09ICdhcnJheScpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBvYmoucHVzaChkZWVwQ2xvbmUoZGF0YVtpXSkpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xyXG4gICAgICAgICAgICBvYmpba2V5XSA9IGRlZXBDbG9uZShkYXRhW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbmxldCBleHRlbmQgPSAobywgbikgPT4ge1xyXG4gICAgZm9yICh2YXIgcCBpbiBuKSB7XHJcbiAgICAgICAgaWYgKG4uaGFzT3duUHJvcGVydHkocCkgJiYgKCFvLmhhc093blByb3BlcnR5KHApKSlcclxuICAgICAgICAgICAgb1twXSA9IG5bcF07XHJcbiAgICB9XHJcbn07XHJcblxyXG5sZXQgYXJyTWVyZ2UgPSAoYSwgYikgPT4ge1xyXG4gICAgYS5wdXNoLmFwcGx5KGEsIGIpO1xyXG59O1xyXG5cclxubGV0IHN1cHBvcnRfbGlzdCA9IFtcInJlc2l6ZVwiLCBcImxvYWRcIiwgXCJjbGlja1wiLCBcImRibGNsaWNrXCIsIFwiY2hhbmdlXCIsIFwiYmx1clwiLCBcImZvY3VzXCIsIFwia2V5ZG93blwiLCBcImtleXVwXCIsIFwibW91c2Vkb3duXCIsIFwibW91c2Vtb3ZlXCIsIFwibW91c2VvdXRcIiwgXCJtb3VzZW92ZXJcIiwgXCJtb3VzZXVwXCIsIFwic2VsZWN0XCIsIFwia2V5cHJlc3NcIl07XHJcblxyXG5sZXQgR2V0QXR0ckVsZW1lbnQgPSAoYXR0ciwgdmFsKSA9PiB7XHJcbiAgICBsZXQgZSA9IGRvY3VtZW50LmFsbDtcclxuICAgIGxldCBhID0gbmV3IEFycmF5KCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoZVtpXS5nZXRBdHRyaWJ1dGUoYXR0cikgPT0gdmFsKSB7XHJcbiAgICAgICAgICAgIGEucHVzaChlW2ldKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBhO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcm94eV9jYXRjaF9zZXQodGhhdCwgY2IpIHtcclxuICAgIGlmICggZ2V0VHlwZSh0aGF0KSA9PSBcImFycmF5XCIgKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3h5X2Fycih0aGF0LCBjYik7XHJcbiAgICB9XHJcbiAgICBpZiAoIGdldFR5cGUodGhhdCkgPT0gXCJvYmplY3RcIil7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh0aGF0LCB7XHJcbiAgICAgICAgICAgIHNldChvYmosIHByb3AsIHZhbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9ialtwcm9wXSAhPSB2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgY2IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuICAgIC8vIGRlZmF1bHRcclxuICAgIHJldHVybiB0aGF0XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb3h5X2FycihhcnIsIGNiKSB7XHJcbiAgICBpZiAoYXJyLmxlbmd0aCAhPSAwKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYXJyW2ldID0gcHJveHlfY2F0Y2hfc2V0KGFycltpXSwgKCkgPT4gY2IoYXJyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gI3UxIGRvdWJsZSBjYWxsYmFjay5maXhlZFxyXG4gICAgcmV0dXJuIG5ldyBQcm94eShhcnIsIHtcclxuICAgICAgICBzZXQob2JqLCBwcm9wLCB2YWwpIHtcclxuICAgICAgICAgICAgdmFyIGNhbGxpbmcgPSBmYWxzZVxyXG4gICAgICAgICAgICBpZiAocHJvcCA9PSAnbGVuZ3RoJyl7XHJcbiAgICAgICAgICAgICAgICBpZihvYmpbcHJvcF0gPiB2YWwpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOS7heaUueWPmOmVv+W6puS4jeS8muS/ruaUueeJueWumnByb3BcclxuICAgICAgICAgICAgICAgICAgICAvLyBwb3BcclxuICAgICAgICAgICAgICAgICAgICBjYWxsaW5nID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gcHVzaDog5YiG5Yir6ZyA6KaB6K6+572u5pawcHJvcOeahOWAvOW5tuiuvue9rmxlbmd0aCzlj6rnlKhjYWxsaW5n5LiA5qyhXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gcHVzaCBvciBhZGQgXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9ialtwcm9wXSAhPSB2YWwpe1xyXG4gICAgICAgICAgICAgICAgY2FsbGluZyA9IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZighaXNOYU4ocHJvcCkpb2JqW3Byb3BdID0gcHJveHlfY2F0Y2hfc2V0KHZhbCwgKCkgPT4gY2Iob2JqKSlcclxuICAgICAgICAgICAgZWxzZSBvYmpbcHJvcF0gPSB2YWxcclxuICAgICAgICAgICAgLy8gcmVuZGVyIGNhbGxiYWNrXHJcbiAgICAgICAgICAgIGlmKGNhbGxpbmcpY2Iob2JqKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxufVxyXG5cclxuY29uc3QgJCA9ICguLi5hcmdzKSA9PiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yLmFwcGx5KGRvY3VtZW50LGFyZ3MpXHJcbmNvbnN0ICQkID0gKC4uLmFyZ3MpID0+IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwuYXBwbHkoZG9jdW1lbnQsYXJncylcclxuXHJcbi8vICZndDsgPT4gPlxyXG4vLyAmbHQ7ID0+IDxcclxuLy8gLi4uXHJcbmNvbnN0IGVzY2FwZTJIdG1sID0gcyA9PiBzLnJlcGxhY2UoLyYobHR8Z3R8bmJzcHxhbXB8cXVvdCk7L2lnLChhbGwsdCk9Pih7J2x0JzonPCcsJ2d0JzonPicsJ25ic3AnOicgJywnYW1wJzonJicsJ3F1b3QnOidcIid9KVt0XSk7XHJcbi8vIHRyaW0gYW5kIG1lcmdlIFxcclxcblxyXG5jb25zdCB0cmltQnIgPSBzID0+IHMucmVwbGFjZSgvKChcXHN8ICkqXFxyP1xcbil7Myx9L2csXCJcXHJcXG5cXHJcXG5cIikucmVwbGFjZSgvXigoXFxzfCApKlxccj9cXG4pKy9nLCcnKS5yZXBsYWNlKC8oKFxcc3wgKSpcXHI/XFxuKSskL2csJycpO1xyXG5jb25zdCBtZXJnZVNwYWNlID0gcyA9PiBzLnJlcGxhY2UoLyhcXHN8ICkrL2csJyAnKTtcclxuZnVuY3Rpb24gSFRNTENsZWFuKHRleHQpe1xyXG4gICAgcmV0dXJuIGVzY2FwZTJIdG1sKG1lcmdlU3BhY2UodHJpbUJyKHRleHQpKSlcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBkZWVwQ2xvbmUsXHJcbiAgICBleHRlbmQsXHJcbiAgICBhcnJNZXJnZSxcclxuICAgIGV2X3N1cExpc3Q6IHN1cHBvcnRfbGlzdCxcclxuICAgIEdldEF0dHJFbGVtZW50LFxyXG4gICAgcHJveHlBcnI6IHByb3h5X2FycixcclxuICAgICQsJCQsXHJcbiAgICBIVE1MQ2xlYW5cclxufTtcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/util/util.js\n");

/***/ })

/******/ });